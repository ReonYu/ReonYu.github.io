<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="挪威的森林">
<meta name="keywords" content="路漫漫其修远兮，吾将上下而求索">
<meta property="og:type" content="website">
<meta property="og:title" content="Leon">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Leon">
<meta property="og:description" content="挪威的森林">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leon">
<meta name="twitter:description" content="挪威的森林">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Leon</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Live for Real</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-commonweal">
      
    

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeats"></i>Commonweal 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/个人简历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/06/14/个人简历/" class="post-title-link" itemprop="url">个人简历</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-06-14 16:35:18" itemprop="dateCreated datePublished" datetime="2019-06-14T16:35:18+08:00">2019-06-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 16:36:26" itemprop="dateModified" datetime="2019-10-10T16:36:26+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul>
<li>喻~/男/1993</li>
<li>本科/西安邮电大学电子信息工程系</li>
<li>工作年限：2年3个月</li>
<li>技术博客：<a href="https://reonyu.github.io" target="_blank" rel="noopener">https://reonyu.github.io</a></li>
<li>Github：<a href="https://github.com/ReonYu" target="_blank" rel="noopener">https://github.com/ReonYu</a></li>
<li>期望薪资：税前月薪15k~20k</li>
<li>所在城市：北京</li>
</ul>
<h3 id="工作-实践经历"><a href="#工作-实践经历" class="headerlink" title="工作 + 实践经历"></a>工作 + 实践经历</h3><ul>
<li>北京东方国信科技股份公司(大数据研发) (2017.7 ~ Now )</li>
<li>2017.1 - 2017.6 东方国信（北京）-云计算部(实习)</li>
<li>2016.9 - 2016.12 神州数码（西安）-技术研发部(实习)</li>
</ul>
<h3 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h3><ul>
<li>项目管理: Svn、Maven、Git、JIRA、Confluence</li>
<li>设计语言: Java、Shell、SQL</li>
<li>应用框架: Spring、Flink、Hadoop、Kafka、Spark、JPA、Zookeeper、Dobbo、Netty</li>
<li>部署测试: Docker、Xcode、GitHub、Jenkins、Sonar</li>
</ul>
<h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><ul>
<li>1 目前工作主要涉及后端应用开发及大数据应用，有大数据企业级应用开发经验，参与过运营商大数据平台建设；</li>
<li>2 熟悉系统对接流程，有分布式系统开发经验；</li>
<li>3 追求高质量代码，有源码阅读经验；</li>
</ul>
<h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><ul>
<li>手机：18829288613 </li>
<li>Email：<a href="mailto:yxy013@163.com" target="_blank" rel="noopener">yxy013@163.com</a> </li>
<li>QQ：43286734</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="流服务应用平台-2019-07-2019-10"><a href="#流服务应用平台-2019-07-2019-10" class="headerlink" title="流服务应用平台(2019/07-2019/10)"></a>流服务应用平台(2019/07-2019/10)</h3><ul>
<li>项目描述:</li>
</ul>
<p>该项目基于B/S前后端分离架构,打造以电信运营商海量数据为基础,针对丰富的数据来源,打造以数流为载体,多租户的数据共享平台.主要功能包括数据源注册,数据服务定义,流服务产品发布,订阅,流程审批,数据源管理等.</p>
<ul>
<li>实现技术:</li>
</ul>
<p>Flink + Kafka + Flume + SpringBoot + MyBatis + Mysql + Redis</p>
<ul>
<li>职责描述:</li>
</ul>
<p>作为两位核心开发之一,主要负责参与需求分析与后台开发,同时负责需求整理与项目推进.主要负责资源管理,服务编排及服务发布订阅模块的开发设计.</p>
<h3 id="云化ETL-2018-08-2019-06"><a href="#云化ETL-2018-08-2019-06" class="headerlink" title="云化ETL(2018/08-2019/06)"></a>云化ETL(2018/08-2019/06)</h3><ul>
<li>项目描述:</li>
</ul>
<p>该项目采用基于B/S的前后端分离架构,提供平台式的可视化数据管理,支持多源、异构数据采集迁移,分布式执行,任务监控预警.以数据的采集、管理为核心，提供可视化、线上配置、自动执行的大数据采集交换平台.支持常用数据源包括oracle、mysql、ftp、hdfs、cirroData、hbase、hive、redis等.</p>
<ul>
<li><p>实现技术:</p>
</li>
<li><p>SpringBoot + MyBatis + Dubbo + ActiveMQ + Redis + MySQL + Shell + Sqoop + Sqlldr + Hadoop</p>
</li>
<li><p>职责描述:</p>
</li>
</ul>
<p>1、独立负责任务定义及调度模块的开发设计工作;<br>2、负责执行代理的开发设计工作;</p>
<h3 id="能力开放平台-2017-10-2018-07"><a href="#能力开放平台-2017-10-2018-07" class="headerlink" title="能力开放平台(2017/10-2018/07)"></a>能力开放平台(2017/10-2018/07)</h3><ul>
<li><p>项目描述:</p>
<p>该项目是依托联通数据中心超大规模计算资源、存储资源及海量数据处理能力，结合特定的业务场景，构建出的一个数据域的企业级云平台.平台包括多租户,安全管理,流程审批,能力管理,云化ETL,数据平台等.项目采用B/S分离架构,后端包括多套微服务系统.</p>
</li>
<li><p>实现技术:</p>
<p>Mysql + SpringMVC + Docker + Feign + Shiro</p>
</li>
<li><p>职责描述:</p>
</li>
</ul>
<p>1、负责对接集成后端工单审批系统,应用Feign+ Rest 完成;<br>2、借助jsch框架,完成大数据组件自动化部署功能;</p>
<h3 id="互联网日志采集-2017-01-2017-09"><a href="#互联网日志采集-2017-01-2017-09" class="headerlink" title="互联网日志采集(2017/01-2017/09)"></a>互联网日志采集(2017/01-2017/09)</h3><ul>
<li><p>项目描述:</p>
<p>该项目主要由互联网日志生产（日志生产），解析（规则库建设），实例库（爬虫，处理），实时引擎（实时解析，场景化营销）四部分组成,各种数据通过各系统解析后即沉淀为信息库,支撑上游需求。</p>
</li>
<li><p>相关技术:</p>
<p>SQL  + ELK + Kafka + Hadoop + Hive + HBase + Mysql</p>
</li>
<li><p>职责描述:</p>
</li>
</ul>
<p>1、负责数据迁移,互联网地址标签梳理,搭建结合爬虫与ELK爬虫的数据可视化;<br>2、编写了Kafka Stream 接入Kafka数据,对对应数据清洗，格式转换，字段提取，与动态更新码表匹配规则，号码数据统计并更新（峰值处理600W每天）;</p>
<h3 id="演讲和讲义"><a href="#演讲和讲义" class="headerlink" title="演讲和讲义"></a>演讲和讲义</h3><ul>
<li>9月公司内部分享：<a href="https://reonyu.github.io/2017/08/09/%E6%B5%85%E8%B0%88%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/" target="_blank" rel="noopener">云计算纵览</a><ul>
<li>小组技术分析：<a href="https://reonyu.github.io/2018/05/10/docker/" target="_blank" rel="noopener">docker</a></li>
</ul>
</li>
</ul>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/10/浅尝Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/02/10/浅尝Spring/" class="post-title-link" itemprop="url">浅尝Spring</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-02-10 12:59:34" itemprop="dateCreated datePublished" datetime="2019-02-10T12:59:34+08:00">2019-02-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 13:04:59" itemprop="dateModified" datetime="2019-10-10T13:04:59+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。</p>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><ul>
<li><strong>轻量级</strong>：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。</li>
<li><strong>控制反转(IOC)</strong>：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</li>
<li><strong>面向切面编程(AOP)</strong>： Spring支持面向切面编程，同时把应用的<strong>业务逻辑与系统的服务分离开来</strong>。</li>
<li><strong>容器</strong>：Spring包含并管理应用程序对象的配置及生命周期。</li>
<li><strong>MVC框架</strong>：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。</li>
<li><strong>事务管理</strong>：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。</li>
<li><strong>异常处理</strong>：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</li>
</ul>
<h2 id="Spring框架有哪些模块"><a href="#Spring框架有哪些模块" class="headerlink" title="Spring框架有哪些模块"></a>Spring框架有哪些模块</h2><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成、Web、AOP（面向切面编程）、测试模块。<br><img src="/assets/spring.png" alt></p>
<ul>
<li><strong>核心容器模块</strong>：是spring中最核心的模块。负责Bean的创建、配置和管理。主要包括：beans,core,context,expression等模块。</li>
<li><strong>Spring的AOP模块</strong>：主要负责对面向切面编程的支持，帮助应用对象解耦。</li>
<li><strong>数据访问和集成模块</strong>：包括JDBC，ORM，OXM，JMS和事务处理模块，其细节如下：<ul>
<li>JDBC模块提供了不再需要冗长的JDBC编码相关了JDBC的抽象层。</li>
<li>ORM（Object Relational Mapping，对象关系映射）模块提供的集成层。流行的对象关系映射API，包括JPA，JDO，Hibernate和iBatis。</li>
<li>OXM模块提供了一个支持对象/ XML映射实现对JAXB，Castor，使用XMLBeans，JiBX和XStream 的抽象层。</li>
<li>Java消息服务JMS模块包含的功能为生产和消费的信息。</li>
<li>事务模块支持编程和声明式事务管理实现特殊接口类，并为所有的POJO。</li>
</ul>
</li>
<li><strong>Web和远程调用</strong>：包括web,servlet,struts,portlet模块。</li>
<li><strong>测试模块</strong>：test</li>
</ul>
<h2 id="什么是控制反转-IOC-？什么是依赖注入？"><a href="#什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IOC)？什么是依赖注入？"></a>什么是控制反转(IOC)？什么是依赖注入？</h2><p>传统模式中对象的调用者需要创建被调用对象，两个对象过于耦合，不利于变化和拓展．在spring中，直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理，从而实现对象之间的松耦合。<strong>所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器</strong>。</p>
<p><strong>依赖注入</strong>：对象无需自行创建或管理它们的依赖关系，IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。依赖注入能让相互协作的软件组件保持松散耦合。</p>
<h2 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h2><ul>
<li>Bean工厂(BeanFactory)是Spring框架最核心的接口，提供了高级IOC的配置机制．</li>
<li>应用上下文(ApplicationContext)建立在BeanFacotry基础之上，提供了更多面向应用的功能，如果国际化，属性编辑器，事件等等．</li>
<li>beanFactory是spring框架的基础设施，是面向spring本身。ApplicationContext是面向使用Spring框架的开发者，几乎所有场合都会用到ApplicationContext.</li>
</ul>
<h2 id="Spring有几种配置方式？"><a href="#Spring有几种配置方式？" class="headerlink" title="Spring有几种配置方式？"></a>Spring有几种配置方式？</h2><p>将Spring配置到应用开发中有以下三种方式：</p>
<ul>
<li><strong>基于XML的配置</strong>:</li>
<li><strong>基于注解的配置</strong>： Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果</li>
<li><strong>基于Java的配置</strong>： Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean> 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。</bean></li>
</ul>
<h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p><img src="/assets/beans.png" alt></p>
<p>Bean在Spring中的生命周期如下：</p>
<ul>
<li><strong>实例化</strong>：Spring通过new关键字将一个Bean进行实例化。</li>
<li><strong>填入属性</strong>：spring将值和bean引用注入到bean 的属性中。</li>
<li>如果Bean实现了<strong>BeanNameAware</strong>接口，工厂调用Bean的<strong>setBeanName()</strong>方法传递Bean的ID。</li>
<li>如果Bean实现了<strong>BeanFactoryAware</strong>接口，工厂调用<strong>setBeanFactory()</strong>方法传入工厂自身。</li>
<li>如果实现了<strong>ApplicationContextAware</strong>, spring将调用setApplicationContext()方法，将bean所在的上下文的引用 进来。</li>
<li>如果<strong>BeanPostProcessor</strong>和Bean关联，那么它们的<strong>postProcessBeforeInitialization()</strong>方法将被调用。</li>
<li>如果Bean指定了init-method方法，它将被调用。</li>
<li>如果有<strong>BeanPostProcessor</strong>和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用</li>
<li>最后如果配置了destroy-method方法则注册<strong>DisposableBean</strong>.</li>
</ul>
<p><strong>使用：</strong>到这个时候，Bean已经可以被应用系统使用了，并且将被保留在Bean Factory中知道它不再需要。</p>
<p><strong>销毁</strong>。如果Bean实现了DisposableBean接口，就调用其destroy方法。有两种方法可以把它从Bean Factory中删除掉：</p>
<ol>
<li>如果Bean实现了DisposableBean接口，destory()方法被调用。</li>
<li>如果指定了订制的销毁方法，就调用这个方法。destory-method（）配置时指定。</li>
</ol>
<p>对几个重要接口的解释：</p>
<ul>
<li><strong>BeanNameAware</strong>: 实现该接口可以获得本身bean的id属性，获得在配置文件中定义好的Bean的ID名</li>
<li><strong>BeanFactoryAware</strong>：实现这个接口的bean其实是希望知道自己属于哪一个BeanFactory, 是哪个BeanFactory创建的。</li>
<li><strong>ApplicationContextAware</strong>：当一个类实现了这个接口之后，这个类就可以方便地获得 ApplicationContext 中的所有bean。换句话说，就是这个类可以直接获取Spring配置文件中，所有有引用到的bean对象。</li>
<li><strong>BeanPostProcessor</strong>是Spring中定义的一个接口，其与InitializingBean和DisposableBean接口类似，也是供Spring进行回调的。Spring将在初始化bean前后对BeanPostProcessor实现类进行回调，Spring容器通过BeanPostProcessor给了我们一个机会对Spring管理的bean进行再加工。比如：我们可以修改bean的属性，可以给bean生成一个动态代理实例等等。参考: <a href="https://www.jianshu.com/p/1417eefd2ab1" target="_blank" rel="noopener">利用BeanPostProcessor做版本切换</a></li>
</ul>
<h2 id="Spring-Bean的作用域之间有什么区别"><a href="#Spring-Bean的作用域之间有什么区别" class="headerlink" title="Spring Bean的作用域之间有什么区别"></a>Spring Bean的作用域之间有什么区别</h2><ul>
<li><strong>singleton</strong>：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</li>
<li><strong>prototype</strong>：原形范围与单例范围相反，为每一个bean请求提供一个实例。</li>
<li><strong>request</strong>：在请求bean范围内会每一个来自<strong>客户端的网络请求</strong>创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li>
<li><strong>Session</strong>：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li><strong>global-session</strong>：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</li>
</ul>
<h2 id="请解释自动装配模式的区别"><a href="#请解释自动装配模式的区别" class="headerlink" title="请解释自动装配模式的区别"></a>请解释自动装配模式的区别</h2><ul>
<li><p><strong>no</strong>：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</p>
</li>
<li><p><strong>byName**</strong>：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p>
</li>
<li><p><strong>byType</strong>：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p>
</li>
<li><p><strong>constructor</strong>：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</p>
</li>
<li><p><strong>autodetect</strong>：该模式自动探测<strong>使用构造器自动装配或者byType自动装配</strong>。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</p>
</li>
</ul>
<h2 id="Spring-框架中都用到了哪些设计模式"><a href="#Spring-框架中都用到了哪些设计模式" class="headerlink" title="Spring 框架中都用到了哪些设计模式"></a>Spring 框架中都用到了哪些设计模式</h2><ul>
<li><strong>代理模式</strong>—在AOP和remoting中被用的比较多。 </li>
<li><strong>单例模式</strong>—在spring配置文件中定义的bean默认为单例模式。</li>
<li><strong>模板方法</strong>—用来解决代码重复的问题. 比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li><strong>工厂模式</strong>—BeanFactory用来创建对象的实例。</li>
<li><strong>Builder模式</strong> - 自定义配置文件的解析bean是时采用builder模式，一步一步地构建一个beanDefinition</li>
<li><strong>策略模式</strong> ：Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。这里主要看一下代理对象创建的策略模式的实现。前面已经了解 Spring 的代理方式有两个 <strong>Jdk 动态代理</strong>和<strong>CGLIB 代理</strong>。这两个代理方式的使用正是使用了策略模式。</li>
</ul>
<h2 id="AOP（Aspect-Oriented-Programming）是怎么实现的"><a href="#AOP（Aspect-Oriented-Programming）是怎么实现的" class="headerlink" title="AOP（Aspect-Oriented Programming）是怎么实现的"></a>AOP（Aspect-Oriented Programming）是怎么实现的</h2><p>实现AOP的技术，主要分为两大类：</p>
<ul>
<li>一是采用<strong>动态代理技术</strong>，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>二是采用<strong>静态织入的方式</strong>，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ul>
<p>Spring AOP 的实现原理其实很简单：AOP 框架负责动态地生成 AOP 代理类，这个代理类的方法则由 Advice和回调目标对象的方法所组成, 并将该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异，AOP方法在特定切入点添加了<strong>增强处理，并回调了目标对象的方法</strong>。</p>
<p>Spring AOP使用动态代理技术在运行期织入增强代码。使用两种代理机制：<strong>基于JDK的动态代理</strong>（JDK本身只提供接口的代理）和<strong>基于CGlib的动态代理</strong>。</p>
<ul>
<li><strong>(1) JDK的动态代理</strong></li>
</ul>
<p>JDK的动态代理主要涉及java.lang.reflect包中的两个类：<strong>Proxy和InvocationHandler</strong>。其中InvocationHandler只是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态的将横切逻辑与业务逻辑织在一起。而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</p>
<p>其代理对象<strong>必须是某个接口的实现</strong>, 它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理.只能实现接口的类生成代理,而<strong>不能针对类</strong></p>
<ul>
<li><strong>(2)CGLib</strong></li>
</ul>
<p>CGLib采用<strong>底层的字节码技术</strong>，<strong>为一个类创建子类</strong>，并在子类中采用方法拦截的技术拦截所有父类的调用方法，并顺势织入横切逻辑.它运行期间生成的代理对象是目标类的扩展子类.<strong>所以无法通知final、private的方法</strong>,因为它们不能被覆写.是针对类实现代理,主要是为指定的类生成一个子类,覆盖其中方法.</p>
<p>在spring中默认情况下使用JDK动态代理实现AOP,如果proxy-target-class设置为true或者使用了优化策略那么会使用CGLIB来创建动态代理.Spring　AOP在这两种方式的实现上基本一样．以JDK代理为例，会使用JdkDynamicAopProxy来创建代理，在invoke()方法首先需要织入到当前类的增强器封装到拦截器链中，然后递归的调用这些拦截器完成功能的织入．最终返回代理对象．</p>
<p><a href="http://zhengjianglong.cn/2015/12/12/Spring/spring-source-aop/" target="_blank" rel="noopener">http://zhengjianglong.cn/2015/12/12/Spring/spring-source-aop/</a></p>
<h2 id="介绍spring的IOC实现"><a href="#介绍spring的IOC实现" class="headerlink" title="介绍spring的IOC实现"></a>介绍spring的IOC实现</h2><p>Spring　<strong>IOC主要负责创建和管理bean及bean之间的依赖关系</strong>．Spring　IOC的可分为:IOC容器的初始化和bean的加载．</p>
<p>在IOC容器初始化阶段主要是完成资源的加载(如定义bean的xml文件)，bean的解析及对解析后得到的beanDefinition的进行注册．以xmlBeanFactory为例，XmlBeanFactory继承了DefaultListableBeanFactory，XmlBeanFactory将读取xml配置文件，解析bean和注册解析后的beanDefinition工作交给XmlBeanDefinitionReader(是BeanDefinitionReader接口的一个个性化实现)来执行.</p>
<ul>
<li><p>1) spring中定义了一套资源类，将文件，class等都看做资源．所以首先是将xml文件转化为资源然后用EncodeResouce来封装，该功能主要时考虑Resource可能存在编码要求的情况，如UTF-8等．</p>
</li>
<li><p>2) 然后根据xml文件判断xml的约束模式，是DTD还是Schema,以及寻找模式文档(验证文件)的方法(EntityResolver，这部分采用了代理模式和策略模式)．</p>
</li>
</ul>
<p>完成了前面所有的准备工作以后就可以正式的加载配置文件，获取Document和解析注册BeanDefinition．Document的获取以及BeanDefinition的解析注册并不是由<strong>XmlBeanDefinitionReader</strong>完成，XmlBeanDefinitionReader只是将前面的工作完成以后文档加载交给<strong>DefaultDocumentLoader</strong>类来完成．</p>
<p>而解析交给了<strong>DefaultBeanDefinitionDocumentReader</strong>来处理.bean标签可以分为两种，一种是spring自带的默认标签，另一种就是用户自定义的标签．所以spring针对这两种情况，提供了不同的解析方式. 每种bean的解析完成后都会先注册到容器中然后最后发出响应事件，通知相关的监听器这个bean已经注册完成了．</p>
<p><strong>bean的加载</strong>:</p>
<p><a href="http://zhengjianglong.cn/2015/12/06/Spring/spring-source-ioc-bean-parse/" target="_blank" rel="noopener">http://zhengjianglong.cn/2015/12/06/Spring/spring-source-ioc-bean-parse/</a></p>
<h2 id="spring中bean加载机制，bean生成的具体步骤"><a href="#spring中bean加载机制，bean生成的具体步骤" class="headerlink" title="spring中bean加载机制，bean生成的具体步骤"></a>spring中bean加载机制，bean生成的具体步骤</h2><ol>
<li>容器寻找Bean的定义信息并且将其实例化。</li>
<li>如果允许提前暴露工厂，则提前暴露这个bean的工厂，这个工厂主要是返回该未完全处理的bean．主要是用于避免单例属性循环依赖问题．</li>
<li>受用<strong>依赖注入</strong>，Spring按照Bean定义信息配置Bean的所有属性。</li>
<li>如果Bean实现了<strong>BeanNameAware</strong>接口，工厂调用Bean的<strong>setBeanName()</strong>方法传递Bean的ID。</li>
<li>如果Bean实现了<strong>BeanFactoryAware</strong>接口，工厂调用<strong>setBeanFactory()</strong>方法传入工厂自身。</li>
<li>如果实现了<strong>ApplicationContextAware</strong>, spring将调用setApplicationContext()方法，将bean所在的上下文的引用 进来。</li>
<li>如果<strong>BeanPostProcessor</strong>和Bean关联，那么它们的<strong>postProcessBeforeInitialization()</strong>方法将被调用。</li>
<li>如果Bean指定了init-method方法，它将被调用。</li>
<li>如果有<strong>BeanPostProcessor</strong>和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用</li>
<li>最后如果配置了destroy-method方法则注册<strong>DisposableBean</strong>.</li>
</ol>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3978349.html</a></p>
<h2 id="springMVC流程具体叙述下"><a href="#springMVC流程具体叙述下" class="headerlink" title="springMVC流程具体叙述下"></a>springMVC流程具体叙述下</h2><p>当应用启动时, 容器会加载servlet类并调用<strong>init</strong>方法. 在这个阶段，DispatcherServlet在init()完成初始化参数<strong>init-param</strong>的解析和封装、相关配置：</p>
<ul>
<li>完成了spring的<strong>WebApplicationContext</strong>的初始化，即完成xml文件的加载、bean的解析和注册等工作。</li>
<li>另外为servlet功能所用的变量进行初始化, 如:handlerMapping, viewResolvers等.</li>
</ul>
<p>当用户发送一个请求时，首先根据请求的类型调用DispatcherServlet不同的方法，这些方法都会转发到doService()中执行．在该方法内部完成以下工作：</p>
<ol>
<li><p>spring首先考虑<strong>multipart</strong>的处理, 如果是MultipartContent类型的request,则将该请求转换成MultipartHttpServletRequest类型的request.</p>
</li>
<li><p>根据request信息获取对应的<strong>Handler</strong>. 首先根据request获取访问路径,然后根据该路径可以选择直接匹配或通用匹配的方式寻找Handler,即用户定义的controller. Handler在init()方法时已经完成加载且保存到Map中了,只要根据路径就可以得到对应的Handler. 如果不存在则尝试使用默认的Handler. 如果还是没有找到那么就通过response向用户返回错误信息. 找到handler后会将其包装在一个<strong>执行链</strong>中,然后将所有的拦截器也加入到该链中.</p>
</li>
<li><p>如果存在handler则根据当前的handler寻找对应的<strong>HandlerAdapter</strong>. 通过遍历所有适配器来选择合适的适配器.</p>
</li>
<li><p>SpringMVC允许你通过处理<strong>拦截器</strong>Web请求,进行前置处理和后置处理.所以在正式调用 Handler的逻辑方法时,先执行所有拦截器的<strong>preHandle()</strong>方法.</p>
</li>
<li><p>正式执行handle的业务逻辑方法<strong>handle()</strong>,返回ModelAndView.逻辑处理是通过适配器调用handle并返回视图.这过程其实是调用用户controller的业务逻辑.</p>
</li>
<li><p>调用拦截器的<strong>postHandle()</strong>方法,完成后置处理.</p>
</li>
<li><p>根据视图进行页面跳转.该过程首先会根据视图名字解析得到视图,该过程支持缓存,如果缓存中存在则直接获取,否则创建新的视图并在支持缓存的情况下保存到缓冲中. 该过程完成了像添加前缀后缀, 设置必须的属性等工作.最后就是进行页面跳转处理.</p>
</li>
<li><p>调用拦截器的<strong>afterCompletion()</strong></p>
</li>
</ol>
<p> 核心类说明：</p>
<ul>
<li><strong>HandlerAdapter</strong>：它的作用用一句话概括就是调用具体的方法对用户发来的请求来进行处理。当handlerMapping获取到执行请求的controller时，DispatcherServlet会根据controller对应的controller类型来调用相应的HandlerAdapter来进行处理。 </li>
</ul>
<h2 id="spring各个版本的区别"><a href="#spring各个版本的区别" class="headerlink" title="spring各个版本的区别"></a>spring各个版本的区别</h2><h2 id="ioc注入的方式"><a href="#ioc注入的方式" class="headerlink" title="ioc注入的方式"></a>ioc注入的方式</h2><ul>
<li>setter方法注入</li>
<li>构造器注入</li>
</ul>
<pre><code>&lt;!--普通构造器注入--&gt;
&lt;bean id=&quot;helloAction&quot; class=&quot;org.yoo.action.ConstructorHelloAction&quot;&gt;
&lt;!--type 必须为java.lang.String 因为是按类型匹配的，不是按顺序匹配--&gt;

    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yoo&quot;/&gt;
    &lt;!-- 也可以使用index来匹配--&gt;
    &lt;!--&lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;--&gt;
    &lt;constructor-arg&gt;&lt;ref bean=&quot;helloService&quot;/&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><ul>
<li>静态工厂注入  factory-method参数</li>
<li>实例工厂</li>
</ul>
<p><a href="http://blessht.iteye.com/blog/1162131" target="_blank" rel="noopener">http://blessht.iteye.com/blog/1162131</a></p>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><ul>
<li><p><strong>方面（Aspect）</strong>：一个<strong>关注点</strong>的模块化，这个关注点实现可能横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</p>
</li>
<li><p><strong>连接点（Joinpoint）</strong>: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。可以理解什么时机执行aop的代码。</p>
</li>
<li><p><strong>通知（Advice）:</strong> 在特定的连接点，AOP框架执行的<strong>动作</strong>(怎么执行)。各种类型的通知包括“around”、“before”和“throws”等通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了5个advice:</p>
<ul>
<li>Interception Around：JointPoint前后调用</li>
<li>Before：JointPoint前调用</li>
<li>After Returning：JointPoint后调用</li>
<li>Throw：JoinPoint抛出异常时调用</li>
<li>Introduction：JointPoint调用完毕后调用</li>
</ul>
</li>
<li><p><strong>切入点（Pointcut）</strong>: 一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p>
</li>
<li><p><strong>引入（Introduction）</strong>: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p>
</li>
<li><p><strong>目标对象（Target Object）</strong>: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
</li>
<li><p><strong>AOP代理（AOP Proxy）</strong>: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
</li>
<li><p><strong>织入（Weaving）</strong>: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
</li>
</ul>
<h2 id="spring何时创建applicationContext-web-xml中使用listener-或dispatcherServlet"><a href="#spring何时创建applicationContext-web-xml中使用listener-或dispatcherServlet" class="headerlink" title="spring何时创建applicationContext(web.xml中使用listener 或dispatcherServlet)"></a>spring何时创建applicationContext(web.xml中使用listener 或dispatcherServlet)</h2><h2 id="listener是监听哪个事件-ServletContext创建事件"><a href="#listener是监听哪个事件-ServletContext创建事件" class="headerlink" title="listener是监听哪个事件(ServletContext创建事件)"></a>listener是监听哪个事件(ServletContext创建事件)</h2><p>ServletContextListener 接口用于监听 ServletContext 对象的创建和销毁事件:</p>
<ul>
<li>当 ServletContext 对象被创建时，激发contextInitialized (ServletContextEvent sce)方法</li>
<li>当 ServletContext 对象被销毁时，激发contextDestroyed(ServletContextEvent sce)方法。</li>
</ul>
<h2 id="过滤器与监听器的区别"><a href="#过滤器与监听器的区别" class="headerlink" title="过滤器与监听器的区别"></a>过滤器与监听器的区别</h2><p>Filter可认为是Servlet的一种“变种”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给 Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p>
<p> Java中的Filter 并不是一个标准的Servlet ，它不能处理用户请求，也不能对客户端生成响应。 主要用于对HttpServletRequest 进行预处理，也可以对HttpServletResponse 进行后处理，是个典型的处理链。优点：过滤链的好处是，执行过程中任何时候都可以打断，只要不执行chain.doFilter()就不会再执行后面的过滤器和请求的内容。而在实际使用时，就要特别注意过滤链的执行顺序问题<br> <a href="http://blog.csdn.net/sd0902/article/details/8395641" target="_blank" rel="noopener">http://blog.csdn.net/sd0902/article/details/8395641</a></p>
<p>Servlet,Filter都是针对url之类的，而Listener是针对对象的操作的，如session的创建，session.setAttribute的发生，或者在启动服务器的时候将你需要的数据加载到缓存等，在这样的事件发生时做一些事情。<br><a href="http://www.tuicool.com/articles/bmqMjm" target="_blank" rel="noopener">http://www.tuicool.com/articles/bmqMjm</a></p>
<h2 id="请描述一下java事件监听机制。"><a href="#请描述一下java事件监听机制。" class="headerlink" title="请描述一下java事件监听机制。"></a>请描述一下java事件监听机制。</h2><ul>
<li>Java的事件监听机制涉及到三个组件：事件源、事件监听器、事件对象</li>
<li>当事件源上发生操作时，它将会调用事件监听器的一个方法，并在调用这个方法时，会传递事件对象过来</li>
<li>事件监听器由开发人员编写，开发人员在事件监听器中，通过事件对象可以拿到事件源，从而对事件源上的操作进行处理。</li>
</ul>
<h2 id="解释核心容器-应用上下文-模块"><a href="#解释核心容器-应用上下文-模块" class="headerlink" title="解释核心容器(应用上下文)模块"></a>解释核心容器(应用上下文)模块</h2><p>这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。</p>
<h2 id="BeanFactory-–-BeanFactory-实例"><a href="#BeanFactory-–-BeanFactory-实例" class="headerlink" title="BeanFactory – BeanFactory 实例"></a>BeanFactory – BeanFactory 实例</h2><p>BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。最常用的BeanFactory实现是XmlBeanFactory类。</p>
<h2 id="XmlBeanFactory"><a href="#XmlBeanFactory" class="headerlink" title="XmlBeanFactory"></a>XmlBeanFactory</h2><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。</p>
<h2 id="解释AOP模块"><a href="#解释AOP模块" class="headerlink" title="解释AOP模块"></a>解释AOP模块</h2><p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<h2 id="解释抽象JDBC和DAO模块"><a href="#解释抽象JDBC和DAO模块" class="headerlink" title="解释抽象JDBC和DAO模块"></a>解释抽象JDBC和DAO模块</h2><p>通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。</p>
<h2 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h2><p>Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。</p>
<h2 id="解释web模块"><a href="#解释web模块" class="headerlink" title="解释web模块"></a>解释web模块</h2><p>Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p>
<h2 id="解释Spring-MVC模块"><a href="#解释Spring-MVC模块" class="headerlink" title="解释Spring MVC模块"></a>解释Spring MVC模块</h2><p>Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。</p>
<h2 id="ContextLoaderListener是监听什么事件"><a href="#ContextLoaderListener是监听什么事件" class="headerlink" title="ContextLoaderListener是监听什么事件"></a>ContextLoaderListener是监听什么事件</h2><p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</p>
<h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。</p>
<h2 id="IOC有什么优点？"><a href="#IOC有什么优点？" class="headerlink" title="IOC有什么优点？"></a>IOC有什么优点？</h2><p>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的<strong>测试很简单</strong>，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得<strong>松耦合</strong>得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<h2 id="应用上下文是如何实现的？"><a href="#应用上下文是如何实现的？" class="headerlink" title="应用上下文是如何实现的？"></a>应用上下文是如何实现的？</h2><p>ClassPathXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。</p>
<p>FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。</p>
<p>WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。</p>
<h2 id="有哪些不同类型的IOC-依赖注入"><a href="#有哪些不同类型的IOC-依赖注入" class="headerlink" title="有哪些不同类型的IOC(依赖注入)"></a>有哪些不同类型的IOC(依赖注入)</h2><p><strong>接口注入</strong>:接口注入的意思是通过接口来实现信息的注入，而其它的类要实现该接口时，就可以实现了注入</p>
<p>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</p>
<p>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
<h2 id="你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？"><a href="#你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？" class="headerlink" title="你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？"></a>你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？</h2><p>你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。</p>
<h2 id="什么是Spring-Beans"><a href="#什么是Spring-Beans" class="headerlink" title="什么是Spring Beans"></a>什么是Spring Beans</h2><p>Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。</p>
<p>在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。</p>
<h2 id="Spring-Bean中定义了什么内容？"><a href="#Spring-Bean中定义了什么内容？" class="headerlink" title="Spring Bean中定义了什么内容？"></a>Spring Bean中定义了什么内容？</h2><p>Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p>
<h2 id="如何向Spring-容器提供配置元数据"><a href="#如何向Spring-容器提供配置元数据" class="headerlink" title="如何向Spring 容器提供配置元数据"></a>如何向Spring 容器提供配置元数据</h2><p>有三种方式向Spring 容器提供元数据:</p>
<ul>
<li>XML配置文件</li>
<li>基于注解配置</li>
<li>基于Java的配置</li>
</ul>
<h2 id="Spring框架中单例beans是线程安全的吗？"><a href="#Spring框架中单例beans是线程安全的吗？" class="headerlink" title="Spring框架中单例beans是线程安全的吗？"></a>Spring框架中单例beans是线程安全的吗？</h2><p>不是，Spring框架中的单例beans不是线程安全的。</p>
<p><strong>Spring框架并没有对单例bean进行任何多线程的封装处理</strong>。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</p>
<h2 id="哪些是最重要的bean生命周期方法？能重写它们吗？"><a href="#哪些是最重要的bean生命周期方法？能重写它们吗？" class="headerlink" title="哪些是最重要的bean生命周期方法？能重写它们吗？"></a>哪些是最重要的bean生命周期方法？能重写它们吗？</h2><p>有两个重要的bean生命周期方法。</p>
<ul>
<li>第一个是setup方法，该方法在容器加载bean的时候被调用。</li>
<li>第二个是teardown方法，该方法在bean从容器中移除的时候调用。</li>
<li>bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。</li>
</ul>
<h2 id="什么是Spring的内部bean"><a href="#什么是Spring的内部bean" class="headerlink" title="什么是Spring的内部bean"></a>什么是Spring的内部bean</h2><p>当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。</p>
<h2 id="如何在Spring中注入Java集合类"><a href="#如何在Spring中注入Java集合类" class="headerlink" title="如何在Spring中注入Java集合类"></a>如何在Spring中注入Java集合类</h2><p>Spring提供如下几种类型的集合配置元素：</p>
<ul>
<li>list元素用来注入一系列的值，允许有相同的值。</li>
<li>set元素用来注入一些列的值，不允许有相同的值。</li>
<li>map用来注入一组”键-值”对，键、值可以是任何类型的。</li>
<li>props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</li>
</ul>
<h2 id="什么是bean-wiring？"><a href="#什么是bean-wiring？" class="headerlink" title="什么是bean wiring？"></a>什么是bean wiring？</h2><p>Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。</p>
<h2 id="什么是bean自动装配？"><a href="#什么是bean自动装配？" class="headerlink" title="什么是bean自动装配？"></a>什么是bean自动装配？</h2><p>Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&lt; property&gt;元素。</p>
<h2 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h2><p>自动装配有如下局限性：</p>
<ul>
<li>重写：你仍然需要使用 和&lt; property&gt;设置指明依赖，这意味着总要重写自动装配。</li>
<li>原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。</li>
<li>模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。</li>
</ul>
<h2 id="你可以在Spring中注入null或空字符串吗"><a href="#你可以在Spring中注入null或空字符串吗" class="headerlink" title="你可以在Spring中注入null或空字符串吗"></a>你可以在Spring中注入null或空字符串吗</h2><p>完全可以。</p>
<h2 id="什么是Spring基于Java的配置？给出一些注解的例子"><a href="#什么是Spring基于Java的配置？给出一些注解的例子" class="headerlink" title="什么是Spring基于Java的配置？给出一些注解的例子"></a>什么是Spring基于Java的配置？给出一些注解的例子</h2><p>基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。</p>
<h2 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h2><p>另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。</p>
<h2 id="如何开启注解装配？"><a href="#如何开启注解装配？" class="headerlink" title="如何开启注解装配？"></a>如何开启注解装配？</h2><p>注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。<a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a></p>
<h2 id="Required-注解"><a href="#Required-注解" class="headerlink" title="@Required 注解"></a>@Required 注解</h2><p>@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。</p>
<h2 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired 注解"></a>@Autowired 注解</h2><p>@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<h2 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a>@Qualifier 注解</h2><p>当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。</p>
<h2 id="在Spring框架中如何更有效的使用JDBC？"><a href="#在Spring框架中如何更有效的使用JDBC？" class="headerlink" title="在Spring框架中如何更有效的使用JDBC？"></a>在Spring框架中如何更有效的使用JDBC？</h2><p>使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate。</p>
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p>JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。</p>
<h2 id="Spring对DAO的支持"><a href="#Spring对DAO的支持" class="headerlink" title="Spring对DAO的支持"></a>Spring对DAO的支持</h2><p>Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。</p>
<h2 id="Spring支持的ORM"><a href="#Spring支持的ORM" class="headerlink" title="Spring支持的ORM"></a>Spring支持的ORM</h2><p>Spring支持一下ORM：</p>
<ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA (Java -Persistence API)</li>
<li>TopLink</li>
<li>JDO (Java Data Objects)</li>
<li>OJB</li>
</ul>
<h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持如下两种方式的事务管理：</p>
<ul>
<li><p><strong>编码式事务管理</strong>：sping对编码式事务的支持与EJB有很大区别，不像EJB与java事务API耦合在一起．spring通过回调机制将实际的事务实现从事务性代码中抽象出来．<strong>你能够精确控制事务的边界，它们的开始和结束完全取决于你</strong>．</p>
</li>
<li><p><strong>声明式事务管理</strong>：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。通过传播行为，隔离级别，回滚规则，事务超时，只读提示来定义．</p>
</li>
</ul>
<h2 id="Spring框架的事务管理有哪些优点"><a href="#Spring框架的事务管理有哪些优点" class="headerlink" title="Spring框架的事务管理有哪些优点"></a>Spring框架的事务管理有哪些优点</h2><ul>
<li>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。</li>
<li>它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).</li>
<li>它支持声明式事务管理。</li>
<li>它可以和Spring 的多种数据访问技术很好的融合。</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li><strong>原子性(Atomic)</strong>: 一个操作要么成功，要么全部不执行.</li>
<li><strong>一致性(Consistent)</strong>: 一旦事务完成，系统必须确保它所建模业务处于一致的状态</li>
<li><strong>隔离性(Isolated)</strong>: 事务允许多个用户对相同的数据进行操作，每个用户用户的操作相互隔离互补影响．</li>
<li><strong>持久性(Durable)</strong>: 一旦事务完成，事务的结果应该持久化．</li>
</ul>
<h2 id="spring事务定义的传播规则"><a href="#spring事务定义的传播规则" class="headerlink" title="spring事务定义的传播规则"></a>spring事务定义的传播规则</h2><ul>
<li><strong>PROPAGATION_REQUIRED</strong>: 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li><strong>PROPAGATION_SUPPORTS</strong>: 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li><strong>PROPAGATION_MANDATORY</strong>: 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong>: 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li><strong>PROPAGATION_NOT_SUPPORTED</strong>: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><strong>PROPAGATION_NEVER</strong>: 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><strong>PROPAGATION_NESTED</strong>: 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 </li>
</ul>
<h2 id="spring事务支持的隔离级别"><a href="#spring事务支持的隔离级别" class="headerlink" title="spring事务支持的隔离级别"></a>spring事务支持的隔离级别</h2><p>并发会导致以下问题：</p>
<ul>
<li><strong>脏读</strong>：发生在一个事务读取了另一个事务改写但尚未提交的数据．</li>
<li><strong>不可重复读</strong>：在一个事务执行相同的查询两次或两次以上，每次得到的数据不同．</li>
<li><strong>幻读</strong>：与不可重复读类似，发生在一个事务读取多行数据，接着另一个并发事务插入一些数据，随后查询中，第一个事务发现多了一些原本不存在的数据．</li>
</ul>
<p>spring 事务上提供以下的隔离级别:</p>
<ul>
<li><strong>ISOLATION_DEFAULT</strong>: 使用后端数据库默认的隔离级别，大多数数据库系统的默认隔离级别是READ COMMITTED。</li>
<li><strong>ISOLATION_READ_UNCOMMITTED</strong>: 允许<strong>读取未提交</strong>的数据变更，可能会导致<strong>脏读</strong>，幻读或不可重复读</li>
<li><strong>ISOLATION_READ_COMMITTD</strong>: 允许读取为<strong>提交数据</strong>,可以阻止脏读，当时幻读或不可重复读仍可能发生</li>
<li><strong>ISOLATION_REPEATABLE_READ</strong>: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生</li>
<li><strong>ISOLATION_SERIALIZABLE</strong>:　完全服从ACID</li>
</ul>
<h2 id="你更推荐那种类型的事务管理？"><a href="#你更推荐那种类型的事务管理？" class="headerlink" title="你更推荐那种类型的事务管理？"></a>你更推荐那种类型的事务管理？</h2><p>许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。</p>
<h2 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h2><ul>
<li><strong>BeanNameAutoProxyCreator</strong>：bean名称自动代理创建器</li>
<li><strong>DefaultAdvisorAutoProxyCreator</strong>：默认通知者自动代理创建器</li>
<li><strong>Metadata autoproxying</strong>：元数据自动代理</li>
</ul>
<h2 id="什么是织入？什么是织入应用的不同点？"><a href="#什么是织入？什么是织入应用的不同点？" class="headerlink" title="什么是织入？什么是织入应用的不同点？"></a>什么是织入？什么是织入应用的不同点？</h2><p>织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。</p>
<h2 id="什么是Spring的MVC框架？"><a href="#什么是Spring的MVC框架？" class="headerlink" title="什么是Spring的MVC框架？"></a>什么是Spring的MVC框架？</h2><p>Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><p>WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。</p>
<h2 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h2><p>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</p>
<h2 id="Controller-annotation"><a href="#Controller-annotation" class="headerlink" title="@Controller annotation"></a>@Controller annotation</h2><p>@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。</p>
<h2 id="RequestMapping-annotation"><a href="#RequestMapping-annotation" class="headerlink" title="@RequestMapping annotation"></a>@RequestMapping annotation</h2><p>@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。</p>
<h2 id="MyBatis-与-Hibernate的区别"><a href="#MyBatis-与-Hibernate的区别" class="headerlink" title="MyBatis 与 Hibernate的区别"></a>MyBatis 与 Hibernate的区别</h2><p>（1）<strong>hibernate是全自动，而mybatis是半自动</strong></p>
<p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p>
<p>（2）<strong>hibernate数据库移植性远大于mybatis</strong></p>
<p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p>
<p>（3）<strong>hibernate拥有完整的日志系统，mybatis则欠缺一些</strong></p>
<p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p>
<p>（4）mybatis相比hibernate需要关心很多细节</p>
<p><strong>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高</strong>。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p>
<p>（5）<strong>sql直接优化上，mybatis要比hibernate方便很多</strong></p>
<p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p>
<p>（6）缓存机制上，hibernate要比mybatis更好一些</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>
<h2 id="JDBC-和-Hibernate的区别"><a href="#JDBC-和-Hibernate的区别" class="headerlink" title="JDBC 和　Hibernate的区别"></a>JDBC 和　Hibernate的区别</h2><h2 id="Hibernate的原理体系架构"><a href="#Hibernate的原理体系架构" class="headerlink" title="Hibernate的原理体系架构"></a>Hibernate的原理体系架构</h2><p><img src="http://my.csdn.net/uploads/201205/30/1338346660_4642.gif" alt="图片标题"><br><strong>1) SessionFactory (org.hibernate.SessionFactory)</strong><br>针对单个数据库映射关系经过编译后的内存镜像，是线程安全的（不可变）。它是生成Session的工厂，本身要用到ConnectionProvider。该对象可以在进程或集群的级别上，为那些事务之间可以重用的数据提供可选的二级缓存。</p>
<p><strong>2) Session (org.hibernate.Session)</strong><br>表示应用程序与持久储存层之间交互操作的一个单线程对象，此对象生存期很短。 其隐藏了JDBC连接，也是Transaction的工厂。其会持有一个针对持久化对象的必选（第一级）缓存，在遍历对象图或者根据持久化标识查找对象时会用到。</p>
<p><strong>3) 事务Transaction (org.hibernate.Transaction)</strong><br>（可选的）应用程序用来指定原子操作单元范围的对象，它是单线程的，生命周期很短。 它通过抽象将应用从底层具体的JDBC、JTA以及CORBA事务隔离开。 某些情况下，一个Session之内可能包含多个Transaction对象。 尽管是否使用该对象是可选的，但无论是使用底层的API还是使用Transaction对象，事务边界的开启与关闭是必不可少的。</p>
<p><strong>4) ConnectionProvider  (org.hibernate.connection.ConnectionProvider)</strong><br>（可选的）生成JDBC连接的工厂（同时也起到连接池的作用）。 它通过抽象将应用从底层的Datasource或DriverManager隔离开。 仅供开发者扩展/实现用，并不暴露给应用程序使用。</p>
<p><strong>5)TransactionFactory (org.hibernate.TransactionFactory)</strong><br>（可选的）生成Transaction对象实例的工厂。 仅供开发者扩展/实现用，并不暴露给应用程序使用。</p>
<p><strong>6) 持久的对象及其集合</strong><br>带有持久化状态的、具有业务功能的单线程对象，此对象生存期很短。 这些对象可能是普通的JavaBeans/POJO，唯一特殊的是他们正与（仅仅一个）Session相关联。 一旦这个Session被关闭，这些对象就会脱离持久化状态，这样就可被应用程序的任何层自由使用。 （例如，用作跟表示层打交道的数据传输对象。）</p>
<p><strong>7) 瞬态(transient)和脱管(detached)的对象及其集合</strong><br>那些目前没有与session关联的持久化类实例。他们可能是在被应用程序实例化后，尚未进行持久化的对象。也可能是因为实例化他们的Session已经被关闭而脱离持久化的对象。</p>
<p>参考: <a href="http://blog.sina.com.cn/s/blog_667fe4a501016awl.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_667fe4a501016awl.html</a></p>
<h2 id="五大核心接口，"><a href="#五大核心接口，" class="headerlink" title="五大核心接口，"></a>五大核心接口，</h2><p>Hibernate的核心接口一共有5个，分别为:Session、SessionFactory、Transaction、Query和 Configuration。这5个核心接口在任何开发中都会用到。通过这些接口，不仅可以对持久化对象进行存取，还能够进行事务控制。下面对这五的核心 接口分别加以介绍。 </p>
<p><strong>1) Session接口</strong>:<br>Session接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的 SQL语句。)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSesion对象称为用户session。</p>
<p><strong>2) SessionFactory接口</strong><br>SessionFactroy接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建 Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。</p>
<p><strong>3) Configuration接口</strong><br>Configuration接口负责配置并启动Hibernate，创建SessionFactory对 象。在Hibernate的启动的过程中，Configuration类的实例首先定位映射文档位置、读取配置，然后创建SessionFactory对象。</p>
<p><strong>4) Transaction接口</strong><br>Transaction接口负责事务相关的操作。它是可选的，开发人员也可以设计编写自己的底层事务处理代码。</p>
<p><strong>5) Query和Criteria接口</strong>:<br>Query和Criteria接口负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式。</p>
<p><a href="http://blog.csdn.net/martinmateng/article/details/50879436" target="_blank" rel="noopener">http://blog.csdn.net/martinmateng/article/details/50879436</a></p>
<h2 id="Hibernate对象的三种状态转换"><a href="#Hibernate对象的三种状态转换" class="headerlink" title="Hibernate对象的三种状态转换"></a>Hibernate对象的三种状态转换</h2><h3 id="1-瞬时状态-transient"><a href="#1-瞬时状态-transient" class="headerlink" title="1.瞬时状态 (transient)"></a>1.瞬时状态 (transient)</h3><p>特征：</p>
<ol>
<li>不处于Session 缓存中</li>
<li>数据库中没有对象记录</li>
</ol>
<p>Java如何进入临时状态：</p>
<ol>
<li>通过new语句刚创建一个对象时</li>
<li>当调用Session 的delete()方法，从Session 缓存中删除一个对象时。</li>
</ol>
<h3 id="2-持久化状态-persisted"><a href="#2-持久化状态-persisted" class="headerlink" title="2.持久化状态(persisted)"></a>2.持久化状态(persisted)</h3><p>特征：</p>
<ol>
<li>处于Session 缓存中</li>
<li>持久化对象数据库中设有对象记录</li>
<li>Session 在特定时刻会保持二者同步</li>
</ol>
<p>Java如何进入持久化状态</p>
<ol>
<li>Session 的save()把临时－》持久化状态</li>
<li>Session 的load(),get()方法返回的对象</li>
<li>Session 的find()返回的list集合中存放的对象</li>
<li>session 的update(),saveOrupdate()使游离－》持久化</li>
</ol>
<h3 id="3-游离状态-detached"><a href="#3-游离状态-detached" class="headerlink" title="3.游离状态(detached)"></a>3.游离状态(detached)</h3><p>特征：</p>
<ol>
<li>不再位于Session 缓存中</li>
<li>游离对象由持久化状态转变而来，数据库中可能还有对应记录。</li>
</ol>
<p>Java如何进入持久化状态－》游离状态</p>
<ol>
<li>Session 的close()方法</li>
<li>Session 的evict()方法，从缓存中删除一个对象。提高性能。少用。</li>
</ol>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h2 id="Hibernate对一二级缓存的使用"><a href="#Hibernate对一二级缓存的使用" class="headerlink" title="Hibernate对一二级缓存的使用"></a>Hibernate对一二级缓存的使用</h2><p>（1）一级缓存就是Session级别的缓存，一个Session做了一个查询操作，它会把这个操作的结果放在一级缓存中，如果短时间内这个session（一定要同一个session）又做了同一个操作，那么hibernate直接从一级缓存中拿，而不会再去连数据库，取数据；</p>
<p>（2）二级缓存就是SessionFactory级别的缓存，顾名思义，就是查询的时候会把查询结果缓存到二级缓存中，如果同一个sessionFactory创建的某个session执行了相同的操作，hibernate就会从二级缓存中拿结果，而不会再去连接数据库；</p>
<p>3）Hibernate中提供了两级Cache，第一级别的缓存是Session级别的缓存，它是属于事务范围的缓存。这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存。这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存；</p>
<p><a href="http://www.open-open.com/lib/view/open1413527015465.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1413527015465.html</a></p>
<h2 id="Lazy-Load的理解"><a href="#Lazy-Load的理解" class="headerlink" title="Lazy-Load的理解"></a>Lazy-Load的理解</h2><p>在Hibernate框架中，当我们要访问的数据量过大时，明显用缓存不太合适， 因为内存容量有限，为了减少并发量，减少系统资源的消耗，这时Hibernate用懒加载机制来弥补这种缺陷，但是这只是弥补而不是用了懒加载总体性能就提高了。我们所说的懒加载也被称为延迟加载，它在查询的时候不会立刻访问数据库，而是返回代理对象，当真正去使用对象的时候才会访问数据库。</p>
<p>1、通过Session.load()实现懒加载</p>
<p>load(Object, Serializable)：根据id查询。查询返回的是代理对象，不会立刻访问数据库，是懒加载的。当真正去使用对象的时候才会访问数据库。用load()的时候会发现不会打印出查询语句，而使用get()的时候会打印出查询语句。<br>使用load()时如果在session关闭之后再查询此对象，会报异常：could not initialize proxy - no Session。处理办法：在session关闭之前初始化一下查询出来的对象：Hibernate.initialize(user);使用load()可以提高效率，因为刚开始的时候并没有查询数据库。但很少使用。</p>
<p>2、one-to-one(元素)实现了懒加载。</p>
<p>在一对一的时候，查询主对象时默认不是懒加载。即：查询主对象的时候也会把从对象查询出来。需要把主对象配制成lazy=”true” constrained=”true” fetch=”select”。此时查询主对象的时候就不会查询从对象，从而实现了懒加载。一对一的时候，查询从对象的是默认是懒加载。即：查询从对象的时候不会把主对象查询出来。而是查询出来的是主对象的代理对象。</p>
<p>3、many-to-one（元素）实现了懒加载。<br>多对一的时候，查询主对象时默认是懒加载。即：查询主对象的时候不会把从对象查询出来。</p>
<p>4、one-to-many(元素)懒加载：默认会懒加载，这是必须的，是重常用的。<br>一对多的时候，查询主对象时默认是懒加载。即：查询主对象的时候不会把从对象查询出来。</p>
<p>参考： <a href="http://blog.csdn.net/sanjy523892105/article/details/7071139" target="_blank" rel="noopener">http://blog.csdn.net/sanjy523892105/article/details/7071139</a><br><a href="http://blog.csdn.net/yaorongwang0521/article/details/7074573" target="_blank" rel="noopener">http://blog.csdn.net/yaorongwang0521/article/details/7074573</a></p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p><strong>悲观锁 (Pessimistic Locking)</strong><br>悲观锁，正如其名，他是对数据库而言的，数据库悲观了，他感觉每一个对他操作的程序都有可能产生并发。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p>
<p>优点：数据的一致性保持得很好<br>缺点：不适合多个用户并发访问。</p>
<p><strong>乐观锁</strong><br> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个”version”字段来实现。乐观锁的工作原理：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h2 id="描述-Struts-体系结构？对应各个部分的开发工作主要包括哪些？"><a href="#描述-Struts-体系结构？对应各个部分的开发工作主要包括哪些？" class="headerlink" title="描述 Struts 体系结构？对应各个部分的开发工作主要包括哪些？"></a>描述 Struts 体系结构？对应各个部分的开发工作主要包括哪些？</h2><p>Struts开源架构很好的实现了MVC模式，MVC即Model-View-Controller的缩写，是一种常用的设计模式。MVC 减弱了业务逻辑接口和数据接口之间的耦合，以及让视图层更富于变化。在Struts2的模型 - 视图 - 控制器模式，实现以下五个核心部件：</p>
<ul>
<li>Actions</li>
<li>Interceptors</li>
<li>Value Stack / OGNL</li>
<li>Results / Result types</li>
<li>View technologies</li>
</ul>
<p>Struts 2 从传统的MVC框架操作需要的模型，而不是在控制器角色略有不同，虽然有一些重叠</p>
<p><strong>模型</strong><br>模型以一个或多个java bean的形式存在。这些bean分为三类：Action Form、Action、JavaBean or EJB。Action Form通常称之为FormBean，封装了来自于Client的用户请求信息，如表单信息。Action通常称之为ActionBean，获取从ActionSevlet传来的FormBean，取出FormBean中的相关信息，并做出相关的处理，一般是调用Java Bean或EJB等。</p>
<p><strong>视图</strong><br>主要由JSP生成页面完成视图，Struts提供丰富的JSP 标签库： Html，Bean，Logic，Template等</p>
<p><strong>控制器</strong><br>该控制器负责响应用户输入和执行数据模型对象的相互作用。控制器接收输入，验证输入，然后进行业务操作，修改数据模型的状态。</p>
<p>这个解释比较好：　<a href="http://www.yiibai.com/struts_2/struts_architecture.html" target="_blank" rel="noopener">http://www.yiibai.com/struts_2/struts_architecture.html</a><br><a href="http://www.cnblogs.com/langtianya/archive/2013/04/09/3011090.html" target="_blank" rel="noopener">http://www.cnblogs.com/langtianya/archive/2013/04/09/3011090.html</a></p>
<h2 id="什么是Struts2"><a href="#什么是Struts2" class="headerlink" title="什么是Struts2"></a>什么是Struts2</h2><p>Apache Struts2的是一个在Java中构建<strong>Web应用程序开源框架</strong>。 Struts2是基于OpenSymphony的WebWork的框架。它是Struts1的提高，它更加灵活，易于使用和扩展。 Struts2的核心组成部分是Action，拦截器和结果页。</p>
<p>Struts2提供了许多方法来创建Action类，并<strong>通过struts.xml中或通过注释进行配置</strong>。我们可以创建自己的<strong>拦截器</strong>实现常见任务。 Struts2中自带了很多的<strong>标签，并使用OGNL表达式语言</strong>。我们可以创造我们自己的类型转换器来呈现的结果页面。结果页面可以JSP和FreeMarker的模板。</p>
<h2 id="Struts-与webWork的区别"><a href="#Struts-与webWork的区别" class="headerlink" title="Struts 与webWork的区别"></a>Struts 与webWork的区别</h2><p>Struts 2是Struts的下一代产品。是在 struts 和WebWork的技术基础上进行了合并，全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构的差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与Servlet API完全脱离开，所以Struts 2可以理解为WebWork的更新产品。</p>
<p>Struts和Webwork同为服务于Web的一种MVC框架，从某种程度上看，Struts2是从WebWork2上升级得到的。甚至Apache的官方文档也讲：WebWork2到Struts2是平滑的过渡。我们甚至也可以说Struts2就是WebWork2.3而已。在很多方面Struts仅仅是改变了WebWork下的名称。Struts2对应的有自己的标签，并且功能强大。Webwork也有自己的标签。</p>
<p>1) 在很多方面Struts2仅仅是改变了WebWork下的名称,如DispatcherUtil 改为了Dispatcher.<br>2) AroundInterceptor：Struts 2不再支持WebWork中的AroundInterceptor。如果应用程序中需要使用AroundInterceptor，则应该自己手动导入WebWork中的AroundInterceptor类。<br>3) IoC容器支持：Struts 2不再支持内建的IoC容器，而改为全面支持Spring的IoC容器，以Spring的IoC容器作为默认的Object工厂。<br>4) 富文本编辑器标签：Struts 2不再支持WebWork的富文本编辑器，如果应用中需要使用富文本编辑器，则应该使用<strong>Dojo</strong>的富文本编辑器。</p>
<p><a href="http://developer.51cto.com/art/201106/271744.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201106/271744.htm</a></p>
<h2 id="struts2-与struts1的区别"><a href="#struts2-与struts1的区别" class="headerlink" title="struts2 与struts1的区别"></a>struts2 与struts1的区别</h2><p>Action类,线程安全，测试，标签，验证<br><img src="imgs/struts2-vs-struts1.png"></p>
<p><strong>Action 类:</strong><br>• Struts1要求Action类继承一个<strong>抽象</strong>基类。Struts1的一个普遍问题是使用抽象类编程而不是接口，而struts2的Action是接口。<br>• Struts 2 Action类可以实现一个Action<strong>接口</strong>，也可实现其他接口，<strong>使可选和定制的服务成为可能</strong>。Struts2提供一个ActionSupport基类去 实现 常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。</p>
<p><strong>线程模式</strong>:<br>• Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。(<strong>不是线程安全</strong>)<br>• Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）(<strong>线程安全</strong>)</p>
<p><strong>Servlet 依赖</strong>:<br>• Struts1 Action 依赖于Servlet API ,因为当一个Action被调用时HttpServletRequest 和 HttpServletResponse 被传递给execute方法。<br>• Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2 Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest 和 HttpServletResponse的必要性。</p>
<p><strong>可测性</strong>:<br>• 测试Struts1 Action的一个主要问题是execute方法暴露了servlet API（这使得测试要依赖于容器）。一个第三方扩展－－Struts TestCase－－提供了一套Struts1的模拟对象（来进行测试）。<br>• Struts 2 Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。</p>
<p><strong>表达式语言</strong>：<br>• Struts1 整合了JSTL，因此使用JSTL EL。这种EL有基本对象图遍历，但是对集合和索引属性的支持很弱。<br>• Struts2可以使用JSTL，但是也支持一个更强大和灵活的表达式语言－－”Object Graph Notation Language” (OGNL). </p>
<p><strong>绑定值到页面（view）</strong>:<br>• Struts 1使用标准JSP机制把对象绑定到页面中来访问。<br>• Struts 2 使用 “ValueStack”技术，使taglib能够访问值而不需要把你的页面（view）和对象绑定起来。ValueStack策略允许通过一系列名称相同但类型不同的属性重用页面（view）。</p>
<h2 id="Struts工作流程"><a href="#Struts工作流程" class="headerlink" title="Struts工作流程:"></a>Struts工作流程:</h2><p><img src="http://www.evget.com/images/article/08072801.png" alt="图片标题"><br>Struts2:<br>(1)客户端提交一个HttpServletRequest请求(.action或JSP页面)<br>(2)请求被提交到一系列（主要是三层）的过滤器（Filter），如（ActionContextCleanUp、其他过滤器（SiteMesh等）、 FilterDispatcher）。注意这里是有顺序的，先ActionContextCleanUp，再其他过滤器（SiteMesh等）、最后到FilterDispatcher。<br>(3)FilterDispatcher是Struts2控制器的核心,它通常是过滤器链中的最后一个过滤器,FilterDispatcher进行初始化并启用核心doFilter().FilterDispatcher询问ActionMapper是否需要调用某个Action来处理这个（request）请求，如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy。<br>(6)ActionProxy通过<strong>ConfigurationManager</strong>(它会访问struts.xml)询问框架的配置文件,找到需要调用的Action类.<br>(7)ActionProxy创建一个ActionInvocation实例,而ActionInvocation通过代理模式调用Action,(在调用之前会根据配置文件加载相关的所有Interceptor拦截器)<br>(8)Action执行完毕后,返回一个result字符串,此时再按相反的顺序通过Interceptor拦截器.<br>(9)最后ActionInvocation负责根据struts.xml中配置的result元素,找到与返回值对应的result,决定进行下一步输出.</p>
<h2 id="为什么要使用-Struts2-amp-Struts2-的优点："><a href="#为什么要使用-Struts2-amp-Struts2-的优点：" class="headerlink" title="为什么要使用 Struts2 &amp; Struts2 的优点："></a>为什么要使用 Struts2 &amp; Struts2 的优点：</h2><p>①. 基于 MVC 架构，框架结构清晰。<br>②. 使用 OGNL: OGNL 可以快捷的访问值栈中的数据、调用值栈中对象的方法<br>③. 拦截器: Struts2 的拦截器是一个 Action 级别的 AOP, Struts2 中的许多特性都是通过拦截器来实现的, 例如异常处理，文件上传，验证等。拦截器是可配置与重用的<br>④. 多种表现层技术. 如：JSP、FreeMarker、Velocity 等</p>
<h2 id="SpringMVC-与-Struts2区别"><a href="#SpringMVC-与-Struts2区别" class="headerlink" title="SpringMVC 与　Struts2区别"></a>SpringMVC 与　Struts2区别</h2><p>1.核心控制器（前端控制器、预处理控制器）：对于使用过mvc框架的人来说这个词应该不会陌生，核心控制器的主要用途是处理所有的请求，然后对那些特殊的请求 （控制器）统一的进行处理(字符编码、文件上传、参数接受、异常处理等等),spring mvc核心控制器是Servlet，而Struts2是Filter。<br>2.控制器实例：Spring Mvc会比Struts快一些（理论上）。Spring Mvc是基于方法设计，而Sturts是基于对象，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring更像Servlet一样，只有一个实例，每次请求执行对应的方法即可(注意：由于是单例实例，所以应当避免全局变量的修改，这样会产生线程安全问题)。<br>3. 管理方式：大部分的公司的核心架构中，就会使用到spring,而spring mvc又是spring中的一个模块，所以spring对于spring mvc的控制器管理更加简单方便，而且提供了全 注解方式进行管理，各种功能的注解都比较全面，使用简单，而struts2需要采用XML很多的配置参数来管理（虽然也可以采用注解，但是几乎没有公司那 样使用）。<br>4.参数传递：Struts2中自身提供多种参数接受，其实都是通过（ValueStack）进行传递和赋值，而SpringMvc是通过方法的参数进行接收。<br>5.intercepter 的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。这样导致struts的配置文件量还是比spring mvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上spring3 mvc就容易实现restful url。struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而struts2搞的就比较乱，虽然方法之间 也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。<br>7.spring mvc处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，spring mvc自动帮我们对象转换为JSON数据。</p>
<h2 id="Filter-Listener-Servlet区别"><a href="#Filter-Listener-Servlet区别" class="headerlink" title="Filter,Listener,Servlet区别"></a>Filter,Listener,Servlet区别</h2><p>1) Filter　实现javax.servlet.Filter接口，在web.xml中配置与标签指定使用哪个Filter实现类过滤哪些URL链接。只在web启动时进行初始化操作。filter流程是<strong>线性</strong>的， url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个filter, servlet接收等，而servlet 处理之后，不会继续向下传递。filter功能可用来保持流程继续按照原来的方式进行下去，或者主导流程，而servlet的功能主要用来主导流程。<br>特点：可以在响应之前修改Request和Response的头部，只能转发请求，不能直接发出响应。filter可用来进行字符编码的过滤，检测用户是否登陆的过滤，禁止页面缓存等<br>2) Servlet 流程是短的，url传来之后，就对其进行处理，之后返回或转向到某一自己指定的页面。它主要用来在业务处理之前进行控制。<br>3) Listener<br>servlet,filter都是针对url之类的，而listener是针对<strong>对象操作</strong>的，如session的创建，session.setAttribute的发生，在这样的事件发<br>生时做一些事情。</p>
<h2 id="Struts2拦截器和过滤器的区别"><a href="#Struts2拦截器和过滤器的区别" class="headerlink" title="Struts2拦截器和过滤器的区别"></a>Struts2拦截器和过滤器的区别</h2><p>①、过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器。<br>②、Struts2 拦截器只能对 Action 请求起作用，而过滤器则可以对几乎所有请求起作用。<br>③、拦截器可以访问 Action 上下文(ActionContext)、值栈里的对象(ValueStack)，而过滤器不能.<br>④、在 Action 的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。</p>
<h2 id="Struts的Action是不是线程安全的"><a href="#Struts的Action是不是线程安全的" class="headerlink" title="Struts的Action是不是线程安全的"></a>Struts的Action是不是线程安全的</h2><p> struts2的action是线程安全的，struts1的action不是线程安全的 。<br>对于struts1 ，Action是单例模式，一个实例来处理所有的请求。当第一次**.do的请求过来时，在内存中的actionmapping中找到相对应的action，然后new出这个action放在缓存中，当第二次一样的请求过来时，还是找的这个action，所以对于struts1来说，action是单实例的，只有一个，如果在action中定义变量，就要非常小心了，因为并发问题，可能带来灾难性的后果，也不是不可以，我们可以加锁达到同步，只是在性能上就 要折衷了。<br>声明局部变量，或者扩展RequestProcessor，让每次都创建一个Action，或者在spring中用scope=”prototype”来管理，不申明类变量就可以保证线程安全。因为只存在一个Action类实例，所有线程会共享类变量。<br>struts2 在struts1的基础上做了改进 ，对于struts2 ，每次请求过来都会new一个新的action, 所以说struts2的action没有线程安全问题，是线程安全的，但同时也带来一个问题，每次都new一个action ，这样action的实例太多 ， 在性能方面还是存在一定的缺陷的。</p>
<h2 id="struts2-0的mvc模式与struts1-0的区别"><a href="#struts2-0的mvc模式与struts1-0的区别" class="headerlink" title="struts2.0的mvc模式与struts1.0的区别?"></a>struts2.0的mvc模式与struts1.0的区别?</h2><p>与struts1最大的不同是：struts2的控制器。struts2的控制器不再像struts1的控制器,需要<strong>继承</strong>一个Action父类,甚至可以无需实现任何接口,struts2的Action就是一个普通的POJO。实际上，Struts2 的Action就是一个包含execute方法的普通Java类该类里包含的多个属性用于封装用户的请求参数。</p>
<h2 id="你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？"><a href="#你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？" class="headerlink" title="你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？"></a>你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？</h2><p>MVC设计模式（应用观察者模式的框架模式）<br>M: Model(Business process layer)，模型，是应用程序中用于处理应用程序数据逻辑的部分,通常模型对象负责在数据库中存取数据。,并独立于表现层 (Independent of presentation)。<br>V: View(Presentation layer)，视图，通过客户端数据类型显示数据,并回显模型层的执行结果。<br>C: Controller(Control layer)，控制器，也就是<strong>视图层和模型层桥梁</strong>，控制数据的流向，接受视图层发出的事件，并重绘视图<br>优点：<br>1）视图控制模型分离，提高代码重用性。<br>2）提高开发效率。<br>3）便于后期维护，降低维护成本。<br>4）方便多开发人员间的分工。<br>5)结构清晰<br>缺点：<br>1）清晰的构架以代码的复杂性为代价， 对小项目优可能反而降低开发效率。<br>2）运行效率相对较低 </p>
<p>MVC框架的一种实现模型<br>模型二(Servlet-centric)： JSP+Servlet+JavaBean，以控制为核心，JSP只负责显示和收集数据，Sevlet，连接视图和模型，将视图层数据，发送给模型层，JavaBean，分为业务类和数据实体，业务类处理业务数据，数据实体，承载数据，基本上大多数的项目都是使用这种MVC的实现模式。</p>
<p>Struts MVC框架(Web application frameworks)  :Struts是使用MVC的实现模式二来实现的，也就是以控制器为核心。</p>
<p>Struts提供了一些组件使用MVC开发应用程序：<br>Model：Struts 没有提供model 类。这个商业逻辑必须由Web 应用程序的开发者以JavaBean或EJB的形式提供<br>View：Struts提供了action form创建form bean, 用于在controller和view间传输数据。此外，Struts提供了自定义JSP标签库，辅助开发者用JSP创建交互式的以表单为基础的应用程序，应用程序资源文件保留了一些文本常量和错误消息，可转变为其它语言， 可用于JSP中。<br>Controller：Struts提供了一个核心的控制器FilterDispatcher，通过这个核心的控制器来调用其他用户注册了的自定义的控制器Action，自定义Action需要符合Struts的自定义Action规范，还需要在struts-config.xml的特定配置文件中进行配置，接收JSP输入字段形成Action form，然后调用一个Action控制器。Action控制器中提供了model的逻辑接口。</p>
<h2 id="说出-struts2-中至少-5-个的默认拦截器"><a href="#说出-struts2-中至少-5-个的默认拦截器" class="headerlink" title="说出 struts2 中至少 5 个的默认拦截器"></a>说出 struts2 中至少 5 个的默认拦截器</h2><p>exception；fileUpload；i18n；modelDriven；params；prepare；token；tokenSession；validation 等<br>拦截器的生命周期与工作过程 ?</p>
<h2 id="每个拦截器都是需要实现-Interceptor-接口"><a href="#每个拦截器都是需要实现-Interceptor-接口" class="headerlink" title="每个拦截器都是需要实现 Interceptor 接口"></a>每个拦截器都是需要实现 Interceptor 接口</h2><p>init()：在拦截器被创建后立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化；<br>intercept(ActionInvocation invocation)：每拦截一个动作请求，该方法就会被调用一次；<br>destroy：该方法将在拦截器被销毁之前被调用, 它在拦截器的生命周期内也只被调用一次；</p>
<h2 id="创建Action类有几种方法？"><a href="#创建Action类有几种方法？" class="headerlink" title="创建Action类有几种方法？"></a>创建Action类有几种方法？</h2><p>实现Action 接口<br>使用Struts2 @Action 元注解<br>继承ActionSupport类，必须实现 execute() 方法，返回一个可配置的字符串</p>
<p>##Struts2的拦截器执行什么模式？<br><strong>责任链模式</strong><br>过滤器decorator模式和职责链模式</p>
<h1 id="web-部分"><a href="#web-部分" class="headerlink" title="web 部分"></a>web 部分</h1><h2 id="1-servlet生命周期"><a href="#1-servlet生命周期" class="headerlink" title="1. servlet生命周期"></a>1. servlet生命周期</h2><p>servlet的声明周期周期是由servlet的容器来控制,它可以分为3个阶段:初始化,运行和销毁. </p>
<h3 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="1) 初始化阶段"></a>1) 初始化阶段</h3><p>初始化阶段主要完成以下任务: </p>
<ul>
<li>servlet容器加载servlet类,把servlet类的.class文件中的数据读到内存中. </li>
<li>servlet容器创建一个ServletConfig对象,ServletConfig对象包含了servlet的初始化配置信息. </li>
<li>servlet容器创建一个servlet对象 </li>
<li>servlet容器调用servlet的init方法进行初始化. </li>
</ul>
<h3 id="2-运行阶段"><a href="#2-运行阶段" class="headerlink" title="2) 运行阶段"></a>2) 运行阶段</h3><p>当servlet容器收到一个请求时,servlet容器会针对这个请求创建servletRequest和servletResponse对象,然后调用service方法.并把这两个参数传递给service方法.service方法通过servletRequest对象获得请求的信息,并处理该请求. 再通过servletResponse对象生成这个请求的相应结果.然后销毁servletRequest和servletResponse对象. 不管这个请求时post还是get提交的,最终这个请求都会由service方法来处理. </p>
<h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3) 销毁阶段"></a>3) 销毁阶段</h3><p>当web应用被终止时,servlet容器会调用servlet对象的destroy方法,然后销毁servlet对象. 同时也会销毁servlet对象相关联的servletConfig对象. 我们可以通过destroy方法释放servlet占用的资源.</p>
<p><a href="https://reonyu.github.io/" target="_blank" rel="noopener">https://reonyu.github.io/</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/15/面向对象-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/01/15/面向对象-Java/" class="post-title-link" itemprop="url">面向对象-Java</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-01-15 15:18:11" itemprop="dateCreated datePublished" datetime="2019-01-15T15:18:11+08:00">2019-01-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 14:06:33" itemprop="dateModified" datetime="2019-10-10T14:06:33+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- GFM-TOC -->
<ul>
<li><a href="#一三大特性">一、三大特性</a><ul>
<li><a href="#封装">封装</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#多态">多态</a></li>
</ul>
</li>
<li><a href="#二类图">二、类图</a><ul>
<li><a href="#泛化关系-generalization">泛化关系 (Generalization)</a></li>
<li><a href="#实现关系-realization">实现关系 (Realization)</a></li>
<li><a href="#聚合关系-aggregation">聚合关系 (Aggregation)</a></li>
<li><a href="#组合关系-composition">组合关系 (Composition)</a></li>
<li><a href="#关联关系-association">关联关系 (Association)</a></li>
<li><a href="#依赖关系-dependency">依赖关系 (Dependency)</a></li>
</ul>
</li>
<li><a href="#三设计原则">三、设计原则</a><ul>
<li><a href="#solid">S.O.L.I.D</a></li>
<li><a href="#其他常见原则">其他常见原则</a></li>
</ul>
</li>
<li><a href="#四、JavaIO/NIO">四、Java IO/NIO</a></li>
<li><a href="#五、JVM">五、JVM</a></li>
<li><a href="#六、thread">六、thread</a></li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
<h1 id="一、三大特性"><a href="#一、三大特性" class="headerlink" title="一、三大特性"></a>一、三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure>

<h1 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h1><p>以下类图使用 <a href="https://www.planttext.com/" target="_blank" rel="noopener">PlantUML</a> 绘制，更多语法及使用请参考：<a href="http://plantuml.com/" target="_blank" rel="noopener">http://plantuml.com/</a> 。</p>
<h2 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h2><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Generalization</span><br><span class="line"></span><br><span class="line">class Vihical</span><br><span class="line">class Car</span><br><span class="line">class Trunck</span><br><span class="line"></span><br><span class="line">Vihical &lt;|-- Car</span><br><span class="line">Vihical &lt;|-- Trunck</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h2><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Realization</span><br><span class="line"></span><br><span class="line">interface MoveBehavior</span><br><span class="line">class Fly</span><br><span class="line">class Run</span><br><span class="line"></span><br><span class="line">MoveBehavior &lt;|.. Fly</span><br><span class="line">MoveBehavior &lt;|.. Run</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h2><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Aggregation</span><br><span class="line"></span><br><span class="line">class Computer</span><br><span class="line">class Keyboard</span><br><span class="line">class Mouse</span><br><span class="line">class Screen</span><br><span class="line"></span><br><span class="line">Computer o-- Keyboard</span><br><span class="line">Computer o-- Mouse</span><br><span class="line">Computer o-- Screen</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h2><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Composition</span><br><span class="line"></span><br><span class="line">class Company</span><br><span class="line">class DepartmentA</span><br><span class="line">class DepartmentB</span><br><span class="line"></span><br><span class="line">Company *-- DepartmentA</span><br><span class="line">Company *-- DepartmentB</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h2><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Association</span><br><span class="line"></span><br><span class="line">class School</span><br><span class="line">class Student</span><br><span class="line"></span><br><span class="line">School &quot;1&quot; - &quot;n&quot; Student</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h2><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Dependency</span><br><span class="line"></span><br><span class="line">class Vihicle &#123;</span><br><span class="line">    move(MoveBehavior)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MoveBehavior &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note &quot;MoveBehavior.move()&quot; as N</span><br><span class="line"></span><br><span class="line">Vihicle ..&gt; MoveBehavior</span><br><span class="line"></span><br><span class="line">Vihicle .. N</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h1 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h1><h2 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h2><table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">全拼</th>
<th align="center">中文翻译</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SRP</td>
<td align="center">The Single Responsibility Principle</td>
<td align="center">单一责任原则</td>
</tr>
<tr>
<td align="center">OCP</td>
<td align="center">The Open Closed Principle</td>
<td align="center">开放封闭原则</td>
</tr>
<tr>
<td align="center">LSP</td>
<td align="center">The Liskov Substitution Principle</td>
<td align="center">里氏替换原则</td>
</tr>
<tr>
<td align="center">ISP</td>
<td align="center">The Interface Segregation Principle</td>
<td align="center">接口分离原则</td>
</tr>
<tr>
<td align="center">DIP</td>
<td align="center">The Dependency Inversion Principle</td>
<td align="center">依赖倒置原则</td>
</tr>
</tbody></table>
<h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h3><blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h3><blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h2 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h2><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">全拼</th>
<th align="center">中文翻译</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOD</td>
<td align="center">The Law of Demeter</td>
<td align="center">迪米特法则</td>
</tr>
<tr>
<td align="center">CRP</td>
<td align="center">The Composite Reuse Principle</td>
<td align="center">合成复用原则</td>
</tr>
<tr>
<td align="center">CCP</td>
<td align="center">The Common Closure Principle</td>
<td align="center">共同封闭原则</td>
</tr>
<tr>
<td align="center">SAP</td>
<td align="center">The Stable Abstractions Principle</td>
<td align="center">稳定抽象原则</td>
</tr>
<tr>
<td align="center">SDP</td>
<td align="center">The Stable Dependencies Principle</td>
<td align="center">稳定依赖原则</td>
</tr>
</tbody></table>
<h3 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<h3 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h3><p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h3 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h3><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<h3 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h3><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<h3 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h3><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h1 id="四、Java-IO-NIO"><a href="#四、Java-IO-NIO" class="headerlink" title="四、Java IO/NIO"></a>四、Java IO/NIO</h1><h2 id="1-1-kernel-IO-linux-IO"><a href="#1-1-kernel-IO-linux-IO" class="headerlink" title="1.1 kernel IO/linux IO"></a>1.1 kernel IO/linux IO</h2><p>用户进程进行I/O操作的时候实际上交给了kernel进行执行，kernel执行的I/O操作可以分为两个阶段：</p>
<div align="center"> <img src="../images/15267089312034.jpg" width="400"> </div>


<ul>
<li><strong>准备阶段</strong>：在执行I/O操作的时候需要等待I/O是否就绪，因为此刻IO设备在忙状态。以网络IO为例，在读取远程数据时，需要阻塞等待远程将数据发送过来，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。 </li>
</ul>
<div align="center"> <img src="../images/15267023963428.jpg" width="400"> </div>

<ul>
<li><strong>用户进程空间和内核空间的数据拷贝</strong> : 当等到数据准备好了，kernel就会将数据从从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</li>
</ul>
<p>准备阶段时，CPU内容发送指令给IO通道，让IO通道负责执行IO的读写操作。CPU不用一直阻塞可以继续执行别的逻辑，但此刻IO线程会挂起，等待IO通道读写操作完成通知。 IO通道将操作交给DMA，DMA直接连接设备控制器负责将设备控制器中的数据直接读入到内核内存中。读完成后通知通道告知IO处理完成，IO通道发送中断给CPU，原内核IO线程醒来继续执行后续工作</p>
<h2 id="1-1-I-O-模型"><a href="#1-1-I-O-模型" class="headerlink" title="1.1 I/O 模型"></a>1.1 I/O 模型</h2><p>根据IO对kernel IO操作两个阶段的感知能力可以分为一下四种IO模型：</p>
<ul>
<li><strong>阻塞（Blocking）</strong>：阻塞等待IO就绪，这期间用户线程不可以做其他事情。</li>
<li><strong>非阻塞（Non-blocking）</strong>：轮询感知IO就绪，用户线程可以做其他事情。</li>
<li><strong>同步（Synchronous）</strong>：同步等待读IO读写结果。</li>
<li><strong>异步（Asynchronous）</strong>：异步等待kernel通知IO读写结果。</li>
</ul>
<p><strong>IO阻塞和非阻塞主要关注IO的就绪状态的感知方式，同步和异步关注IO读写操作的结果获取方式</strong>。同步是指函数完成之前会一直等待；阻塞 是指系统调用的时候进程会被设置为Sleep状态直到等待的事件发生（比如有新的数据）。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞是一种<strong>调用机制</strong>，用来描述进程处理调用的方式。在IO中两者的<strong>区别主要体现在I/O未准备好时，用户线程是否可以做其他事情</strong>。比如网络读操作，根据是否需要等待kernel数据准备好。</p>
<p>阻塞是等待某个事件的就绪/发生，当前线程会被<strong>挂起</strong>，一直处于等待消息通知，不能执行其他业务。<strong>阻塞通信意味着通信方法在尝试访问套接字或者读写数据时阻塞了对套接字的访问</strong>。以网络读操作为例，用户线程在socket中调用recv函数时，如果缓冲区中没有数据，则需要一直阻塞等待服务端发来的数据，这时候线程会挂起等待。 </p>
<p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。非阻塞IO是用户线程不会一直阻塞待待IO就绪，通过不断轮询的方式来查看就绪状态。。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步是一种<strong>通信机制</strong>，涉及到调用方和被调用方，<strong>关注的是IO操作结果的获知方式，主要区别在于IO结果未返回时用户线程是否可以做其他事情</strong>：</p>
<ul>
<li><strong>同步</strong>是调用方需要保持等待直到IO操作完成，进而通过返回获得结果；</li>
<li><strong>异步</strong>则调用方在IO操作的执行过程中不需要保持等待，而是在操作完成后被动的接受（通过消息或回调）被调用方推送的结果。</li>
</ul>
<p>以下是同步和异步定义：</p>
<blockquote>
<p><strong>A synchronous I/O</strong> operation causes the requesting process to be blocked until that I/O operation completes;<br><strong>An asynchronous I/O</strong> operation does not cause the requesting process to be blocked;</p>
</blockquote>
<p>同步和异步的区别也在于在进行整个IO操作的时候会用户进程<strong>是否会阻塞等待结果</strong>，linux中IO模型中blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<h2 id="1-2-linux-I-O-模型"><a href="#1-2-linux-I-O-模型" class="headerlink" title="1.2 linux I/O 模型"></a>1.2 linux I/O 模型</h2><p>linux根据用户进程对这个两个阶段的感知方式分为5中I/O模型：</p>
<ul>
<li>阻塞I/O（bloking IO）</li>
<li>非阻塞I/O（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li>异步IO（asynchronous IO）</li>
</ul>
<h3 id="1）-阻塞IO（blocking-IO）"><a href="#1）-阻塞IO（blocking-IO）" class="headerlink" title="1） 阻塞IO（blocking IO）"></a>1） 阻塞IO（blocking IO）</h3><p>默认情况下所有的socket都是blocking</p>
<div align="center"> <img src="../images/15263482717424.jpg" width="500"> </div>

<p> 当用户进程调用了recvfrom这个系统调用，就<strong>阻塞等待结果</strong>。kernel负责完成IO操作，完成后返回给用户。用户进程需要阻塞等待kernel完成两个阶段操作：<strong>准备数据(wait for data)</strong>、 <strong>数据拷贝到用户进程空间(copy data from kenel to user)</strong>。 阻塞IO是同步阻塞IO, 准备数据阶段会阻塞并同步等待I/O结果。在准备阶段和数据拷贝阶段中，用户线程都会被阻塞。</p>
<p>使用linux中进行网络编程时，一般都从listen()、send()、recv() 等接口开始，这些接口都是阻塞型。使用这些接口可以方便构建服务器/客户机模型。下面是一个简单地“一问一答”服务器。 整体流程如下:</p>
<div align="center"> <img src="../images/15263488660716.jpg" width="300"> </div>


<p><strong>服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销。通常会对它的线程模型进行优化，后端通过一个线程池来处理多个客户端的请求接入。通过“线程池”减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务，提高系统性能。</p>
<div align="center"> <img src="../images/15263493121606.jpg" width="600"> </div>


<p>java 的BIO就是采用这种模式实现的。</p>
<h3 id="2）非阻塞IO（non-blocking-IO）"><a href="#2）非阻塞IO（non-blocking-IO）" class="headerlink" title="2）非阻塞IO（non-blocking IO）"></a>2）非阻塞IO（non-blocking IO）</h3><div align="center"> <img src="../images/15263496139671.jpg" width="500"> </div>

<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它<strong>并不会block用户进程，而是立刻返回一个error</strong>。整体流程是：</p>
<ol>
<li>用户线程轮询查看kernel是否准备好数据（datagram ready）。这个过程kernel主要处于wait for data阶段。</li>
<li>当用户调用read, kernel已准备好数据，则执行数据拷贝操作，<strong>用户线程阻塞直到数据读取完成</strong>。kernel读取数据完成后，返回给用户数据。 </li>
</ol>
<p>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p><strong>在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有，非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。</strong></p>
<p><strong>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的</strong>，因此属于同步IO。</p>
<p>优点：</p>
<ol>
<li>用户进程不会被阻塞，可以在期间做一些别的事情。</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户线程不知道什么时候完成，需要不断的轮询查看I/O操作结果。看是否已经读取完成，增加了用户使用的复杂度。</li>
<li>在数据copy部分用户进程还是需要阻塞。</li>
</ol>
<h3 id="3）多路复用IO（IO-multiplexing）"><a href="#3）多路复用IO（IO-multiplexing）" class="headerlink" title="3）多路复用IO（IO multiplexing）"></a>3）多路复用IO（IO multiplexing）</h3><p>IO multiplexing，也称这种IO方式为<strong>事件驱动IO(event driven IO)</strong>。非阻塞IO（non-blocking IO）模式需要用户自己去轮询查看是否数据准备好，如果准备好则阻塞调用kernel进行copy。多路复用IO就是解决这种轮询问题，linux内部提供了select/poll/epoll来完成IO复用。</p>
<p>select/poll/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<div align="center"> <img src="../images/15263505327822.jpg" width="500"> </div>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select的调用过程如下所示：</p>
<div align="center"> <img src="../images/15263523909429.jpg" width="400"> </div>

<p>select负责管理多个FD文件描述符，kernel就会<strong>轮询</strong>检查所有select负责的fd，看是否有一个FD的数据已准备好。select会返回kernel数据准备就绪的FD， FD调用read操作让kernel完成数据的拷贝。 select解决了非阻塞状态下用户进程需要自己轮询的问题，同时可以用一个线程管理多个用户进程的读写操作。</p>
<p>select的缺点：</p>
<ul>
<li>单个进程能够监视的文件描述符的<strong>数量存在最大限制</strong>，<strong>通常是1024</strong>，当然可以更改数量。</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</li>
<li>内核/用户空间内存拷贝问题。每次调用select，<strong>都需要把fd集合从用户态拷贝到内核态</strong>，这个开销在fd(客户端套接字)很多时会很大。</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</strong>。然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的</strong>，但是同样有一个缺点：</p>
<ul>
<li>1）大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>2）poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<strong>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的copy只需一次。</p>
<p>基本原理：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，<strong>epoll使用“事件”的就绪通知方式</strong>，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似<strong>callback的回调机制来激活该fd</strong>，epoll_wait便可以收到通知。</p>
<p>epoll的优点：</p>
<ol>
<li><strong>没有最大并发连接的限制</strong>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li><strong>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</strong>。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li><strong>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递</strong>；即epoll使用mmap减少复制开销。</li>
</ol>
<h3 id="4）信号驱动式IO"><a href="#4）信号驱动式IO" class="headerlink" title="4）信号驱动式IO"></a>4）信号驱动式IO</h3><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它<strong>并不会block用户进程，而是立刻返回一个, 用户进程可以执行自己的程序不用轮询结果。kernel在IO就绪时会发送一个信号给用户进程告知IO准备好，可以执行后续操作</strong>。整体流程是：</p>
<ol>
<li>用户线程调用read, kernel执行IO准备阶段，这个过程不阻塞用户线程。</li>
<li>数据就绪后内核给用户线程发signal。 </li>
<li>当用户调用read, kernel执行数据拷贝操作，<strong>用户线程阻塞直到数据读取完成</strong>。kernel读取数据完成后，返回给用户数据。 </li>
</ol>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。这样避免了用户线程进行不断轮询的操作。</p>
<div align="center"> <img src="../images/15276920363669.jpg" width="500"> </div>


<h3 id="5）异步IO（Asynchronous-I-O）"><a href="#5）异步IO（Asynchronous-I-O）" class="headerlink" title="5）异步IO（Asynchronous I/O）"></a>5）异步IO（Asynchronous I/O）</h3><div align="center"> <img src="../images/15264350580615.jpg" width="500"> </div>

<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以<strong>不会对用户进程产生任何block</strong>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<strong>当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了</strong>。 </p>
<p>和同步方式不同，kernel的数据准备好以后不需要用户进程再次发送拷贝指令并阻塞等待kernel拷贝完成。</p>
<h2 id="Java-IO-分类"><a href="#Java-IO-分类" class="headerlink" title="Java IO 分类"></a>Java IO 分类</h2><ul>
<li><p><strong>Java BIO</strong>： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 </p>
</li>
<li><p><strong>Java NIO</strong> ： 同步非阻塞，服务器实现模式为一个请求一个线程，即当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。</p>
</li>
<li><p><strong>Java AIO(NIO.2)</strong> ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
</li>
</ul>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><strong>同步</strong>:指的是用户进程触发IO操作需要等待或者轮询的去查看IO操作执行完成才能执行其他操作.这种方式性能比较差，只有一些对数据安全性要求比较高的场景中才会使用．</li>
<li><strong>异步</strong>:异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）</li>
<li><strong>阻塞</strong>：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止</li>
<li><strong>非阻塞</strong>：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待</li>
</ul>
<h2 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h2><p>在JDK 1.4推出Java NIO之前，基于Java的所有Socket通信都采用了同步阻塞模式（BIO），<strong>这种一请求一应答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈</strong>。当并发访问量增大、响应时间延迟增大之后，采用Java BIO开发的服务端软件只有通过硬件的不断扩容来满足高并发和低时延，它极大地增加了企业的成本，并且随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战，只能通过采购性能更高的硬件服务器来解决问题，这会导致恶性循环,传统采用BIO的Java Web服务器如下所示（典型的如Tomcat的BIO模式）：</p>
<div align="center"> <img src="../images/15263490496683.jpg" width="600"> </div>


<p>采用该线程模型的服务器调度特点如下：</p>
<ol>
<li>服务端监听线程Acceptor负责客户端连接的接入，每当有新的客户端接入，就会创建一个新的I/O线程负责处理Socket</li>
<li>客户端请求消息的读取和应答的发送，都有I/O线程负责</li>
<li>除了I/O读写操作，默认情况下业务的逻辑处理，例如DB操作等，也都在I/O线程处理</li>
<li>I/O操作采用同步阻塞操作，读写没有完成，I/O线程会同步阻塞</li>
</ol>
<p>BIO线程模型主要存在如下三个问题：</p>
<ol>
<li><strong>性能问题</strong>：一连接一线程模型导致服务端的并发接入数和系统吞吐量受到极大限制</li>
<li><strong>可靠性问题</strong>：由于I/O操作采用同步阻塞模式，当网络拥塞或者通信对端处理缓慢会导致I/O线程被挂住，阻塞时间无法预测</li>
<li><strong>可维护性问题</strong>：I/O线程数无法有效控制、资源无法有效共享（多线程并发问题），系统可维护性差</li>
</ol>
<h2 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h2><ul>
<li>BIO方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器<strong>资源要求比较高</strong>，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 </li>
</ul>
<h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><ol>
<li>面向流与面向缓冲.</li>
</ol>
<p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。</p>
<ol start="2">
<li>阻塞与非阻塞IO</li>
</ol>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<ol start="3">
<li>选择器（Selectors）</li>
</ol>
<p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<h1 id="五、JVM"><a href="#五、JVM" class="headerlink" title="五、JVM"></a>五、JVM</h1><p>虚拟机面试一般包含以下几个知识点：</p>
<ul>
<li>JVM内存划分</li>
<li>JVM垃圾回收，垃圾回收可从几个点出发：<ul>
<li>什么对象需要回收</li>
<li>什么时候回收</li>
<li>怎么回收<ul>
<li>垃圾回收算法</li>
<li>垃圾收集器</li>
</ul>
</li>
</ul>
</li>
<li>如何使用工具观察和解决虚拟机问题</li>
<li>参数调优</li>
<li>类加载机制<ul>
<li>加载过程</li>
<li>双亲委派原理<ul>
<li>执行引擎</li>
</ul>
</li>
<li>动态委派和静态委派。这里涉及到java多态的概念。   </li>
</ul>
</li>
</ul>
<h2 id="介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明"><a href="#介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明" class="headerlink" title="介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明"></a>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</h2><ul>
<li><p><strong>程序计数器</strong>：看做当前线程所执行的<strong>字节码行号指示器</strong>。是线程<strong>私有</strong>的内存，且唯一一块不报OutOfMemoryError异常的内存区域。</p>
</li>
<li><p><strong>Java虚拟机栈</strong>：用于描述java方法的<strong>内存模型</strong>：每个方法被执行时都会同时创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的深度就报StackOverflowError, 如果虚拟机栈可以动态<strong>扩展</strong>，当拓展时无法申请到足够的内存会抛出OutOfMemoryError. 是线程<strong>私有</strong>的。</p>
</li>
<li><p><strong>本地方法栈</strong>：与虚拟机栈相似，不同的在于它是为虚拟机使用到<strong>Native</strong>方法服务的。会抛出StackOverflowError和OutOfMemoryError。是线程<strong>私有</strong>的。</p>
</li>
<li><p><strong>Java堆</strong>: 是所有线程共享的一块内存，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。如果堆上没有内存完成实例的分配就会报OutOfMemoryError.</p>
</li>
<li><p><strong>方法区（永久代）</strong>：用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。是共享内存。</p>
</li>
<li><p><strong>运行时常量池</strong>：用于存放编译器生成的各种字面量和符号引用，是方法区的一部分。无法申请内存时抛出OutOfMemoryError。</p>
</li>
<li><p><strong>直接内存</strong>：不是虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的区域，是计算机直接的内存空间。这部分也被频繁使用，如JAVA NIO的引入基于通道和缓存区的I/O使用native函数直接分配堆外内存。如果内存不足会报OutOfMemoryError。</p>
</li>
</ul>
<h2 id="GC的两种判定方法：引用计数与根搜索算法"><a href="#GC的两种判定方法：引用计数与根搜索算法" class="headerlink" title="GC的两种判定方法：引用计数与根搜索算法"></a>GC的两种判定方法：引用计数与根搜索算法</h2><ul>
<li><p><strong>引用计数</strong>： 给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1，当引用失效时，计数器值减1,。任何时候计数器都为0的对象就是不可能再被使用的。它很难解决对象之间相互<strong>循环引用</strong>问题。</p>
</li>
<li><p><strong>根搜索算法（GC Roots Traceing）:</strong> 通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。</p>
<p>GC Roots对象一般是：虚拟机栈中的引用对象，方法区中类静态属性引用的对象，方法区常量引用的对象等。</p>
</li>
</ul>
<h2 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。</p>
<ul>
<li><p><strong>强引用</strong>：程序代码中的普通引用。如Object obj = new Object(),只要强引用存在，垃圾回收器就不会回收。在不使用对象时应及时将引用设置为null，便于垃圾回收。</p>
</li>
<li><p><strong>软引用</strong>：描述一些有用但并非必须的对象。对于软引用关联的对象在系统将要<strong>发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第二次回收。<strong>SoftRefence</strong></p>
</li>
<li><p><strong>弱引用</strong>：描述非必须对象，比软引用弱一些。被弱引用关联的对象只能<strong>生存到下一次垃圾收集发生之前</strong>。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<strong>WeakRefence</strong></p>
</li>
<li><p><strong>虚引用</strong>：最弱的引用，不管是否有虚引用存在，完全不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的是希望能够在这个对象被垃圾回收器之前收到系统通知。<strong>PhantomReference</strong></p>
</li>
</ul>
<p>相关参考：<a href="https://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p>
<h2 id="对象创建方法，对象的内存分配，对象的访问定位。"><a href="#对象创建方法，对象的内存分配，对象的访问定位。" class="headerlink" title="对象创建方法，对象的内存分配，对象的访问定位。"></a>对象创建方法，对象的内存分配，对象的访问定位。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br></pre></td></tr></table></figure>

<p>obj 保存在java栈中的局部变量表里，作为一个引用数据出现。 New Object()会在java堆上分配一块存储Object类型实例的所有数值的结构化内存，根据类型以及虚拟机实现的对象内存布局不同。这块内存是不固定的。</p>
<p>对象访问方式有两种：<strong>句柄和直接指针</strong>。</p>
<ul>
<li><p><strong>句柄</strong>：在java堆中会划分出一块内存作为句柄池，reference中存储的对象是句柄地址。<strong>而句柄中包含对象实例数据和类型数据各自的具体地址信息</strong>。最大的好处是如果对象地址发生变化不需要改变reference的值，只需要改变句柄中实例数据指针。</p>
</li>
<li><p><strong>直接指针访问</strong>：reference直接存储对象的地址，最大的好处是<strong>速度更快</strong>。</p>
</li>
</ul>
<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><ul>
<li><p><strong>内存溢出</strong>：通俗理解就是<strong>内存不够</strong>，程序所需要的内存远远超出了你虚拟机分配的内存大小，就叫内存溢出</p>
</li>
<li><p><strong>内存泄露</strong>：内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在<strong>使用完毕后未释放</strong>，结果导致<strong>一直占据该内存单元</strong>。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏</p>
</li>
</ul>
<h2 id="内存溢出了怎么办"><a href="#内存溢出了怎么办" class="headerlink" title="内存溢出了怎么办"></a>内存溢出了怎么办</h2><p>通过内存映像工具如jhat、jconsole等对dump出来的堆转存储快照进行分析，重点是确认内存是出现内存泄露还是内存溢出。</p>
<p>如果是<strong>内存泄露</strong>进一步使用工具查看泄露的对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握泄露对象的信息，以及GC Roots引用链的信息，就可以比较准确定位泄露代码的位置。</p>
<p>如果不存在<strong>内存泄露</strong>，那就需要通过jinfo、Jconsole等工具分析java堆参数与机器物理内存对比是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态过长的情况，尝试减少程序的运行消耗。</p>
<h2 id="Java-中有内存泄露吗？"><a href="#Java-中有内存泄露吗？" class="headerlink" title="Java 中有内存泄露吗？"></a>Java 中有内存泄露吗？</h2><p>有，Java中，造成内存泄露的原因有很多种。典型的例子是<strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</p>
<p>检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。（采用什么工具？）</p>
<p><strong>如果一个外部类的实例对象的方法返回了一个内部类的实例对象</strong>，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p>
<p><a href="http://www.mamicode.com/info-detail-504269.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-504269.html</a></p>
<h2 id="什么时候会发生jvm堆（持久区）内存溢出"><a href="#什么时候会发生jvm堆（持久区）内存溢出" class="headerlink" title="什么时候会发生jvm堆（持久区）内存溢出"></a>什么时候会发生jvm堆（持久区）内存溢出</h2><p>简单的来说 java的堆内存分为两块:permantspace（持久代） 和 heap space。</p>
<p>持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。</p>
<p>而heapspace分为年轻代和年老代:</p>
<ul>
<li>年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。</li>
<li>在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象</li>
<li>年老代溢出原因有  循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存</li>
</ul>
<p><strong>持久代溢出原因动态加载了大量Java类而导致溢出，以及生产大量的常量</strong>。 </p>
<p><strong>永久代内存泄露</strong>: 以一个部署到应用程序服务器的Java web程序来说，当该应用程序被卸载的时候，你的EAR/WAR包中的所有类都将变得无用。只要应用程序服务器还活着，JVM将继续运行，但是一大堆的类定义将不再使用，理应将它们从永久代（PermGen）中移除。如果不移除的话，我们在永久代（PermGen）区域就会有内存泄漏。</p>
<h2 id="堆里面的分区：Eden，survivor-from-to，老年代，各自的特点。"><a href="#堆里面的分区：Eden，survivor-from-to，老年代，各自的特点。" class="headerlink" title="堆里面的分区：Eden，survivor from to，老年代，各自的特点。"></a>堆里面的分区：Eden，survivor from to，老年代，各自的特点。</h2><p>新生代：朝生夕死</p>
<p>老年代一般是放对象和长期存活对象。当一个对象分配的内存空间大于某个阈值时或则年龄增加到一定程度（默认15岁）就进入老年代。</p>
<h2 id="OOM你遇到过哪些情况"><a href="#OOM你遇到过哪些情况" class="headerlink" title="OOM你遇到过哪些情况"></a>OOM你遇到过哪些情况</h2><ul>
<li><p>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。 </p>
</li>
<li><p>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，<strong>一般出现于大量Class或者jsp页面</strong>，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。 </p>
</li>
<li><p>java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在<strong>死循环或者深度递归调用</strong>造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数<strong>-Xss</strong>来设置栈的大小。</p>
</li>
</ul>
<h2 id="GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h2><ul>
<li><p><strong>标记清理</strong>：首先标记所有需要回收的对象，在标记完成后<strong>统一回收掉</strong>所有被标记的对象，它的标记的对象。缺点是<strong>效率低</strong>，且存在<strong>内存碎片</strong>。主要用于老生代垃圾回收。</p>
</li>
<li><p><strong>标记整理</strong>：首先标记所有需要回收的对象，在标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。用于老年代。</p>
</li>
<li><p><strong>复制算法</strong>：将内存按容量划分为大小相等的一块，每次只用其中一块。当内存用完了，将还存活的对象复制到另一块内存，然后把已使用过的内存空间一次清理掉。实现简单，高效。一般用于新生代。一般是将内存分为一块较大的<strong>Eden空间</strong>和两块较小的<strong>Survivor</strong>空间。HotSpot虚拟机默认比例是<strong>8:1</strong>,。每次使用Eden和一块Survivor，当回收时将这两块内存中还存活的对象复制到Survivor然后清理掉刚才Eden和Survivor的空间。如果复制过程内存不够使用则向老年代分配担保。</p>
</li>
<li><p><strong>分代收集算法</strong>：根据对象的生存周期将内存划分为新生代和老年代，根据年代的特点采用最适当的收集算法。</p>
</li>
</ul>
<h2 id="GC收集器有哪些？CMS收集器与G1收集器的特点。"><a href="#GC收集器有哪些？CMS收集器与G1收集器的特点。" class="headerlink" title="GC收集器有哪些？CMS收集器与G1收集器的特点。"></a>GC收集器有哪些？CMS收集器与G1收集器的特点。</h2><ul>
<li><p><strong>Serial</strong>: 单线程收集器，只会使用一个CPU或一条收集器线程去完成，垃圾回收工作，更重要的是在进行垃圾回收时，必须暂停其他所有的工作线程。（Stop the world）。简单高效，用于新生代。</p>
</li>
<li><p><strong>ParNew</strong>: 是Serial收集器的<strong>多线程版本</strong>，垃圾回收时采用多线程方式进行回收。默认情况下使用的线程数是cpu数量。除了serial收集器，目前只有它能和CMS收集器配合工作。是server模式下首选的新生代收集器。</p>
</li>
<li><p><strong>Parallel Scavenge</strong>: 使用<strong>复制算法</strong>收集器，也是一个并行的多线程收集器。Parallel Scavenge收集器与其他收集器关注点不同，其它收集器主要关注缩短垃圾回收时用户线程的停顿时间。而它关心<strong>吞吐量</strong>，即<strong>运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)</strong>。停顿时间越短越适合需要与用户交互的程序，高吞吐量则可以最高效率的利用CPU时间。</p>
</li>
<li><p><strong>Serial Old</strong>: 老年代，单线程收集器，使用<strong>标记整理算法</strong>。主要有两个用途，一是和Parallel Scavenge 收集器配合使用，二是作为CMS的后备方案在并发收集器发生<strong>Concurrent Mode Failure</strong>时候使用。</p>
</li>
<li><p><strong>Parallel Old</strong>:并行的老年代版本收集器，使用标记整理算法。主要与Parallel Scavenge配合使用。</p>
</li>
<li><p><strong>CMS</strong>：是以获得<strong>最短回收停顿时间为</strong>目标的收集器，使用<strong>标记清除算法</strong>。整个过程包括4个：</p>
<ul>
<li><strong>初始标记</strong>: 标记Gc ROOTS能直接关联到的对象</li>
<li><strong>并发标记</strong>：进行Roots Traceing的过程</li>
<li><strong>重新标记</strong>：修正并发标记期间因用户继续工作导致标记产生变动</li>
<li><strong>并发清除</strong>：并发清除数据。<br>初始标记和重新标记需要stop the world. 并发标记和并发清除过程用户线程和收集器线程可以并行执行。</li>
</ul>
</li>
<li><p><strong>G1(Garbage First):</strong> 基于<strong>标记-整理算法</strong>的收集器,不会产生空间碎片.它可以精确控制停顿,能够让使用者明确指定一个长度为M毫秒的时间片段内,消耗集上的时间不超过N秒.是不牺牲吞吐量的前提下完成低停顿的.<strong>G1将整个java堆(新生和老生)划分为大小相同的区,并跟踪这些区上发生的变化.在后台维护一个优先列表,每次根据允许的收集时间优先回收垃圾最多的区域</strong>.</p>
</li>
</ul>
<p>现在公司中很多都采用了G1 垃圾回收期，建议大家多深入了解下G1，更多参考: <a href="./G1垃圾回收器.md">G1垃圾回收器</a></p>
<h2 id="Minor-GC与Full-GC分别在什么时候发生？"><a href="#Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="Minor GC与Full GC分别在什么时候发生？"></a>Minor GC与Full GC分别在什么时候发生？</h2><p>FullGC 一般是发生在老年代的GC，出现一个FullGC经常会伴随至少一次的Minor GC。速度比MinorGC慢10倍以上。</p>
<h3 id="FUll-GC"><a href="#FUll-GC" class="headerlink" title="FUll GC"></a>FUll GC</h3><p>FULL GC发生的情况:</p>
<ul>
<li><strong>1) 老年代空间不足</strong><br>老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space.</li>
</ul>
<p>措施:为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组</p>
<ul>
<li><p><strong>2) Permanet Generation(方法区或永久代)空间满</strong><br>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space </p>
<p>措施:为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
</li>
<li><p><strong>3) CMS GC时出现promotion failed和concurrent mode failure</strong><br>对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；</p>
<p>concurrent mode failure: CMS在执行垃圾回收时需要一部分的内存空间并且此刻用户程序也在运行需要预留一部分内存给用户程序，如果预留的内存无法满足程序需求就出现一次”Concurrent mod failure”,并触发一次Full GC。</p>
<p>应对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，</p>
</li>
<li><p><strong>4) 空间分配担保</strong><br>统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，Hotspot为了避免由于新生代对象晋升到老年代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断。如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发Full GC。如果小于并且不允许担保失败也会发生一次Full GC。</p>
</li>
</ul>
<h3 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h3><p>MinorGC 指发生在新生代的垃圾收集动作，非常频繁，回收速度也快。一般发生在新生代空间不足时,另外一个FullGC经常会伴随至少一次的Minor GC. 当虚拟检测晋升到到老年代的平均大小是否小于老年代剩余空间大小,如果小于并且允许担保失败,则执行Minor GC.</p>
<h2 id="几种常用的内存调试工具：jmap、jstack、jconsole。"><a href="#几种常用的内存调试工具：jmap、jstack、jconsole。" class="headerlink" title="几种常用的内存调试工具：jmap、jstack、jconsole。"></a>几种常用的内存调试工具：jmap、jstack、jconsole。</h2><p>(如何用工具分析jvm状态)</p>
<ul>
<li><strong>jps</strong>: 列出正在虚拟机运行的虚拟机进程，并显示虚拟机执行主类的名称，以及这些进程的本地虚拟机的唯一ID。</li>
<li><strong>jstat</strong> : 监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中<strong>类装载、垃圾收集、JIT编译、内存</strong>等数据。</li>
<li><strong>jinfo</strong>: 实时查看和调整虚拟机的各项参数。</li>
<li><strong>jmap</strong>: 生成<strong>堆转存储快照</strong>，查询fianlize执行队列、java堆和永生代详细信息，如空间使用率，当前用的是那种收集器。</li>
<li><strong>Jhat</strong>: 和jmap搭配使用，来分析jmap生成的堆转存储快照。内置一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以通过浏览器查看。</li>
<li><strong>jstack</strong>:用于生成当前时刻<strong>线程快照</strong>.线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合.生成线程快照的主要目的是为了定位线程长时间停顿的原因.如死锁、死循环、请求外部资源导致的长时间等待.</li>
<li><strong>JConsole</strong>: 可视化监视和管理工具,几乎包括以上工具的所有功能</li>
<li><strong>VisualVM</strong></li>
</ul>
<h2 id="GC-是什么？为什么要有-GC"><a href="#GC-是什么？为什么要有-GC" class="headerlink" title="GC 是什么？为什么要有 GC"></a>GC 是什么？为什么要有 GC</h2><p>GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显示的垃圾回收调用。</p>
<p>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。</p>
<h2 id="JVM-加载-class-文件的原理机制"><a href="#JVM-加载-class-文件的原理机制" class="headerlink" title="JVM 加载 class 文件的原理机制"></a>JVM 加载 class 文件的原理机制</h2><p>JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<p>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的 .class 文件中的数据读入到内存中，通常是创建一个字节数组读入 .class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后 JVM 对类进行初始化，包括：</p>
<ol>
<li>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；</li>
<li>如果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ol>
<p>类的加载是由类加载器完成的，类加载器包括：<strong>启动类加载器（BootStrap）、扩展加载器（Extension）、应用程序加载器（Application）和用户自定义类加载器（java.lang.ClassLoader的子类）</strong>。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：</p>
<ul>
<li><strong>Bootstrap</strong>：启动类加载器，一般用本地代码实现，负责加载JVM基础核心类库。加载存放在<java_home>/lib目录中的类库（如rt.jar）；</java_home></li>
<li><strong>Extension ClassLoader</strong>：扩展加载器， 负责加载<java_home>/lib/ext目录中的<br>，或被java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；</java_home></li>
<li><strong>Application ClassLoader</strong>：应用程序加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
<p>缺点: </p>
<ul>
<li>双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码时，双亲委派模型无法满足要求。 因为Bootstrap加载器无法找到永不代码类。</li>
</ul>
<p>为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文件类加载器(Thread Context ClassLoader)</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。<strong>Java中所有涉及SPI的加载动作基本上都采用这种方式</strong>，例如JNDI,JDBC,JCE,JAXB和JBI等。 Dubbo的SPI也是采用这种机制实现。</p>
<h2 id="类加载的五个过程：加载、验证、准备、解析、初始化。"><a href="#类加载的五个过程：加载、验证、准备、解析、初始化。" class="headerlink" title="类加载的五个过程：加载、验证、准备、解析、初始化。"></a>类加载的五个过程：加载、验证、准备、解析、初始化。</h2><ul>
<li><p><strong>加载</strong>: 根据全限定名来获取定义类的二进制字节流,然后将该字节流所代表的静态结构转化为方法区的运行时数据结构,最后在生成一个代表该类的Class对象,作为方法区这些数据的访问入口.</p>
</li>
<li><p><strong>验证</strong>:主要时为了确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.包含四个阶段的验证过程:</p>
<ul>
<li><strong>文件格式验证</strong>:保证输入的字节流能够正确地解析并存储在方法区之内,格式上符合描述一个java类型信息的要求</li>
<li><strong>元数据验证</strong>:字节码语义信息的验证,以保证描述的信息符合java语言规范.验证点有:这个类是否有父类等.</li>
<li><strong>字节码验证</strong>:主要是进行数据流和控制流分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为.</li>
<li><strong>符号引用验证</strong>:对符号引用转化为直接引用过程的验证.</li>
</ul>
</li>
<li><p><strong>准备</strong>:为类变量分配内存并设置变量的初始值,这些内存在方法区进行分配.</p>
</li>
<li><p><strong>解析</strong>:将虚拟机常量池中的符号引用转化为直接引用的过程.解析主要是针对类或接口、字段、类方法、类接口方法四类.</p>
</li>
<li><p><strong>初始化</strong>:执行静态变量的赋值操作以及静态代码块,完成初识化.初始化过程保证了父类中定义的初始化优先于子类的初始化.但接口不需要执行父类的初始化.</p>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器.顺序依次是:</p>
<ul>
<li>Bootstrap ClassLoader: 启动类加载器,加载java_home/lib中的类</li>
<li>Extension ClassLoader: 扩展类加载器,加载java_home/lib/ext目录下的类库</li>
<li>Application ClassLoader: 应用程序类加载器,加载用户类路径上指定类库.</li>
</ul>
<p>双亲委派模型的工作原理是:如果一个类加载器受到了类加载请求,它首先不会自己去尝试加载这个类,而把这个请求委派给父类加载器去完成,每一层次的类加载器都是如此,因此所有的加载请求最终都应该传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成加载请求时,加载器才尝试自己加载.这种方式保证了Oject类(JDK 核心类)在各个加载器加载环境中都是同一个类.</p>
<h2 id="分派：静态分派与动态分派。"><a href="#分派：静态分派与动态分派。" class="headerlink" title="分派：静态分派与动态分派。"></a>分派：静态分派与动态分派。</h2><p>多态性特征的一些最基本的体现. <strong>静态类型是编译期可知的,动态类型是在运行时可知</strong>.Human h =new Man(); Human是静态类型,Man时动态类型.</p>
<p>所有依赖于静态类型定位方法执行版本的分派动作称作<strong>静态分派</strong>,最典型的应用是方法重载.静态分派发生在编译阶段。</p>
<p><strong>动态分派</strong>是根据动态类型来确定执行的版本,所以只有到运行时才能确定具体的执行方法版本.典型的代表时重写.其过程如下:</p>
<ul>
<li>1) 首先找到操作数栈栈顶的第一个元素所执向对象的实际类型,记做C.</li>
<li>2) 如果在类型C中找到和常量中的描述符和简单名称都相符的方法,则进行范围权限校验.如果通过则返回该方法的直接引用,否则抛出IllegalAccessError异常.</li>
<li>3) 否则按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程.</li>
<li>4) 如果始终没有找到就抛出AbstractMethodError异常.<br>方法的接受者和方法的参数统称方法宗量,根据分配基于多少中宗量可以分为单分派和多分派.java是静态多分派,动态分派属于单分派.</li>
</ul>
<p><strong>动态分派的实现:</strong><br>动态分派时非常频繁的动作,而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法,因此出于性能的考虑,在方法区中建立一个<strong>虚方法表</strong>,用来保存各个方法的实际入口地址.如果某个方法的子类中没有被重写,那么子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的.都是指向父类的实现入口,如果子类中重写了这个方法,子类方法表中的地址将会被替换为指向子类实现版本的入口地址.虚方法表在类加载的连接阶段进行初始化.</p>
<h2 id="Jvm-自动内存管理（什么时候触发-gc-）"><a href="#Jvm-自动内存管理（什么时候触发-gc-）" class="headerlink" title="Jvm 自动内存管理（什么时候触发 gc ）"></a>Jvm 自动内存管理（什么时候触发 gc ）</h2><p><a href="http://jeromecen1021.blog.163.com/blog/static/18851527120117274624888/" target="_blank" rel="noopener">http://jeromecen1021.blog.163.com/blog/static/18851527120117274624888/</a><br>FULL GC 和 Minor GC 的触发时间<br>程序员不能具体控制时间，系统在不可预测的时间调用System.gc()函数的时候；当然可以通过调优，用NewRatio控制newObject和oldObject的比例，用MaxTenuringThreshold 控制进入oldObject的次数，使得oldObject 存储空间延迟达到full gc,从而使得计时器引发gc时间延迟OOM的时间延迟，以延长对象生存期。</p>
<h2 id="GC停顿原因，如何降低停顿"><a href="#GC停顿原因，如何降低停顿" class="headerlink" title="GC停顿原因，如何降低停顿"></a>GC停顿原因，如何降低停顿</h2><h2 id="JVM如何调优、参数怎么调"><a href="#JVM如何调优、参数怎么调" class="headerlink" title="JVM如何调优、参数怎么调"></a>JVM如何调优、参数怎么调</h2><h2 id="jvm的体系结构及各个部分的职责"><a href="#jvm的体系结构及各个部分的职责" class="headerlink" title="jvm的体系结构及各个部分的职责"></a>jvm的体系结构及各个部分的职责</h2><p>JVM都有两种机制，一个是装载具有合适名称的类(类或是接口)，包含类的装载 连接 初始化的过程叫做<strong>类装载子系统</strong>；另外的一个负责执行包含在已装载的类或接口中的指令，叫做<strong>运行引擎</strong>。每个JVM又包括方法区、堆、Java栈、程序计数器和本地方法栈这五个部分，这几个部分和类装载机制与运行引擎机制一起组成的体系结构图为:</p>
<img src="../images/15268031792473.jpg" width="340px">

<ul>
<li>JVM的每个实例都有一个它自己的方法域和一个堆，运行于JVM内的所有的线程都共享这些区域；</li>
<li>当虚拟机装载类文件的时候，它解析其中的二进制数据所包含的类信息，并把它们放到方法域中；</li>
<li>当程序运行的时候，JVM把程序初始化的所有对象置于堆上；</li>
<li>而每个线程创建的时候，都会拥有自己的程序计数器和Java栈，其中程序计数器中的值指向下一条即将被执行的指令，线程的Java栈则存储为该线程调用Java方法的状态；</li>
<li>本地方法调用的状态被存储在本地方法栈，该方法栈依赖于具体的实现。</li>
</ul>
<p><a href="http://blog.csdn.net/dongdong_java/article/details/24797307" target="_blank" rel="noopener">http://blog.csdn.net/dongdong_java/article/details/24797307</a><br><a href="http://blog.csdn.net/longyulu/article/details/8350622" target="_blank" rel="noopener">http://blog.csdn.net/longyulu/article/details/8350622</a></p>
<h2 id="如果想不被-GC-怎么办"><a href="#如果想不被-GC-怎么办" class="headerlink" title="如果想不被 GC 怎么办"></a>如果想不被 GC 怎么办</h2><p>可以先说那些对象可以被GC,然后说java对象会不会回收，决定于是否还被引用，不被引用了就有可能被GC回收，一直被引用着就不会被回收. </p>
<ol start="2">
<li>jvm性能调优都做了什么</li>
<li>介绍GC 和GC Root不正常引用。</li>
<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>
<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>
<li>老年代中数组的访问方式</li>
<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>
<li>jvm 如何分配直接内存??</li>
<li>new 对象如何不分配在堆而是栈上?</li>
<li>常量池解析</li>
</ol>
<h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="Student-s-new-Student-在内存中做了那些事情"><a href="#Student-s-new-Student-在内存中做了那些事情" class="headerlink" title="Student s= new Student(),在内存中做了那些事情"></a>Student s= new Student(),在内存中做了那些事情</h2><ol>
<li>加载Student.class 文件进内存</li>
<li>在栈内存为s开辟空间</li>
<li>在堆内存为Student对象开辟空间</li>
<li>学生对象的成员变量进行显示初始化</li>
<li>通过构造方法对学生对象变量赋值</li>
<li>学生对象初始完毕，把对象地址赋值给s变量</li>
</ol>
<h2 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h2><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>表示初始堆大小</td>
<td>默认为物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小(1.4or lator)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1/64</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4</td>
<td></td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话-Xss is translated in a VM flag named ThreadStackSize一般设置这个值就可以了。</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>=4表示年轻代与年老代所占比值为1:4, 年轻代占整个堆栈的1/5 Xms = Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄</td>
<td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效.</td>
<td></td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0    单位字节</td>
<td>新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
</tbody></table>
<h1 id="六、thread"><a href="#六、thread" class="headerlink" title="六、thread"></a>六、thread</h1><h2 id="什么叫线程安全？举例说明"><a href="#什么叫线程安全？举例说明" class="headerlink" title="什么叫线程安全？举例说明"></a>什么叫线程安全？举例说明</h2><p>多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。<br>比如无状态对象一定是线程安全的。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>调度: 线程是调度的基本单位，进程是拥有资源的基本单位。同一进程的中线程的切换不会引起进程的切换，不同进程中进行线程切换会引起进程的切换。</p>
<p>拥有资源：进程是拥有资源的基本单位，线程除了自身的栈外一般不拥有资源。而是和其他线程共享同一进程中的资源。</p>
<p>系统开销：由于创建进程或者撤销进程时，系统都要分配和回收资源，如内存空间，I/O设备等，操作系统所付出的开销远大于创建或撤销进程时的开销。</p>
<h2 id="volatile的理解"><a href="#volatile的理解" class="headerlink" title="volatile的理解"></a>volatile的理解</h2><p><strong>Volatile自身特性</strong>：</p>
<ol>
<li>Volatile 是轻量级的synchronized，它在多处理器开发过程中保证了共享变量的“<strong>可见性</strong>”，可见性是指当一个线程的某个共享变量发生改变时，另一个线程能够读取到这个修改的值。Voaltile变量修饰的变量在进行写操作时在多核处理器下首先将当前处理器缓存行的数据写回到系统内存中。为了保证一致性，其他处理器嗅探到总线上传播的数据，发现数据被修改了使自己缓存地址的数据无效。</li>
<li>Volatile 可以<strong>禁止重排序</strong>，</li>
<li>Volatile 能保持单个简单volatile变量的读/写操作的具有原子性。但不能保证自增自减的<strong>原子性</strong>。</li>
</ol>
<p>从<strong>内存语义</strong>来讲:</p>
<ul>
<li>volatile变量的写-读与锁的释放-获取具有相同语义，volatile的写与锁的释放有相同的内存语义，volatile读与锁的获取具有相同语义。</li>
<li>线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出消息</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的消息。</li>
<li>线程A写volatile变量，随后线程B读这个变量，这个过程实质上线程A通过内存向B发送消息。</li>
</ul>
<p>内存语义的实现，也是禁止重排序特性：<br>为了实现volatile内存语义，JMM限制了对volatile重排序做了限制：</p>
<ol>
<li>当第二个操作是volatile写时，不管第一个操作时什么，都不能重排序。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不重排序。</li>
</ol>
<p>为了实现volatile的内存语义，编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。JMM采取保守策略:</p>
<ol>
<li>在每个volatile写操作前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作后面插入一个LoadStore屏障</li>
</ol>
<p>具体参考《java并发编程的艺术》</p>
<h2 id="原子性实现机制"><a href="#原子性实现机制" class="headerlink" title="原子性实现机制"></a>原子性实现机制</h2><p>处理器提供总线锁定和缓存锁定两种方式来保证复杂内存操作的原子性。</p>
<ul>
<li><p>总线型：就是使用处理器提供一个LOCK信号，当一个处理器在总线传输信号时，其他处理器的请求将被阻塞住，那么该处理独占内存。所以总线锁定开销大。</p>
</li>
<li><p>缓存锁定：内存区域如果被缓存在缓存行中，且在在lock期间被锁定，当它执行锁操作写回内存时，处理器总线不在锁定而是通过修改内部的内存地址并使用缓存一致性制阻止同时修改保证操作的原子性。缓存一致性进制两个以上的处理器同时修改内存区域数据，其他处理器回写被锁定并且使其缓存行无效。</p>
</li>
</ul>
<h2 id="Java原子性操作实现原理"><a href="#Java原子性操作实现原理" class="headerlink" title="Java原子性操作实现原理"></a>Java原子性操作实现原理</h2><p>使用循环CAS实现原子性操作，CAS是在操作期间先比较旧值，如果旧值没有发生改变，才交换成新值，发生了变化则不交换。这种方式会产生以下几种问题：</p>
<ol>
<li>ABA问题，通过加版本号解决；</li>
<li>循环时间过长开销大，一般采用自旋方式实现；</li>
<li>只能保证一个共享变量的原子操作。 </li>
</ol>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型控制线程之间的通信，决定了一个线程对共享变量的写入何时对另一个线程可见。它属于语言级的内存模型，它确保在不同编译器和不同的处理平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。JMM的核心目标是找到一个好的平衡点，一方面是为程序员提供足够强的内存可见性保证（提供happens-before规则），另一方面对编译器和处理器的限制尽可能地放松（只要不改变程序结果，怎么优化都可以）</p>
<p>1) <strong>可见性保证</strong></p>
<p>为了提供内存可见性保证，JMM向程序员保证了以下hapens-before规则:</p>
<ol>
<li><strong>程序顺序规则</strong>：一个线程的每个操作happen-before与该线程的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：一个锁的解锁，happens-before于随后这个锁的加锁。</li>
<li><strong>Volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续这个域的读。</li>
<li><strong>传递性</strong>, 如果A happens-before B, 且B happens-before C 那么A happens-before C</li>
<li><strong>线程启动规则</strong>：如果线程A执行操作ThreadB.start().那么线程A中的任意操作happens-before与线程B中的任意操作。</li>
<li><strong>线程结束规则</strong>: 线程中的任何操作都必须在其线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者在调用Thread.isAlive时返回false.</li>
<li><strong>中断规则</strong>:当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行(通过抛出InterruptedException,或者调用isInterrupted和interrupted)</li>
<li><strong>终结器规则</strong>: 对象的构造函数必须在启动该对象的终结器之前执行完成。</li>
</ol>
<p><strong>2) 禁止重排序</strong></p>
<p>为了保证内存可见性，java编辑器在生成指令序列的适当位置插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<p>重排序：编译器和处理器为了优化程序性能对指令进行重新排序的一种手段。</p>
<ul>
<li>1) 编译器优化的重排序: 编译器在不改变单线程程序语义的前提下可以重新安排语句顺序。</li>
<li>2) 指令级并行的重排序.现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变对应指令的执行顺序。</li>
<li>3) 内存系统重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能在乱序执行。</li>
</ul>
<h2 id="Final域的内存语义"><a href="#Final域的内存语义" class="headerlink" title="Final域的内存语义"></a>Final域的内存语义</h2><p>对于final域编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造器函数内对final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（保证了对象引用为任何线程可见之前，对象的final域已经被正确初始化过）</li>
<li>初次读一个包含final域的对象引用，与随后初次读这个final域这两个操作不能重排序。</li>
</ol>
<p>为何保证其内存语义：可以为java程序员提供安全保证，只要对象是正确构造的，那么不需要使用同步就可以保证线程都能看到这个fianal域在构造函数中被初始化之后的值。</p>
<h2 id="避免死锁的常见方法："><a href="#避免死锁的常见方法：" class="headerlink" title="避免死锁的常见方法："></a>避免死锁的常见方法：</h2><ul>
<li>1)避免一个线程同时获取多个锁</li>
<li>2)避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>3)尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。</li>
<li>4)对数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h2 id="死锁的必要条件？怎么克服？"><a href="#死锁的必要条件？怎么克服？" class="headerlink" title="死锁的必要条件？怎么克服？"></a>死锁的必要条件？怎么克服？</h2><p>答：产生死锁的四个必要条件：</p>
<ul>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li>
<li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>死锁的解决方法:</p>
<ul>
<li>撤消陷于死锁的全部进程；</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在；</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态</li>
</ul>
<h2 id="CountDownLatch-闭锁-与CyclicBarrier-栅栏-的区别"><a href="#CountDownLatch-闭锁-与CyclicBarrier-栅栏-的区别" class="headerlink" title="CountDownLatch(闭锁) 与CyclicBarrier(栅栏)的区别"></a>CountDownLatch(闭锁) 与CyclicBarrier(栅栏)的区别</h2><p>CountDownLatch: <strong>允许一个或多个线程等待其他线程完成操作</strong>. </p>
<p>CyclicBarrier：<strong>让一组线程到达一个屏障(同步点)被阻塞，直到最后一个线程到达屏障时，所有被屏障拦截的线程才会往下执行</strong>。 </p>
<ol>
<li>闭锁用于等待事件、栅栏是等待线程.</li>
<li>闭锁CountDownLatch做减计数，而栅栏CyclicBarrier则是加计数。</li>
<li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li>
<li>CountDownLatch一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行。CyclicBarrier是N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 </li>
</ol>
<p>CountDownLatch 是<strong>计数器</strong>, 线程完成一个就记一个,就像报数一样, 只不过是递减的.</p>
<p>而CyclicBarrier更像一个<strong>水闸</strong>, 线程执行就像水流, 在水闸处都会堵住, 等到水满(线程到齐)了, 才开始泄流.</p>
<h2 id="execute-和submit的区别"><a href="#execute-和submit的区别" class="headerlink" title="execute 和submit的区别"></a>execute 和submit的区别</h2><p>Execute()用于提交不需要返回值得任务，submit()用于提交需要返回值的任务，发挥Future类型的对象。</p>
<h2 id="Shutdown和shutdownNow的区别"><a href="#Shutdown和shutdownNow的区别" class="headerlink" title="Shutdown和shutdownNow的区别"></a>Shutdown和shutdownNow的区别</h2><p>它们的原理都是遍历线程池中的工作线程，然后逐个调用线程的Internet方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<p>ShutdownNow首先将线程池的状态设置成STOP, 然后尝试停止所有正在执行或暂停的任务，并返回等待执行任务的列表。而shutdown只是将线程池设置成SHUTDOWN状态，然后中断没有正在执行任务的线程。</p>
<h2 id="ThreadLocal的设计理念与作用。"><a href="#ThreadLocal的设计理念与作用。" class="headerlink" title="ThreadLocal的设计理念与作用。"></a>ThreadLocal的设计理念与作用。</h2><p>ThreadLocal并不是一个Thread，而是Thread的局部变量, 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</p>
<p><a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">http://blog.csdn.net/lufeng20/article/details/24314381</a></p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步就是协同步调，按预定的先后次序进行运行。</p>
<h2 id="sleep-和-wait-区别"><a href="#sleep-和-wait-区别" class="headerlink" title="sleep() 和 wait() 区别"></a>sleep() 和 wait() 区别</h2><p>答：sleep()方法是<strong>线程类（Thread）的静态方法</strong>，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用 sleep <strong>不会释放对象锁</strong>。</p>
<p>wait() 是 <strong>Object 类的方法</strong>，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)，<strong>释放资源并</strong>进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</p>
<h2 id="sleep-和-yield-区别"><a href="#sleep-和-yield-区别" class="headerlink" title="sleep() 和 yield() 区别"></a>sleep() 和 yield() 区别</h2><ul>
<li>① sleep() 方法给其他线程运行机会时<strong>不考虑线程的优先级</strong>，因此会给低优先级的线程以运行的机会；yield() 方法<strong>只会给相同优先级或更高优先级</strong>的线程以运行的机会；</li>
<li>② 线程执行 sleep() 方法后转入<strong>阻塞</strong>（blocked）状态，而执行 yield() 方法后转入<strong>就绪（ready）</strong>状态；</li>
<li>③ sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常；</li>
<li>④ sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。</li>
</ul>
<h2 id="线程同步相关的方法。"><a href="#线程同步相关的方法。" class="headerlink" title="线程同步相关的方法。"></a>线程同步相关的方法。</h2><ul>
<li><strong>wait()</strong>:使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li><strong>sleep()</strong>:使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；</li>
<li><strong>notify()</strong>:唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li>
<li><strong>notityAll()</strong>:唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争；</li>
</ul>
<h2 id="什么是线程池（thread-pool）"><a href="#什么是线程池（thread-pool）" class="headerlink" title="什么是线程池（thread pool）"></a>什么是线程池（thread pool）</h2><p>在面向对象编程中，<strong>创建和销毁对象是很费时间的</strong>，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是<strong>尽可能减少创建和销毁对象的次数</strong>，特别是一些很耗资源的对象创建和销毁，这就是”<strong>池化资源</strong>“技术产生的原因。</p>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>
<h2 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h2><p>ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度以及如何锁。<br>Hashtabl在竞争激烈的环境下表现效率低下的原因是一把锁锁住整张表，导致所有线程同时竞争一个锁。ConcurrentHashMap采用<strong>分段锁</strong>，每把锁锁住容器中的一个Segment。那么多线程访问容器里不同的Segment的数据时线程就不会存在竞争，从而有效提高并发访问效率。首先是将数据分层多个Segment存储，并为每个Segment分配一把锁，当一个线程范围其中一段数据时，其他线程可以访问其他段的数据。</p>
<p>数据结构：</p>
<p>ConcurrentHashMap内部是有<strong>Segment</strong>数组和<strong>HashEntry</strong>数组组成。一个ConcurrentHashMap里包含一个Segment数组，而Segment的结构和HashMap一样，里面是由一个数组和链表结构组成，所以一个Segment内部包含一个HashEntry数组。每个HashEntry是一个链表结构，对于HashEntry数组进行修改时首先需要获取与它对应的Segment锁。默认情况下有16个Segment</p>
<p>Segment的定位:</p>
<p>使用Wang/Jenkins hash变种算法对元素的hashCode进行一次再散列，目的是为了减少散列冲突。</p>
<p>ConcurrentHashMap的操作:</p>
<ul>
<li>get</li>
</ul>
<p>get操作实现非常简单高效。先经过一次<strong>再散列</strong>，然后用这个散列值通过散列运算定位到Segment，<strong>再通过散列算法定位到元素</strong>。get之所以高效是因为整个get过程不需要加锁，除非读到空值才会加锁重读。实现该技术的技术保证是保证<strong>HashEntry是不可变的</strong>。</p>
<p>第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count 变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。接下来就是根据hash和key对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。</p>
<p>对hash链进行遍历<strong>不需要加锁的原因在于链指针next是final的、entry是不可变类</strong>。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在 table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。</p>
<ul>
<li>put</li>
</ul>
<p>该方法也是在持有段锁(锁定当前segment)的情况下执行的，这当然是为了并发的安全，修改数据是不能并发进行的，必须得有个判断是否超限的语句以确保容量不足时能够rehash。首先根据计算得到的散列值定位到segment及该segment中的散列桶中。接着判断是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。</p>
<ul>
<li>remove<br>HashEntry中除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next 引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。</li>
</ul>
<p>首先定位到要删除的节点e。如果不存在这个节点就直接返回null，否则就要将e前面的结点复制一遍，尾结点指向e的下一个结点。e后面的结点不需要复制，它们可以重用。</p>
<ul>
<li>size()<br>每个Segment都有一个count变量，是一个volatile变量。当调用size方法时，首先先尝试2次通过不锁住segment的方式统计各个Segment的count值得总和，如果两次值不同则将锁住整个ConcurrentHashMap然后进行计算。</li>
</ul>
<p>参见《java并发编程的艺术》P156<br><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3948786.html</a></p>
<h2 id="线程的几种可用状态"><a href="#线程的几种可用状态" class="headerlink" title="线程的几种可用状态"></a>线程的几种可用状态</h2><p>线程在运行周期里有6中不同的状态：</p>
<ol>
<li>New 新建</li>
<li>RUNNABLE 运行状态,操作系统中运行与就绪两种状态统称运行中</li>
<li>BLOCKED 阻塞状态</li>
<li>WAITING    等待状态</li>
<li>TIME_WAITING 超时等待</li>
<li>TERMINATED    终止状态</li>
</ol>
<h2 id="同步方法和同步代码块的区别是什么"><a href="#同步方法和同步代码块的区别是什么" class="headerlink" title="同步方法和同步代码块的区别是什么"></a>同步方法和同步代码块的区别是什么</h2><ol>
<li><p>同步方法只能锁定当前对象或class对象， 而同步方法块可以使用其他对象、当前对象及当前对象的class作为锁。</p>
</li>
<li><p>从反编译后的结果看，对于同步块使用了<strong>monitorenter</strong>和<strong>monitorexit</strong>指令，而同步方法则是依靠方法上的修饰符<strong>ACC_SYNCHRONIZED</strong>来完成，但它们的本质都是对一个对象监视器进行获取，而这个获取过程是排他的。</p>
</li>
</ol>
<h3 id="显示锁ReentrantLock与内置锁synchronized的相同与区别"><a href="#显示锁ReentrantLock与内置锁synchronized的相同与区别" class="headerlink" title="显示锁ReentrantLock与内置锁synchronized的相同与区别"></a>显示锁ReentrantLock与内置锁synchronized的相同与区别</h3><p>相同：显示锁与内置锁在加锁和内存上提供的语义相同(互斥访问临界区)</p>
<p>不同：</p>
<ol>
<li><strong>使用方式</strong>：内置无需指定释放锁，简化锁操作。显示锁拥有锁获取和释放的可操作性。</li>
<li><strong>功能上</strong>：显示锁提供了其他很多功能如定时锁等待、可中断锁等待、公平性、尝试非阻塞获取锁、以及实现非结构化的加锁。（一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断表示为会被修改，但线程依旧会被阻塞在synchronized上，等待获取锁。）</li>
<li><strong>对死锁的处理</strong>：内置只能重启，显示可以通过设置超时获取锁来避免</li>
<li><strong>性能上</strong>：java1.5 显示远超内置，java1.6 显示锁稍微比内置好</li>
<li>atomicinteger和Volatile等线程安全操作的关键字的理解和使用</li>
</ol>
<p>SOF你遇到过哪些情况。</p>
<h3 id="实现多线程的3种方法：Thread与Runable。"><a href="#实现多线程的3种方法：Thread与Runable。" class="headerlink" title="实现多线程的3种方法：Thread与Runable。"></a>实现多线程的3种方法：Thread与Runable。</h3><ul>
<li><strong>1)继承Tread类，重写run函数</strong></li>
<li><strong>2)实现Runnable接口</strong></li>
<li><strong>3)实现Callable接口</strong></li>
</ul>
<h3 id="如何选择多线程池"><a href="#如何选择多线程池" class="headerlink" title="如何选择多线程池"></a>如何选择多线程池</h3><ol start="22">
<li>线程同步的方法：sychronized、lock、reentrantLock等。</li>
<li>锁的等级：方法锁、对象锁、类锁。</li>
<li>ThreadPool用法与优势。</li>
<li>Callable和Runnable的区别</li>
<li>Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</li>
<li>foreach与正常for循环效率对比。</li>
<li>反射的作用于原理。</li>
<li>泛型常用特点，List<string>能否转为List<object>。</object></string></li>
<li>设计模式：单例、工厂、适配器、责任链、观察者等等。</li>
<li>JNI的使用。</li>
<li>java的代理是怎么实现的  </li>
<li>Java1.7与1.8新特性。</li>
<li>lmbda表达式</li>
<li>Java8新特性</li>
<li>连接池使用使用什么数据结构实现</li>
<li>实现连接池</li>
<li>结束一条 Thread 有什么方法？ interrupt 底层实现有看过吗？线程的状态是怎么样的？如果给你实现会怎么样做？</li>
<li>Java 中有内存泄露吗？是怎么样的情景？为什么不用循环计数？</li>
<li>java都有哪些加锁方式</li>
<li>AIO与BIO的区别</li>
<li>生产者与消费者，手写代码</li>
<li>Java创建线程之后，直接调用start()方法和run()的区别</li>
<li>常用的线程池模式以及不同线程池的使用场景</li>
<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>
<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>
<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>
<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>
<li>线程间通信，wait和notify</li>
<li>定时线程的使用</li>
<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>
<li>并发、同步的接口或方法</li>
<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>
<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>
<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法</li>
</ol>
<h2 id="写出生产者消费者模式。"><a href="#写出生产者消费者模式。" class="headerlink" title="写出生产者消费者模式。"></a>写出生产者消费者模式。</h2><pre><code>public class ProducerConsumerPattern {
    public static void main(String args[]){
     BlockingQueue sharedQueue = new LinkedBlockingQueue();
     Thread prodThread = new Thread(new Producer(sharedQueue));
     Thread consThread = new Thread(new Consumer(sharedQueue));
     prodThread.start();
     consThread.start();
    }
}

//Producer Class in java
class Producer implements Runnable {
    private final BlockingQueue sharedQueue;
    public Producer(BlockingQueue sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
    @Override
    public void run() {
        for(int i=0; i&lt;10; i++){
            try {
                System.out.println(&quot;Produced: &quot; + i);
                sharedQueue.put(i);
            } catch (InterruptedException ex) {
                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

//Consumer Class in Java
class Consumer implements Runnable{
    private final BlockingQueue sharedQueue;
    public Consumer (BlockingQueue sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
    @Override
    public void run() {
        while(true){
            try {
                System.out.println(&quot;Consumed: &quot;+ sharedQueue.take());
            } catch (InterruptedException ex) {
                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://bbym010.iteye.com/blog/2100868" target="_blank" rel="noopener">http://bbym010.iteye.com/blog/2100868</a></li>
<li><a href="http://developer.51cto.com/art/201112/307463.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201112/307463.htm</a></li>
<li><a href="http://ifeve.com/java-nio-vs-io/" target="_blank" rel="noopener">http://ifeve.com/java-nio-vs-io/</a></li>
<li><a href="https://www.cnblogs.com/findumars/p/6361627.html" target="_blank" rel="noopener">5种网络IO模型（有图，很清楚）</a></li>
<li><a href="http://www.uml.org.cn/zjjs/201711241.asp" target="_blank" rel="noopener">gRPC线程模型分析</a> | InfoQ</li>
<li><a href="https://blog.csdn.net/qq546770908/article/details/53082870" target="_blank" rel="noopener"></a></li>
<li><a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">IO多路复用之select总结</a></li>
<li><a href="https://www.cnblogs.com/jeakeven/p/5435916.html" target="_blank" rel="noopener">IO多路复用之select、poll、epoll详解</a></li>
<li><a href="https://blog.csdn.net/a627088424/article/details/54582360" target="_blank" rel="noopener">透彻 Linux (Unix) 五种 IO 模型</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32400397" target="_blank" rel="noopener">设备管理 | I/O软件</a></li>
<li><a href="https://tech.meituan.com/about-desk-io.html" target="_blank" rel="noopener">磁盘I/O那些事</a> | 美团</li>
<li><a href="https://www.kancloud.cn/kancloud/ldd3/61083" target="_blank" rel="noopener">《Linux 设备驱动 Edition 3》</a></li>
<li><a href="https://segmentfault.com/a/1190000007692223" target="_blank" rel="noopener">磁盘及网络IO工作方式解析</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Socket.md" target="_blank" rel="noopener">Socket</a></li>
<li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener">面向对象设计的 SOLID 原则</a></li>
<li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener">看懂 UML 类图和时序图</a></li>
<li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener">UML 系列——时序图（顺序图）sequence diagram</a></li>
<li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener">面向对象编程三大特性 —— 封装、继承、多态</a></li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/code-软件基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/01/09/code-软件基础/" class="post-title-link" itemprop="url">code -- 软件基础</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-01-09 09:05:39" itemprop="dateCreated datePublished" datetime="2019-01-09T09:05:39+08:00">2019-01-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-09 09:55:34" itemprop="dateModified" datetime="2019-10-09T09:55:34+08:00">2019-10-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pencil2-算法"><a href="#pencil2-算法" class="headerlink" title=":pencil2: 算法"></a>:pencil2: 算法</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/剑指%20Offer%20题解%20-%20目录.md" target="_blank" rel="noopener">剑指 Offer 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20题解%20-%20目录.md" target="_blank" rel="noopener">Leetcode 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/算法%20-%20目录.md" target="_blank" rel="noopener">算法</a></li>
</ul>
<h2 id="computer-操作系统"><a href="#computer-操作系统" class="headerlink" title=":computer: 操作系统"></a>:computer: 操作系统</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统%20-%20目录.md" target="_blank" rel="noopener">计算机操作系统</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md" target="_blank" rel="noopener">Linux</a></li>
</ul>
<h2 id="cloud-网络"><a href="#cloud-网络" class="headerlink" title=":cloud: 网络"></a>:cloud: 网络</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络%20-%20目录.md" target="_blank" rel="noopener">计算机网络</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md" target="_blank" rel="noopener">HTTP</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">Socket</a></li>
</ul>
<h2 id="art-面向对象"><a href="#art-面向对象" class="headerlink" title=":art: 面向对象"></a>:art: 面向对象</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式.md" target="_blank" rel="noopener">设计模式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/面向对象思想.md" target="_blank" rel="noopener">面向对象思想</a></li>
</ul>
<h2 id="floppy-disk-数据库"><a href="#floppy-disk-数据库" class="headerlink" title=":floppy_disk: 数据库"></a>:floppy_disk: 数据库</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/数据库系统原理.md" target="_blank" rel="noopener">数据库系统原理</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL.md" target="_blank" rel="noopener">SQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode-Database%20题解.md" target="_blank" rel="noopener">Leetcode-Database 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md" target="_blank" rel="noopener">MySQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md" target="_blank" rel="noopener">Redis</a></li>
</ul>
<h2 id="coffee-Java"><a href="#coffee-Java" class="headerlink" title=":coffee: Java"></a>:coffee: Java</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20基础.md" target="_blank" rel="noopener">Java 基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20容器.md" target="_blank" rel="noopener">Java 容器</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20并发.md" target="_blank" rel="noopener">Java 并发</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20虚拟机.md" target="_blank" rel="noopener">Java 虚拟机</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md" target="_blank" rel="noopener">Java I/O</a></li>
</ul>
<h2 id="bulb-系统设计"><a href="#bulb-系统设计" class="headerlink" title=":bulb: 系统设计"></a>:bulb: 系统设计</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/系统设计基础.md" target="_blank" rel="noopener">系统设计基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/分布式.md" target="_blank" rel="noopener">分布式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/集群.md" target="_blank" rel="noopener">集群</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/攻击技术.md" target="_blank" rel="noopener">攻击技术</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/缓存.md" target="_blank" rel="noopener">缓存</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/消息队列.md" target="_blank" rel="noopener">消息队列</a></li>
</ul>
<h2 id="wrench-工具"><a href="#wrench-工具" class="headerlink" title=":wrench: 工具"></a>:wrench: 工具</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md" target="_blank" rel="noopener">Git</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md" target="_blank" rel="noopener">Docker</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/构建工具.md" target="_blank" rel="noopener">构建工具</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/正则表达式.md" target="_blank" rel="noopener">正则表达式</a></li>
</ul>
<h2 id="watermelon-编码实践"><a href="#watermelon-编码实践" class="headerlink" title=":watermelon: 编码实践"></a>:watermelon: 编码实践</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/代码可读性.md" target="_blank" rel="noopener">代码可读性</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/代码风格规范.md" target="_blank" rel="noopener">代码风格规范</a></li>
</ul>
<h2 id="转载自"><a href="#转载自" class="headerlink" title=":转载自"></a>:转载自</h2><ul>
<li><a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">CyC2018</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/Mybatis-动态sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/05/20/Mybatis-动态sql/" class="post-title-link" itemprop="url">Mybatis 动态sql</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-05-20 21:41:10" itemprop="dateCreated datePublished" datetime="2018-05-20T21:41:10+08:00">2018-05-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 21:47:27" itemprop="dateModified" datetime="2019-10-10T21:47:27+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在报表类应用中，通常需要根据不同的维度去组合复杂的查询条件，然后构造SQL去执行查询。如果只是通过在程序中简单地拼接SQL语句，工作量会非常大，而且代码可能也非常难以维护。Mybatis支持动态SQL查询功能，可以通过配置动态的SQL来简化程序代码中复杂性，不过，这个颇有点XML编程的韵味，通过XML来处理复杂的数据判断、循环的功能，其实也很好理解。</p>
<p>建表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `traffic_info` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `domain` varchar(64) NOT NULL,</span><br><span class="line">  `traffic_host` varchar(64) NOT NULL,</span><br><span class="line">  `month` varchar(8) NOT NULL,</span><br><span class="line">  `monthly_traffic` int(11) DEFAULT &apos;0&apos;,</span><br><span class="line">  `global_traffic_rank` int(11) DEFAULT &apos;0&apos;,</span><br><span class="line">  `native_traffic_rank` int(11) DEFAULT &apos;0&apos;,</span><br><span class="line">  `rank_in_country` varchar(64) DEFAULT NULL,</span><br><span class="line">  `address` varchar(200) DEFAULT NULL,</span><br><span class="line">  `email` varchar(50) DEFAULT NULL,</span><br><span class="line">  `traffic_type` int(2) DEFAULT &apos;-1&apos;,</span><br><span class="line">  `status` int(2) DEFAULT &apos;0&apos;,</span><br><span class="line">  `created_at` date DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  `f1` varchar(255) DEFAULT NULL,</span><br><span class="line">  `f2` varchar(255) DEFAULT NULL,</span><br><span class="line">  `f3` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_traffic` (`domain`,`month`,`traffic_type`)</span><br><span class="line">) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>这个表用来存储域名的流量信息，流量信息我们从互联网上像Alexa、Compete、Quantcast等提供商获取，通过Crawler抓取的方式实现。我们先从简单的查询做起，只是根据某个字段进行查询，说明如何配置使用Mybatis，这里面也包含如何与Spring进行集成。</p>
<p>配置实践</p>
<p>下面是用到的一些资源的定义：</p>
<p>org.shirdrn.mybatis.TrafficInfo类<br>该类对应于traffic_info表中一条记录的数据，我们简单取几个字段，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package org.shirdrn.mybatis;</span><br><span class="line"> </span><br><span class="line">import java.io.Serializable;</span><br><span class="line"> </span><br><span class="line">public class TrafficInfo implements Serializable &#123;</span><br><span class="line">     </span><br><span class="line">     private static final long serialVersionUID = -8696613205078899594L;</span><br><span class="line">     int id;</span><br><span class="line">     String domain;</span><br><span class="line">     String month;</span><br><span class="line">     int monthlyTraffic;</span><br><span class="line">     </span><br><span class="line">     public int getId() &#123;</span><br><span class="line">          return id;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setId(int id) &#123;</span><br><span class="line">          this.id = id;</span><br><span class="line">     &#125;</span><br><span class="line">     public String getDomain() &#123;</span><br><span class="line">          return domain;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setDomain(String domain) &#123;</span><br><span class="line">          this.domain = domain;</span><br><span class="line">     &#125;</span><br><span class="line">     public String getMonth() &#123;</span><br><span class="line">          return month;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setMonth(String month) &#123;</span><br><span class="line">          this.month = month;</span><br><span class="line">     &#125;</span><br><span class="line">     public int getMonthlyTraffic() &#123;</span><br><span class="line">          return monthlyTraffic;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setMonthlyTraffic(int monthlyTraffic) &#123;</span><br><span class="line">          this.monthlyTraffic = monthlyTraffic;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     @Override</span><br><span class="line">     public String toString() &#123;</span><br><span class="line">          return &quot;[id=&quot; + id + &quot;, domain=&quot; + domain + &quot;, month=&quot; +</span><br><span class="line">                    month + &quot;, monthlyTraffic=&quot; + monthlyTraffic + &quot;]&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.shirdrn.mybatis.mapper.TrafficInfoMapper接口类<br>该类定义了一个与SQL配置进行映射的基本操作，实际的SQL配置有专门的XML文件来进行配置。该接口定义了如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.shirdrn.mybatis.mapper;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import org.shirdrn.mybatis.TrafficInfo;</span><br><span class="line"> </span><br><span class="line">public interface TrafficInfoMapper &#123;</span><br><span class="line"> </span><br><span class="line">     /**</span><br><span class="line">     * 根据指定id去查询记录，结果至多只有一条</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">     TrafficInfo getTrafficInfo(int id);</span><br><span class="line">     </span><br><span class="line">     /**</span><br><span class="line">     * 根据指定的domain参数查询记录，返回一个记录的列表</span><br><span class="line">     * @param domain</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">     List&lt;TrafficInfo&gt; getTrafficInfoList(String domain);</span><br><span class="line">     </span><br><span class="line">     /**</span><br><span class="line">     * 根据一个 字段domain进行查询，但是存在多个domain的值，传入一个数组</span><br><span class="line">     * @param domains</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">     List&lt;TrafficInfo&gt; getMultiConditionsList(String[] domains);</span><br><span class="line">     </span><br><span class="line">     /**</span><br><span class="line">     * 根据多个字段进行查询，每个字段可能有多个值，所以参数是Map类型</span><br><span class="line">     * @param conditions</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">     List&lt;TrafficInfo&gt; getMapConditionsList(Map&lt;String, Object&gt; conditions);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面接口中定义的操作，一个比一个复杂，我们通过这一系列操作来说明在Mybatis中如果使用各种查询功能。</p>
<p>org/shirdrn/mybatis/mapper/TrafficInfoMapper.xml映射配置文件<br>这个文件TrafficInfoMapper.xml对应了上面的org.shirdrn.mybatis.mapper.TrafficInfoMapper中定义的操作，通过XML的方式将对应的SQL查询构造出来，这个是Mybatis的核心功能。该文件的内容示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;mapper namespace=&quot;org.shirdrn.mybatis.mapper.TrafficInfoMapper&quot;&gt;</span><br><span class="line">     &lt;resultMap type=&quot;TrafficInfo&quot; id=&quot;tfMap&quot;&gt;</span><br><span class="line">          &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;domain&quot; column=&quot;domain&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;month&quot; column=&quot;month&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;monthlyTraffic&quot; column=&quot;monthlyTraffic&quot; /&gt;</span><br><span class="line">     &lt;/resultMap&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;select id=&quot;getTrafficInfo&quot; resultType=&quot;TrafficInfo&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">          SELECT * FROM domain_db.traffic_info WHERE id = #&#123;id&#125;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;select id=&quot;getTrafficInfoList&quot; resultType=&quot;TrafficInfo&quot; parameterType=&quot;string&quot;&gt;</span><br><span class="line">          SELECT * FROM domain_db.traffic_info WHERE domain = #&#123;domain&#125;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;select id=&quot;getMultiConditionsList&quot; resultMap=&quot;tfMap&quot;&gt;</span><br><span class="line">          SELECT * FROM domain_db.traffic_info WHERE domain IN</span><br><span class="line">          &lt;foreach collection=&quot;array&quot; index=&quot;index&quot; item=&quot;domain&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; </span><br><span class="line">             #&#123;domain&#125; </span><br><span class="line">         &lt;/foreach&gt;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;select id=&quot;getMapConditionsList&quot; resultMap=&quot;tfMap&quot;&gt;</span><br><span class="line">          SELECT * FROM domain_db.traffic_info WHERE domain IN</span><br><span class="line">          &lt;foreach collection=&quot;domains&quot; index=&quot;index&quot; item=&quot;domain&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; </span><br><span class="line">             #&#123;domain&#125; </span><br><span class="line">         &lt;/foreach&gt;</span><br><span class="line">         AND status = 0 AND month IN</span><br><span class="line">         &lt;foreach collection=&quot;months&quot; index=&quot;index&quot; item=&quot;month&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; </span><br><span class="line">             #&#123;month&#125; </span><br><span class="line">         &lt;/foreach&gt;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>如果你之前用过ibatis，应该很熟悉上面这个配置文件。上面：<br>namespace指定该SQL映射配置文件的Mapper接口类，其中定义了基本的SQL查询操作（以我们给出的例子为例）；<br>resultMap中的type的值这里是一个别名，当然也可以使用对应的具体类全名（包名+类名），我们会在Mybatis的总的映射配置文件中进行配置，详见后面说明；<br>select是查询SQL的配置，可以通过不同的元素进行动态构造，如if、foreach等；</p>
<p>Mybatis全局映射配置文件sqlMapConfig.xml<br>该文件可以指定数据库连接池配置、别名配置、SQL映射配置文件组等内容，这里示例的配置内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">     &lt;typeAliases&gt;</span><br><span class="line">          &lt;typeAlias type=&quot;org.shirdrn.mybatis.TrafficInfo&quot; alias=&quot;TrafficInfo&quot; /&gt;</span><br><span class="line">     &lt;/typeAliases&gt;</span><br><span class="line">     &lt;mappers&gt;</span><br><span class="line">          &lt;mapper resource=&quot;org/shirdrn/mybatis/mapper/TrafficInfoMapper.xml&quot; /&gt;</span><br><span class="line">     &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>Spring配置文件applicationContext.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/context/spring-context-3.0.xsd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/aop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;bean</span><br><span class="line">          class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;systemPropertiesModeName&quot; value=&quot;SYSTEM_PROPERTIES_MODE_OVERRIDE&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;ignoreResourceNotFound&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;locations&quot;&gt;</span><br><span class="line">               &lt;list&gt;</span><br><span class="line">                    &lt;value&gt;classpath*:/proxool.properties&lt;/value&gt;</span><br><span class="line">               &lt;/list&gt;</span><br><span class="line">          &lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;context:component-scan base-package=&quot;org.shirdrn.mybatis&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt;</span><br><span class="line">     &lt;aop:config proxy-target-class=&quot;true&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;bean id=&quot;dataSource&quot; class=&quot;org.shirdrn.mybatis.utils.ProxoolDataSource&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc-0.proxool.driver-class&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;driverUrl&quot; value=&quot;$&#123;jdbc-0.proxool.driver-url&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc-0.user&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc-0.password&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;alias&quot; value=&quot;$&#123;jdbc-0.proxool.alias&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;prototypeCount&quot; value=&quot;$&#123;jdbc-0.proxool.prototype-count&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;maximumActiveTime&quot; value=&quot;$&#123;jdbc-0.proxool.maximum-active-time&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;maximumConnectionCount&quot; value=&quot;$&#123;jdbc-0.proxool.maximum-connection-count&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;minimumConnectionCount&quot; value=&quot;$&#123;jdbc-0.proxool.minimum-connection-count&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;simultaneousBuildThrottle&quot;</span><br><span class="line">               value=&quot;$&#123;jdbc-0.proxool.simultaneous-build-throttle&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;verbose&quot; value=&quot;$&#123;jdbc-0.proxool.verbose&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;trace&quot; value=&quot;$&#123;jdbc-0.proxool.trace&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;houseKeepingTestSql&quot; value=&quot;$&#123;jdbc-0.proxool.house-keeping-test-sql&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;houseKeepingSleepTime&quot; value=&quot;$&#123;jdbc-0.proxool.house-keeping-sleep-time&#125;&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;maximumConnectionLifetime&quot;</span><br><span class="line">               value=&quot;$&#123;jdbc-0.proxool.maximum-connection-lifetime&#125;&quot; /&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;bean id=&quot;dataSource0&quot; class=&quot;org.jdbcdslog.ConnectionPoolDataSourceProxy&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;targetDSDirect&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;!-- http://mybatis.github.io/spring/getting-started.html --&gt;</span><br><span class="line">     &lt;!-- http://mybatis.github.io/spring/zh/ --&gt;</span><br><span class="line">     &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource0&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;configLocation&quot; value=&quot;classpath:sqlMapConfig.xml&quot;/&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line">     &lt;bean id=&quot;trafficInfoMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;mapperInterface&quot; value=&quot;org.shirdrn.mybatis.mapper.TrafficInfoMapper&quot; /&gt;</span><br><span class="line">          &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line">     &lt;bean id=&quot;trafficInfoService&quot; class=&quot;org.shirdrn.mybatis.TrafficInfoService&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;trafficInfoMapper&quot; ref=&quot;trafficInfoMapper&quot; /&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>简单说明一下：<br>dataSource使用的Proxool连接池组件；<br>sqlSessionFactory是Mybatis的SessionFactory，注入了前面获取到的dataSource，同时指定了Mybatis的总的映射配置文件classpath:sqlMapConfig.xml，属性名为configLocation；<br>trafficInfoMapper直接由Spring的org.mybatis.spring.mapper.MapperFactoryBean进行代理，需要注入属性mapperInterface（即我们定义的SQL Mapper操作的接口类）和sqlSessionFactory（前面的SessionFactory实例）；<br>trafficInfoService是我们最终在其中进行调用的服务类，注入了我们定义的SQL Mapper接口类的实例trafficInfoMapper。</p>
<p>org.shirdrn.mybatis.TrafficInfoService服务类<br>为简单起见，我们就不定义服务接口了，直接在该类中实现，调用SQL Mapper中预定义的SQL查询操作，实现代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package org.shirdrn.mybatis;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import org.shirdrn.mybatis.mapper.TrafficInfoMapper;</span><br><span class="line"> </span><br><span class="line">public class TrafficInfoService &#123;</span><br><span class="line"> </span><br><span class="line">     private TrafficInfoMapper trafficInfoMapper;</span><br><span class="line">     </span><br><span class="line">     public void setTrafficInfoMapper(TrafficInfoMapper trafficInfoMapper) &#123;</span><br><span class="line">          this.trafficInfoMapper = trafficInfoMapper;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     public TrafficInfo getTrafficInfo(int id) &#123;</span><br><span class="line">          return trafficInfoMapper.getTrafficInfo(id);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public List&lt;TrafficInfo&gt; getTrafficInfoList(String domain) &#123;</span><br><span class="line">          return trafficInfoMapper.getTrafficInfoList(domain);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public List&lt;TrafficInfo&gt; getMultiConditionsList(String[] domains) &#123;</span><br><span class="line">          return trafficInfoMapper.getMultiConditionsList(domains);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     List&lt;TrafficInfo&gt; getMapConditionsList(Map&lt;String, Object&gt; conditions) &#123;</span><br><span class="line">          return trafficInfoMapper.getMapConditionsList(conditions);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的配置，我们就能够实现从单个字段的查询，到多个字段的组合复杂查询。可以通过与实际编写代码来控制这些逻辑相比较，使用Mybatis可能配置上相对复杂一些，但是或得到的好处是非常多的，如代码可维护性好，看起来配置比较直观，出错的几率会大大减小。实际上，如果熟练的这种配置方式，就会在实际开发过程中，更好地去处理更加复杂的统计查询条件的组合逻辑。</p>
<p>测试用例</p>
<p>测试用例可以检测我们上面的配置是否生效，实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package org.shirdrn.mybatis;</span><br><span class="line"> </span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"> </span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &#123; &quot;classpath:/applicationContext*.xml&quot; &#125;)</span><br><span class="line">public class TestTrafficInfoService &#123;</span><br><span class="line"> </span><br><span class="line">     @Autowired</span><br><span class="line">     private TrafficInfoService trafficInfoService;</span><br><span class="line"> </span><br><span class="line">     @Test</span><br><span class="line">     public void getTraffic() &#123;</span><br><span class="line">          int id = 1196;</span><br><span class="line">          TrafficInfo result = trafficInfoService.getTrafficInfo(id);</span><br><span class="line">          System.out.println(result);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     @Test</span><br><span class="line">     public void getTrafficList() &#123;</span><br><span class="line">          String domain = &quot;make-the-cut.com&quot;;</span><br><span class="line">          List&lt;TrafficInfo&gt; results = trafficInfoService.getTrafficInfoList(domain);</span><br><span class="line">          System.out.println(results);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     @Test</span><br><span class="line">     public void getMultiConditionsList() &#123;</span><br><span class="line">          String[] domains = new String[] &#123;</span><br><span class="line">                    &quot;make.tv&quot;, &quot; make-the-cut.com&quot;, &quot;makgrills.com&quot;, &quot;makino.com&quot;</span><br><span class="line">          &#125;;</span><br><span class="line">          List&lt;TrafficInfo&gt; results = trafficInfoService.getMultiConditionsList(domains);</span><br><span class="line">          System.out.println(results);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     @Test</span><br><span class="line">     public void getMapConditionsList() &#123;</span><br><span class="line">          String[] domains = new String[] &#123;</span><br><span class="line">                    &quot;make.tv&quot;, &quot; make-the-cut.com&quot;, &quot;makgrills.com&quot;, &quot;makino.com&quot;</span><br><span class="line">          &#125;;</span><br><span class="line">          List&lt;String&gt; months = Arrays.asList(new String[] &#123;</span><br><span class="line">                    &quot;201203&quot;, &quot;201204&quot;, &quot;201205&quot;</span><br><span class="line">          &#125;);</span><br><span class="line">          Map&lt;String, Object&gt; conditions = new HashMap&lt;String, Object&gt;(2);</span><br><span class="line">          conditions.put(&quot;domains&quot;, domains);</span><br><span class="line">          conditions.put(&quot;months&quot;, months);</span><br><span class="line">          List&lt;TrafficInfo&gt; results = trafficInfoService.getMapConditionsList(conditions);</span><br><span class="line">          System.out.println(results);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询进阶</p>
<p>这里，给出一个实际的例子，是对每日报表的一个统计实例，为简单起见，只拿出2张表做LEFT JOIN连接。这个需求，要求查询时可以对每个维度取过得查询条件值，如对于维度osName，值可以使包含Android、IOS，对于另一个维度statDate，可以取最近2天（昨天和前天），等等，并且，这些组合条件可有可无。<br>对应的Mybatis映射配置文件，内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;mapper namespace=&quot;org.shirdrn.data.mappers.DailyAppUserMapper&quot;&gt;</span><br><span class="line">     &lt;resultMap id=&quot;dailyAppUserMap&quot; type=&quot;DailyAppUser&quot;&gt;</span><br><span class="line">          &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;primaryCategoryId&quot; column=&quot;primary_category_id&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;primaryCategoryName&quot; column=&quot;primary_category_name&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;secondaryCategoryId&quot; column=&quot;secondary_category_id&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;secondaryCategoryName&quot; column=&quot;secondary_category_name&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;cooperationMode&quot; column=&quot;cooperation_mode&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;merchantId&quot; column=&quot;merchant_id&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;merchantName&quot; column=&quot;merchant_name&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;osName&quot; column=&quot;osName&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;channelId&quot; column=&quot;channel_id&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;channelName&quot; column=&quot;channel_name&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;version&quot; column=&quot;version&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;statDate&quot; column=&quot;stat_date&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserOpen&quot; column=&quot;new_user_open&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;activeUserOpen&quot; column=&quot;active_user_open&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;activeUserPlay&quot; column=&quot;active_user_play&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;oldUserOpen&quot; column=&quot;old_user_open&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;oldUserPlay&quot; column=&quot;old_user_play&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;averageTime&quot; column=&quot;average_time&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserAverageTime&quot; column=&quot;new_user_average_time&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;oldUserAverageTime&quot; column=&quot;old_user_average_time&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserOpen2Retention&quot; column=&quot;new_user_open_2retention&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserOpen3Retention&quot; column=&quot;new_user_open_3retention&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserOpen7Retention&quot; column=&quot;new_user_open_7retention&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserOpen15Retention&quot; column=&quot;new_user_open_15retention&quot; /&gt;</span><br><span class="line">          &lt;result property=&quot;newUserOpen30Retention&quot; column=&quot;new_user_open_30retention&quot; /&gt;</span><br><span class="line">     &lt;/resultMap&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;select id=&quot;getDailyAppUserListByPage&quot; resultMap=&quot;dailyAppUserMap&quot;&gt;</span><br><span class="line">          &lt;include refid=&quot;getDailyAppUserList&quot;/&gt;</span><br><span class="line">          LIMIT #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">      </span><br><span class="line">     &lt;select id=&quot;getDailyAppUserListForReport&quot; resultMap=&quot;dailyAppUserMap&quot;&gt;</span><br><span class="line">          &lt;include refid=&quot;getDailyAppUserList&quot;/&gt;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">      </span><br><span class="line">     &lt;sql id=&quot;getDailyAppUserList&quot; &gt;</span><br><span class="line">          SELECT </span><br><span class="line">               d.id AS id,</span><br><span class="line">               d.primary_category_id AS primary_category_id,</span><br><span class="line">               d.primary_category_name AS primary_category_name,</span><br><span class="line">               d.secondary_category_id AS secondary_category_id,</span><br><span class="line">               d.secondary_category_name AS secondary_category_name,</span><br><span class="line">               d.cooperation_mode AS cooperation_mode,</span><br><span class="line">               d.merchant_id AS merchant_id,</span><br><span class="line">               d.osName AS osName,</span><br><span class="line">               d.channel_id AS channel_id,</span><br><span class="line">               (CASE WHEN d.channel_name IS NOT NULL THEN d.channel_name ELSE d.channel_id END) AS channel_name,</span><br><span class="line">               d.version AS version,</span><br><span class="line">               d.stat_date AS stat_date,</span><br><span class="line">               d.new_user_open AS new_user_open,</span><br><span class="line">               d.new_user_play AS new_user_play,</span><br><span class="line">               d.active_user_open AS active_user_open,</span><br><span class="line">               d.active_user_play AS active_user_play,</span><br><span class="line">               d.old_user_open AS old_user_open,</span><br><span class="line">               d.old_user_play AS old_user_play,</span><br><span class="line">               d.average_time AS average_time,</span><br><span class="line">               d.new_user_average_time AS new_user_average_time,</span><br><span class="line">               d.old_user_average_time AS old_user_average_time,</span><br><span class="line">               d.new_user_open_2retention AS new_user_open_2retention,</span><br><span class="line">               d.new_user_open_3retention AS new_user_open_3retention,</span><br><span class="line">               d.new_user_open_7retention AS new_user_open_7retention,</span><br><span class="line">               d.new_user_open_15retention AS new_user_open_15retention,</span><br><span class="line">               d.new_user_open_30retention AS new_user_open_30retention,</span><br><span class="line">               d.uninstall_cnt AS uninstall_cnt,</span><br><span class="line">               m.merchant_name AS merchant_name</span><br><span class="line">          FROM daily_app_user d </span><br><span class="line">          LEFT JOIN merchant m ON d.merchant_id=m.id </span><br><span class="line">          WHERE d.stat_date = #&#123;statDate&#125;</span><br><span class="line">          &lt;if test=&quot;osNames!=null&quot;&gt;</span><br><span class="line">               AND d.osName IN</span><br><span class="line">               &lt;foreach collection=&quot;osNames&quot; index=&quot;index&quot; item=&quot;osName&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    #&#123;osName&#125;</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">          &lt;if test=&quot;channelNames!=null&quot;&gt;</span><br><span class="line">               AND</span><br><span class="line">               &lt;foreach collection=&quot;channelNames&quot; index=&quot;index&quot; item=&quot;channelName&quot; open=&quot; (&quot; separator=&quot; OR &quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    (d.channel_name LIKE CONCAT(&apos;%&apos;, CONCAT(#&#123;channelName&#125;, &apos;%&apos;)))</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">          &lt;if test=&quot;versions!=null&quot;&gt;</span><br><span class="line">               AND d.version IN</span><br><span class="line">               &lt;foreach collection=&quot;versions&quot; index=&quot;index&quot; item=&quot;version&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    #&#123;version&#125;</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">          &lt;if test=&quot;merchantNames!=null&quot;&gt;</span><br><span class="line">               AND</span><br><span class="line">               &lt;foreach collection=&quot;merchantNames&quot; index=&quot;index&quot; item=&quot;merchantName&quot; open=&quot; (&quot; separator=&quot; OR &quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    (m.merchant_name LIKE CONCAT(&apos;%&apos;, CONCAT(#&#123;%merchantName%&#125;, &apos;%&apos;)))</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">          &lt;if test=&quot;primaryCategories!=null&quot;&gt;</span><br><span class="line">               AND d.primary_category_id IN</span><br><span class="line">               &lt;foreach collection=&quot;primaryCategories&quot; index=&quot;index&quot; item=&quot;primaryCategory&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    #&#123;primaryCategory&#125;</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">          &lt;if test=&quot;secondaryCategories!=null&quot;&gt;</span><br><span class="line">               AND d.secondary_category_id IN</span><br><span class="line">               &lt;foreach collection=&quot;secondaryCategories&quot; index=&quot;index&quot; item=&quot;secondaryCategory&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    #&#123;secondaryCategory&#125;</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">          &lt;if test=&quot;cooperationModes!=null&quot;&gt;</span><br><span class="line">               AND d.cooperation_model IN</span><br><span class="line">               &lt;foreach collection=&quot;cooperationModes&quot; index=&quot;index&quot; item=&quot;cooperationMode&quot; open=&quot; (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                    #&#123;cooperationMode&#125;</span><br><span class="line">               &lt;/foreach&gt;</span><br><span class="line">          &lt;/if&gt;</span><br><span class="line">     &lt;/sql&gt;</span><br><span class="line">      </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>上述映射配置对应的Mapper定义，接口如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package org.shirdrn.data.mappers;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import org.shirdrn.data.beans.DailyAppUser;</span><br><span class="line"> </span><br><span class="line">public class DailyAppUserMapper &#123;</span><br><span class="line"> </span><br><span class="line">     List&lt;DailyAppUser&gt; getDailyAppUserListByPage(Map&lt;String, Object&gt; conditions);</span><br><span class="line">     List&lt;DailyAppUser&gt; getDailyAppUserListForReport(Map&lt;String, Object&gt; conditions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，如果多个表，一定要设置好Mapper映射配置中每个select元素的resultMap属性，属性值就是前部分的resultMap定义的id。如果只从单个表查询数据，完全可以使用resultType，对应resultMap元素中配置的type属性所指定的别名。<br>实际上，我们需要通过Map来传递参数，也就是把查询的条件值都收集起来，然后放到Map中，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; conditions = new HashMap&lt;String, Object&gt;();</span><br><span class="line">if(osNames != null) &#123;</span><br><span class="line">     conditions.put(DailyAppUserMapper.KEY_OS_NAMES, osNames);</span><br><span class="line">&#125;</span><br><span class="line">if(channelNames != null) &#123;</span><br><span class="line">     conditions.put(DailyAppUserMapper.KEY_CHANNEL_NAMES, channelNames);</span><br><span class="line">&#125;</span><br><span class="line">if(versions != null) &#123;</span><br><span class="line">     conditions.put(DailyAppUserMapper.KEY_VERSIONS, versions);</span><br><span class="line">&#125;</span><br><span class="line">if(merchantNames != null) &#123;</span><br><span class="line">     conditions.put(DailyAppUserMapper.KEY_MERCHANT_NAMES, merchantNames);</span><br><span class="line">&#125;</span><br><span class="line">if(primaryCategories != null) &#123;</span><br><span class="line">     conditions.put(DailyAppUserMapper.KEY_PRIMARY_CATEGORIES, primaryCategories);</span><br><span class="line">&#125;</span><br><span class="line">if(secondaryCategories != null) &#123;</span><br><span class="line">     conditions.put(DailyAppUserMapper.KEY_SECONDARY_CATEGORIES, secondaryCategories);</span><br><span class="line">&#125;</span><br><span class="line">if(cooperationModes != null) &#123;</span><br><span class="line">     conditions.put(ChannelDayMapper.KEY_COOPERATION_MODES, cooperationModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面对应的DailyAppUserMapper中定义的一些Key常量名称，要和Mapper配置文件中foreach元素的collection属性值一致。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/05/10/docker/" class="post-title-link" itemprop="url">docker</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-05-10 15:10:25" itemprop="dateCreated datePublished" datetime="2018-05-10T15:10:25+08:00">2018-05-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 21:35:40" itemprop="dateModified" datetime="2019-10-10T21:35:40+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- GFM-TOC -->
<ul>
<li><a href="#一解决的问题">一、解决的问题</a></li>
<li><a href="#二与虚拟机的比较">二、与虚拟机的比较</a></li>
<li><a href="#三优势">三、优势</a></li>
<li><a href="#四使用场景">四、使用场景</a></li>
<li><a href="#五镜像与容器">五、镜像与容器</a></li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
<h1 id="一、解决的问题"><a href="#一、解决的问题" class="headerlink" title="一、解决的问题"></a>一、解决的问题</h1><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
<h1 id="二、与虚拟机的比较"><a href="#二、与虚拟机的比较" class="headerlink" title="二、与虚拟机的比较"></a>二、与虚拟机的比较</h1><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p>
<h2 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h2><p>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p>
<p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p>
<h2 id="占用资源"><a href="#占用资源" class="headerlink" title="占用资源"></a>占用资源</h2><p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p>
<p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p>
<h1 id="三、优势"><a href="#三、优势" class="headerlink" title="三、优势"></a>三、优势</h1><p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p>
<h2 id="更容易迁移"><a href="#更容易迁移" class="headerlink" title="更容易迁移"></a>更容易迁移</h2><p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p>
<h2 id="更容易维护"><a href="#更容易维护" class="headerlink" title="更容易维护"></a>更容易维护</h2><p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p>
<h2 id="更容易扩展"><a href="#更容易扩展" class="headerlink" title="更容易扩展"></a>更容易扩展</h2><p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
<h1 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h1><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p>
<p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p>
<h2 id="提供可伸缩的云服务"><a href="#提供可伸缩的云服务" class="headerlink" title="提供可伸缩的云服务"></a>提供可伸缩的云服务</h2><p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p>
<h2 id="搭建微服务架构"><a href="#搭建微服务架构" class="headerlink" title="搭建微服务架构"></a>搭建微服务架构</h2><p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p>
<h2 id="docker与swarm"><a href="#docker与swarm" class="headerlink" title="docker与swarm"></a>docker与swarm</h2><p>Docker集群管理和编排的特性是通过SwarmKit进行构建的， 其中Swarm mode是Docker Engine内置支持的一种默认实现。Docker 1.12以及更新的版本，都支持Swarm mode，我们可以基于Docker Engine来构建Swarm集群，然后就可以将我们的应用服务（Application Service）部署到Swarm集群中。创建Swarm集群的方式很简单，先初始化一个Swarm集群，然后将其他的Node加入到该集群即可。本文主要基于Docker Swarm官网文档，学习总结。</p>
<p>Docker Swarm具有如下基本特性：</p>
<p>集群管理集成进Docker Engine<br>使用内置的集群管理功能，我们可以直接通过Docker CLI命令来创建Swarm集群，然后去部署应用服务，而不再需要其它外部的软件来创建和管理一个Swarm集群。</p>
<p>去中心化设计<br>Swarm集群中包含Manager和Worker两类Node，我们可以直接基于Docker Engine来部署任何类型的Node。而且，在Swarm集群运行期间，我们既可以对其作出任何改变，实现对集群的扩容和缩容等，如添加Manager Node，如删除Worker Node，而做这些操作不需要暂停或重启当前的Swarm集群服务。</p>
<p>声明式服务模型（Declarative Service Model）<br>在我们实现的应用栈中，Docker Engine使用了一种声明的方式，让我们可以定义我们所期望的各种服务的状态，例如，我们创建了一个应用服务栈：一个Web前端服务、一个后端数据库服务、Web前端服务又依赖于一个消息队列服务。</p>
<p>服务扩容缩容<br>对于我们部署的每一个应用服务，我们可以通过命令行的方式，设置启动多少个Docker容器去运行它。已经部署完成的应用，如果有扩容或缩容的需求，只需要通过命令行指定需要几个Docker容器即可，Swarm集群运行时便能自动地、灵活地进行调整。</p>
<p>协调预期状态与实际状态的一致性<br>Swarm集群Manager Node会不断地监控集群的状态，协调集群状态使得我们预期状态和实际状态保持一致。例如我们启动了一个应用服务，指定服务副本为10，则会启动10个Docker容器去运行，如果某个Worker Node上面运行的2个Docker容器挂掉了，则Swarm Manager会选择集群中其它可用的Worker Node，并创建2个服务副本，使实际运行的Docker容器数仍然保持与预期的10个一致。</p>
<p>多主机网络<br>我们可以为待部署应用服务指定一个Overlay网络，当应用服务初始化或者进行更新时，Swarm Manager在给定的Overlay网络中为Docker容器自动地分配IP地址，实际是一个虚拟IP地址（VIP）。</p>
<p>服务发现<br>Swarm Manager会给集群中每一个服务分配一个唯一的DNS名称，对运行中的Docker容器进行负载均衡。我们可以通过Swarm内置的DNS Server，查询Swarm集群中运行的Docker容器状态。</p>
<p>负载均衡<br>在Swarm内部，可以指定如何在各个Node之间分发服务容器（Service Container），实现负载均衡。如果想要使用Swarm集群外部的负载均衡器，可以将服务容器的端口暴露到外部。</p>
<p>安全策略<br>在Swarm集群内部的Node，强制使用基于TLS的双向认证，并且在单个Node上以及在集群中的Node之间，都进行安全的加密通信。我们可以选择使用自签名的根证书，或者使用自定义的根CA（Root CA）证书。</p>
<p>滚动更新（Rolling Update）<br>对于服务需要更新的场景，我们可以在多个Node上进行增量部署更新，Swarm Manager支持通过使用Docker CLI设置一个delay时间间隔，实现多个服务在多个Node上依次进行部署。这样可以非常灵活地控制，如果有一个服务更新失败，则暂停后面的更新操作，重新回滚到更新之前的版本。</p>
<h1 id="五、镜像与容器"><a href="#五、镜像与容器" class="headerlink" title="五、镜像与容器"></a>五、镜像与容器</h1><p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
<h1 id="Docker-Troubleshooting"><a href="#Docker-Troubleshooting" class="headerlink" title="Docker Troubleshooting"></a>Docker Troubleshooting</h1><h3 id="get-Container-ID-through-PID"><a href="#get-Container-ID-through-PID" class="headerlink" title="get Container ID through PID"></a>get Container ID through PID</h3><p>最近使用 <code>top</code> 查看服务器状态时，总是看到有几个应用的占用的资源很高，需要知道容器信息;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -axfo pid,uname,cmd | grep -C 4 $pid #--获取到容器内运行的ID对应于宿主机的ID</span><br><span class="line">docker ps -q | xargs docker inspect -f &apos;&#123;&#123;.State.Pid&#125;&#125;  &#123;&#123;.Config.Hostname&#125;&#125;&apos; | grep $pid</span><br></pre></td></tr></table></figure>

<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ol>
<li>深入理解Linux操作系统, 掌握主流linux服务器系统安装配置维护能力 </li>
<li>熟悉常见的服务器基础设施（Nginx、Rabbitmq、Kafka、Mysql、Redis 、ELK、Jenkins、Gitlab、Memcache、Tomcat等）的安装、维护和优化; </li>
<li>熟悉CI/CD技术和流程，有项目持续集成经验，使用过Jenkins+Maven+Nexus+Git等工具 </li>
<li>熟悉微服务，网关、熟悉网关配置，能合理的实施负载均衡 </li>
<li>熟悉docker以及任务编排，熟悉k8s架构，容器化经验2年以上； </li>
<li>熟悉主流云计算产品，对云计算产品的配置管理有一定经验。 </li>
<li>熟练掌握开源监控软件zabbix prometheus等 </li>
<li>熟悉Python语言，熟悉Shell脚本编写，有一定编程能力； </li>
<li>熟悉shell脚本编写, 具备python和golang语言开发能力 </li>
<li>熟悉常用NAS设备，精通分布式存储系统ceph </li>
<li>至少熟悉一种配置管理工具, 如salt, ansible等 </li>
<li>掌握RAID，ipmi等服务器技术原理和应用 </li>
</ol>
<hr>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><ul>
<li>Kubernetes是什么</li>
</ul>
<p>Kubernetes是一个开源的容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。我们在完成一个应用程序的开发时，需要冗余部署该应用的多个实例，同时需要支持对应用的请求进行负载均衡，在Kubernetes中，我们可以把这个应用的多个实例分别启动一个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要应用开发和运维人员去进行复杂的手工配置和处理。<br>Kubernetes是Google基于内部Borg开源的容器编排引擎，关于Borg的设计，可以查看对应的论文《Large-scale cluster management at Google with Borg》。这里，我们先说一说Borg系统，它是Google内部的集群管理系统，使用它能够获得如下好处：</p>
<p>在一个分布式系统中进行资源管理是非常复杂的，构建于Borg系统之上的其他系统，无需关心这些资源管理的复杂细节<br>在大型分布式系统中处理异常也是非常困难的，Borg也屏蔽了运行于其上系统对失败或异常情况的处理，用户可以将精力集中在开发自己的应用系统上<br>支持高可靠性、高可用性<br>Borg支持不同Workload，并且都能够非常高效地运行<br>从应用的视角来看，Google内部的很多系统都构建于Borg之上：应用框架，如MapReduce、FlumeJava、MillWheel、Pregel；存储系统，如GFS、CFS、Bigtable、Megastore。<br>从用户的视角来看， 运行在Borg集群之上的Workload主要分为两类：一类是long-running服务，这类服务一旦运行就不应该终止，比如Gmail、Google Docs、Google Search；另一类是批量作业，这类批量作业可能运行几秒到几天不等，比如MapReduce作业。</p>
<ul>
<li>主要特性</li>
</ul>
<p>自动化部署<br>应用部署到容器中，Kubernetes能够根据应用程序的计算资源需求和其它一些限制条件，自动地将运行应用程序的容器调度到集群中指定的Node上，在这个过程中并不会影响应用程序的可用性。</p>
<p>系统自愈<br>当Kubernetes集群中某些容器失败时，会重新启动他们。当某些Node挂掉后，Kubernetes会自动重新调度这些Node上的容器到其他可用的Node上。如果某些容器没有满足用户定义的健康检查条件，这些容器会被判定为无法正常工作的，集群会自动Kill掉这些容器，在这个过程中直到容器被重新启动或重新调度，直到可用以后才会对调用的客户端可见。</p>
<p>水平扩展<br>在Kubernetes中，通过一个命令就可以实现应用程序的水平扩展，实现这个功能的是HPA（Horizontal Pod Autoscaler）对象。HPA是通过Kubernetes API Resource和Controller的方式实现的，其中Resource决定了Controller的行为，而Controller周期性地调整Replication Controller或Deployment中的副本数，使得观察到的平均CPU使用情况与用户定义的能够匹配。</p>
<p>服务发现和负载均衡<br>Kubernetes内置实现了服务发现的功能，他会给每个容器指派一个IP地址，给一组容器指派一个DNS名称，通过这个就可以实现服务的负载均衡功能。</p>
<p>自动更新和回滚<br>当我们开发的应用程序发生变更，Kubernetes可以实现滚动更新，同时监控应用的状态，确保不会在同一时刻杀掉所有的实例，造成应用在一段时间范围内不可用。如果某些时候应用更新出错，Kubernetes能够自动地将应用恢复到原来正确的状态。</p>
<p>密钥和配置管理<br>Kubernetes提供了一种机制（ConfigMap），能够使我们的配置数据与应用对应的Docker镜像解耦合，如果配置需要变更，不需要重新构建Docker镜像，这为应用开发部署提供很大的灵活性。<br>同时，对于应用所依赖的一些敏感信息，如用户名和密码、令牌、秘钥等信息，Kubernetes也通过Secret对象实现了将这些敏感配置信息与应用的解耦合，这对应用的快速开发和交付提供了便利，在一定程上提供了也安全保障。</p>
<p>存储挂载<br>Kubernetes可以支持挂载不同类型存储系统，比如本地存储、公有云存储（如AWS、GCP）、网络存储系统（如NFS、iSCSI、Gluster、Ceph、Cinder、Flocker）等，我们可以进行灵活的选择。</p>
<p>批量作业执行<br>Kubernetes也支持批量作业的处理、监控、恢复。作业提交以后，直到作业运行完成即退出。如果运行失败，Kubernetes能够使失败的作业自动重新运行，直到作业运行成功为止。</p>
<p>总体架构</p>
<p>首先给出一个概念：Kubernetes Control Plane，翻译过来就是“Kubernetes控制平面”，它表示Kubernetes为了实现最终的目标而构建的一组集群范围内的进程，这组进程相互协调，保证整个集群系统达到用户所期望的目标状态，比如，容器失败自动调度并重启，应用服务的扩容缩容，等等。<br>Kubernetes Control Plane管理了Kubernetes集群中的所有Kubernetes对象及其状态，这些对象包括Pod、Service、Volume、Namespace、ReplicaSet、Deployment、StatefulSet、DaemonSet、Job等等。</p>
<p>Kubernetes Control Plane主要包含两部分，一部分是Kubernetes集群Master上一组关键进程，另一个部分是在每个工作的Node节点上的一组关键进程，下面我们分别详细说明：</p>
<p>Kubernetes Master</p>
<p>Kubernetes Master主要由kube-apiserver、kube-controller-manager和kube-scheduler三个进程组成，它们运行在集群中一个单独的节点上，具体说明如下：<br>kube-apiserver进程：想要操作Kubernetes集群中的任何对象，都需要经过kube-apiserver，它封装了对Kubernetes对象的所有操作，以REST接口方式提供给想要与Kubernetes交互的任何客户端。经过kube-apiserver的所有对Kubernetes对象的修改操作都将持久化到etcd存储中。<br>kube-controller-manager进程：负责运行各种Controller，这些Controller主要包括：</p>
<p>Node Controller<br>Replication Controller<br>Endpoints Controller<br>Service Account<br>Token Controller<br>kube-scheduler进程：负责Kubernetes集群内部的资源调度，主要负责监视Kubernetes集群内部已创建但没有被调度到某个Node上的Pod，然后将该Pod调度到一个选定的Node上面运行。</p>
<p>Kubernetes Node</p>
<p>Kubernetes集群中，每个工作的Node节点上主要运行如下两个进程：<br>kubelet进程：kubelet负责监视指派到它所在Node上的Pod，还负责处理如下工作：</p>
<p>为Pod挂载Volume<br>下载Pod拥有的Secret<br>运行属于Pod的容器<br>周期性地检查Pod中的容器是否存活<br>向Master报告当前Node上Pod的状态信息<br>向Master报告当前Node的状态信息<br>kube-proxy进程：在Kubernetes集群中，每个Node上面都有一个该网络代理进程，它主要负责为Pod对象提供代理：定期从etcd存储中获取所有的Service对象，并根据Service信息创建代理。当某个Client要访问一个Pod时，请求会经过该Node上的代理进程进行请求转发。</p>
<h2 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h2><p><strong>TTL Mechanism</strong> and <strong>Lease</strong> </p>
<p><code>bidirectional gRPC stream</code></p>
<h2 id="自签名SSL证书"><a href="#自签名SSL证书" class="headerlink" title="自签名SSL证书"></a>自签名SSL证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir secrets</span><br><span class="line">$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout secrets/domain.key -x509 -day 365 -out secrets/domain.crt</span><br><span class="line">$ ls secrets</span><br><span class="line">$ openssl rand -hex -out secrets/http.secret 8</span><br><span class="line">$ docker run -i httpd /bin/bash -c &apos;echo my-super-secure-password | /usr/local/apache2/bin/htpasswd -nBi user01&apos; &gt; secrets/registry_passwd</span><br><span class="line">$ kubectl create secret generic registry-secrets --from-file secrets/</span><br></pre></td></tr></table></figure>

<h2 id="集群管理高级"><a href="#集群管理高级" class="headerlink" title="集群管理高级"></a>集群管理高级</h2><h3 id="kubeconfig-高阶配置"><a href="#kubeconfig-高阶配置" class="headerlink" title="kubeconfig 高阶配置"></a>kubeconfig 高阶配置</h3><p><strong>kubeconfig</strong> 管理集群、上下文、认证；可以在不同集群不同上下文进行环境的切换</p>
<p><code>kubectl config</code></p>
<p><img src="./e705eb01-9990-424f-8967-f63d4de49904.png" alt="kubeconfig contains three parameters:user, cluster, and context"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看 kubernetes 配置</span><br><span class="line">$ kubectl config view</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># 备份</span><br><span class="line">$ cp ~/.kube/config ~/original-kubeconfig</span><br><span class="line"></span><br><span class="line"># 查看配置具体选项</span><br><span class="line">$ kubectl config set-credentials -h</span><br><span class="line"># 复制到新目录</span><br><span class="line">$ cp ~/original-kubeconfig ~/new-kubeconfig</span><br><span class="line"># 添加用户</span><br><span class="line">$ kubectl config set-credentials local@local.com --username=local-local --password=123qwe --kubeconfig=&quot;new-kubeconfig&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p><code>Context</code> 包含了cluster, namespaces, user;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 设置Context</span><br><span class="line">S kubectl config set-context &lt;context_name&gt; --user=&lt;credential_name&gt; --namespaces=&lt;namespace_name&gt; --cluster=&lt;cluster_name&gt;</span><br><span class="line">$ kubectl config set-context defalut/local/local --user=local@local.com --namespaces=defalut --cluster=cluster.local</span><br><span class="line"></span><br><span class="line"># 查看配置</span><br><span class="line">$ kubectl config view </span><br><span class="line"></span><br><span class="line"># 当前上下文</span><br><span class="line">$ kubectl config current-context</span><br><span class="line"></span><br><span class="line"># 切换上下文</span><br><span class="line">$ kubectl config use-context defalut/local/local</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">$ kubectl config delete-cluster local-cluster</span><br><span class="line"></span><br><span class="line">$ kubectl unset local@local.com</span><br><span class="line"></span><br><span class="line">$ cp ./original-kubeconfig ~/.kube/config</span><br></pre></td></tr></table></figure>

<h3 id="node-资源配置"><a href="#node-资源配置" class="headerlink" title="node 资源配置"></a>node 资源配置</h3><h3 id="WebUI"><a href="#WebUI" class="headerlink" title="WebUI"></a>WebUI</h3><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><h3 id="Kubernetes-DNS"><a href="#Kubernetes-DNS" class="headerlink" title="Kubernetes DNS"></a>Kubernetes DNS</h3><h3 id="Authentication-and-Authorization"><a href="#Authentication-and-Authorization" class="headerlink" title="Authentication and Authorization"></a>Authentication and Authorization</h3><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/" target="_blank" rel="noopener">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a></li>
<li><a href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php" target="_blank" rel="noopener">Docker container vs Virtual machine</a></li>
<li><a href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/" target="_blank" rel="noopener">How to Create Docker Container using Dockerfile</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5877964.html" target="_blank" rel="noopener">理解 Docker（2）：Docker 镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html" target="_blank" rel="noopener">为什么要使用 Docker？</a></li>
<li><a href="https://www.docker.com/what-docker" target="_blank" rel="noopener">What is Docker</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">持续集成是什么？</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/hbase-协处理器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/03/10/hbase-协处理器/" class="post-title-link" itemprop="url">hbase 协处理器</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-03-10 17:10:48" itemprop="dateCreated datePublished" datetime="2018-03-10T17:10:48+08:00">2018-03-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 17:24:24" itemprop="dateModified" datetime="2019-10-10T17:24:24+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HBASE-OBSERVER</p>
<h1 id="一、-代码模块："><a href="#一、-代码模块：" class="headerlink" title="一、    代码模块："></a>一、    代码模块：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package cn.com.hbase.observer;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.commons.logging.Log;</span><br><span class="line">import com.sun.org.apache.commons.logging.LogFactory;</span><br><span class="line">import org.apache.hadoop.hbase.Cell;</span><br><span class="line">import org.apache.hadoop.hbase.CellUtil;</span><br><span class="line">import org.apache.hadoop.hbase.CoprocessorEnvironment;</span><br><span class="line">import org.apache.hadoop.hbase.client.Delete;</span><br><span class="line">import org.apache.hadoop.hbase.client.Durability;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.ObserverContext;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;</span><br><span class="line">import org.apache.hadoop.hbase.regionserver.wal.WALEdit;</span><br><span class="line">import org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author greatwall</span><br><span class="line"> * observer协处理器测试</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class MyRegionObserver extends BaseRegionObserver &#123;</span><br><span class="line">    private static final Log LOG = LogFactory.getLog(MyRegionObserver.class);</span><br><span class="line"></span><br><span class="line">    private RegionCoprocessorEnvironment env = null;</span><br><span class="line">    // 设定只有F族下的列才能被操作，且A列只写，B列只读。的语言</span><br><span class="line">    private static final String FAMAILLY_NAME = &quot;F&quot;;</span><br><span class="line">    private static final String ONLY_PUT_COL = &quot;A&quot;;</span><br><span class="line">    private static final String ONLY_READ_COL = &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">    // 协处理器是运行于region中的，每一个region都会加载协处理器</span><br><span class="line">    // 这个方法会在regionserver打开region时候执行（还没有真正打开）</span><br><span class="line">    @Override</span><br><span class="line">    public void start(CoprocessorEnvironment e) throws IOException &#123;</span><br><span class="line">        env = (RegionCoprocessorEnvironment) e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个方法会在regionserver关闭region时候执行（还没有真正关闭）</span><br><span class="line">    @Override</span><br><span class="line">    public void stop(CoprocessorEnvironment e) throws IOException &#123;</span><br><span class="line">        // nothing to do here</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需求 1.不允许插入B列</span><br><span class="line">     *      2.只能插入A列</span><br><span class="line">     *      3.插入的数据必须为整数</span><br><span class="line">     *      4.插入A列的时候自动插入B列</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void prePut(final ObserverContext&lt;RegionCoprocessorEnvironment&gt; e,</span><br><span class="line">                       final Put put, final WALEdit edit, final Durability durability)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 首先查看单个put中是否有对只读列有写操作</span><br><span class="line">                List&lt;Cell&gt; cells = put.get(Bytes.toBytes(FAMAILLY_NAME),</span><br><span class="line">                Bytes.toBytes(ONLY_READ_COL));</span><br><span class="line">        if (cells != null &amp;&amp; cells.size() != 0) &#123;</span><br><span class="line">            LOG.warn(&quot;User is not allowed to write read_only col.&quot;);</span><br><span class="line">            throw new IOException(&quot;User is not allowed to write read_only col.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查A列</span><br><span class="line">        cells = put.get(Bytes.toBytes(FAMAILLY_NAME),</span><br><span class="line">                Bytes.toBytes(ONLY_PUT_COL));</span><br><span class="line">        if (cells == null || cells.size() == 0) &#123;</span><br><span class="line">            // 当不存在对于A列的操作的时候则不做任何的处理，直接放行即可</span><br><span class="line">            LOG.info(&quot;No A col operation, just do it.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当A列存在的情况下在进行值得检查，查看是否插入了整数</span><br><span class="line">        byte[] aValue = null;</span><br><span class="line">        for (Cell cell : cells) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                aValue = CellUtil.cloneValue(cell);</span><br><span class="line">                LOG.warn(&quot;aValue = &quot; + Bytes.toString(aValue));</span><br><span class="line">                Integer.valueOf(Bytes.toString(aValue));</span><br><span class="line">            &#125; catch (Exception e1) &#123;</span><br><span class="line">                LOG.warn(&quot;Can not put un number value to A col.&quot;);</span><br><span class="line">                throw new IOException(&quot;Can not put un number value to A col.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当一切都ok的时候再去构建B列的值，因为按照需求，插入A列的时候需要同时插入B列</span><br><span class="line">        LOG.info(&quot;B col also been put value!&quot;);</span><br><span class="line">        put.addColumn(Bytes.toBytes(FAMAILLY_NAME),</span><br><span class="line">                Bytes.toBytes(ONLY_READ_COL), aValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需求 1.不能删除B列 2.只能删除A列 3.删除A列的时候需要一并删除B列</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void preDelete(</span><br><span class="line">            final ObserverContext&lt;RegionCoprocessorEnvironment&gt; e,</span><br><span class="line">            final Delete delete, final WALEdit edit, final Durability durability)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 首先查看是否对于B列进行了指定删除</span><br><span class="line">        List&lt;Cell&gt; cells = delete.getFamilyCellMap().get(</span><br><span class="line">                Bytes.toBytes(FAMAILLY_NAME));</span><br><span class="line">        if (cells == null || cells.size() == 0) &#123;</span><br><span class="line">            // 如果客户端没有针对于FAMAILLY_NAME列族的操作则不用关心，让其继续操作即可。</span><br><span class="line">            LOG.info(&quot;NO F famally operation ,just do it.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 开始检查F列族内的操作情况</span><br><span class="line">        byte[] qualifierName = null;</span><br><span class="line">        boolean aDeleteFlg = false;</span><br><span class="line">        for (Cell cell : cells) &#123;</span><br><span class="line">            qualifierName = CellUtil.cloneQualifier(cell);</span><br><span class="line"></span><br><span class="line">            // 检查是否对B列进行了删除，这个是不允许的</span><br><span class="line">            if (Arrays.equals(qualifierName, Bytes.toBytes(ONLY_READ_COL))) &#123;</span><br><span class="line">                LOG.info(&quot;Can not delete read only B col.&quot;);</span><br><span class="line">                throw new IOException(&quot;Can not delete read only B col.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 检查是否存在对于A队列的删除</span><br><span class="line">            if (Arrays.equals(qualifierName, Bytes.toBytes(ONLY_PUT_COL))) &#123;</span><br><span class="line">                LOG.info(&quot;there is A col in delete operation!&quot;);</span><br><span class="line">                aDeleteFlg = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果对于A列有删除，则需要对B列也要删除</span><br><span class="line">        if (aDeleteFlg)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG.info(&quot;B col also been deleted!&quot;);</span><br><span class="line">            delete.addColumn(Bytes.toBytes(FAMAILLY_NAME), Bytes.toBytes(ONLY_READ_COL));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、-JAR包上传到HDFS"><a href="#二、-JAR包上传到HDFS" class="headerlink" title="二、    JAR包上传到HDFS"></a>二、    JAR包上传到HDFS</h1><p>hadoop fs -put Hbase-test.jar /user/test_lyq/liu</p>
<p>HBASE操作<br>1.建表：<br>hbase(main):001:0&gt; create ‘coprocessor_table’,’F’<br>0 row(s) in 2.7570 seconds</p>
<p>=&gt; Hbase::Table - coprocessor_table</p>
<p>2.加载协处理器代码：<br>alter ‘coprocessor_table’ , METHOD =&gt;’table_att’,’coprocessor’=&gt;’hdfs://ns1/testdata/Test-HBase-Observer.jar|cn.com.newbee.feng.MyRegionObserver|1001’<br>其中：’coprocessor’=&gt;’jar文件在hdfs上的绝对路径|协处理器主类|优先级|协处理器参数<br>上述协处理器并没有参数，所以未给出参数。</p>
<p>3.检查协处理器是否加载成功：<br>hbase(main):021:0&gt; describe ‘coprocessor_table’<br>Table coprocessor_table is ENABLED<br>coprocessor_table, {TABLE_ATTRIBUTES =&gt; {coprocessor$1 =&gt; ‘hdfs://ns1/testdata/T<br>est-HBase-Observer.jar|cn.com.newbee.feng.MyRegionObserver|1001’}<br>COLUMN FAMILIES DESCRIPTION<br>{NAME =&gt; ‘F’, DATA_BLOCK_ENCODING =&gt; ‘NONE’, BLOOMFILTER =&gt; ‘ROW’, REPLICATION_S<br>COPE =&gt; ‘0’, VERSIONS =&gt; ‘1’, COMPRESSION =&gt; ‘NONE’, MIN_VERSIONS =&gt; ‘0’, TTL =&gt;<br> ‘FOREVER’, KEEP_DELETED_CELLS =&gt; ‘FALSE’, BLOCKSIZE =&gt; ‘65536’, IN_MEMORY =&gt; ‘f<br>alse’, BLOCKCACHE =&gt; ‘true’}<br>1 row(s) in 0.0300 seconds</p>
<h1 id="三、-Hbase操作："><a href="#三、-Hbase操作：" class="headerlink" title="三、    Hbase操作："></a>三、    Hbase操作：</h1><p>1： 正常插入A列<br>复制代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):024:0&gt; scan &apos;coprocessor_table&apos;</span><br><span class="line">ROW                   COLUMN+CELL                                               </span><br><span class="line">0 row(s) in 0.0100 seconds</span><br><span class="line">hbase(main):025:0&gt; put &apos;coprocessor_table&apos;,&apos;row1&apos;,&apos;F:A&apos;,123</span><br><span class="line">0 row(s) in 0.0210 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):026:0&gt; scan &apos;coprocessor_table&apos;</span><br><span class="line">ROW                   COLUMN+CELL                                               </span><br><span class="line"> row1                 column=F:A, timestamp=1469838240645, value=123            </span><br><span class="line"> row1                 column=F:B, timestamp=1469838240645, value=123            </span><br><span class="line">1 row(s) in 0.0180 seconds</span><br></pre></td></tr></table></figure>

<p>结果：B列也被插入，OK</p>
<p>2：插入A列，但是值不为整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):027:0&gt; put &apos;coprocessor_table&apos;,&apos;row1&apos;,&apos;F:A&apos;,&apos;cc&apos;</span><br><span class="line">ERROR: Failed 1 action: IOException: 1 time, </span><br><span class="line">结果：插入失败，服务端报如下错误，OK</span><br><span class="line">2016-07-29 20:25:45,406 WARN  [B.defaultRpcServer.handler=3,queue=0,port=60020] feng.MyRegionObserver: Can not put un number value to A col.</span><br></pre></td></tr></table></figure>

<p>3：插入B列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):028:0&gt; put &apos;coprocessor_table&apos;,&apos;row1&apos;,&apos;F:B&apos;,123</span><br><span class="line">ERROR: Failed 1 action: IOException: 1 time,</span><br><span class="line">结果：插入失败，服务器报如下错误，OK</span><br><span class="line">2016-07-29 20:27:13,342 WARN  [B.defaultRpcServer.handler=20,queue=2,port=60020] feng.MyRegionObserver: User is not allowed to write read_only col.</span><br></pre></td></tr></table></figure>

<p>4：删除B列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):029:0&gt; delete &apos;coprocessor_table&apos;,&apos;row1&apos;,&apos;F:B&apos;</span><br><span class="line">ERROR: java.io.IOException: Can not delete read only B col.</span><br></pre></td></tr></table></figure>

<p>结果：删除失败，OK</p>
<p>5：删除A列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):030:0&gt; scan &apos;coprocessor_table&apos;</span><br><span class="line">ROW                   COLUMN+CELL                                                </span><br><span class="line"> row1                 column=F:A, timestamp=1469838240645, value=123             </span><br><span class="line"> row1                 column=F:B, timestamp=1469838240645, value=123             </span><br><span class="line">1 row(s) in 0.0230 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):031:0&gt; delete &apos;coprocessor_table&apos;,&apos;row1&apos;,&apos;F:A&apos;</span><br><span class="line">0 row(s) in 0.0060 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):032:0&gt; scan &apos;coprocessor_table&apos;</span><br><span class="line">ROW                   COLUMN+CELL                                                </span><br><span class="line">0 row(s) in 0.0070 seconds</span><br></pre></td></tr></table></figure>

<p>结果：A列和B列同时被删除了。</p>
<h2 id="kafka-tips"><a href="#kafka-tips" class="headerlink" title="kafka tips:"></a>kafka tips:</h2><p>Kafka:如何保障发送时数据不丢失 1. 需要设置几个关键的参数，如下:</p>
<h3 id="unclean-leader-election-enable-false"><a href="#unclean-leader-election-enable-false" class="headerlink" title="unclean.leader.election.enable=false"></a>unclean.leader.election.enable=false</h3><ul>
<li>在哪里设置:(broker / topic)</li>
<li>默认值: true (在 Kafka 0.11.0.0 中默认值已更改为 false ) </li>
<li>有效值:[true, false]<h3 id="在哪里设置"><a href="#在哪里设置" class="headerlink" title="在哪里设置:"></a>在哪里设置:</h3></li>
<li>(broker / topic) 默认值:1</li>
<li>有效值:[1, …]</li>
<li>acks=all<br>在哪里设置:producer 默认值:1 有效值:[all, ‐1, 0, 1]<br>必须设置以上所有参数，这样在调用 get() 返回发送结果时，无异常则可认为消息已成功写入 Kafka，无丢失。<br>producer.send(new ProducerRecord(topic, key, value)).get();</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p> 我们首先考虑在使用上述参数默认值的情况下，消息为什么会丢失。</p>
<ul>
<li>unclean.leader.election.enable=true</li>
<li>min.insync.replicas=1</li>
<li>acks=1</li>
</ul>
<p>设置 1 表示当该分区所有副本代理都下线的情况下，Kafka 会选第一个上线的代理作为 leader，而不管<br>它下线之前是不是在 ISR[1] 中，那么如果这个新 leader 下线之前并不是 leader 或者不在 ISR 中，有一部 分消息便丢失了。</p>
<ul>
<li>设置 2 和 设置 3 共同作用。即生产时，只要 leader 确认消息已收到，即认为该消息已成功写入 Kafka。 因为需要 leader 确认同时满足最小同步副本数为 1 的设置。<br>如果我们把设置 3 更改为 acks=all ，消息仍然有可能丢失。</li>
<li>一方面是设置 1 的影响，另一方面，更改后的设置 3 要求生产时，需要得到该分区所有在线副本代理 的确认，这里重点是只要在线，如果该分区当时只有 leader 在线，也满足设置 2，那么就会认为消息已 成功写入 Kafka。<br>所以我们需要在上一步的基础上把设置 1 禁用，设置 2 更改为 min.insync.replicas=副本数‐1 ，这 样便达到了消息发送成功的最强保障。<br>禁用设置 1 ，Kafka 会在该分区所有副本代理都下线的情况下，从 ISR 中选择第一个上线的代理作为 leader。更改后的设置 2 和设置 3 共同作用，要求生产时，需要得到该分区所有在线副本代理的确认，并且确 认数要大于等于(副本数‐1)，这样就保证了每次生产，有绝大多数副本代理确认收到消息后才认为消 息已成功写入 Kafka。这样如果在非常情况下进行 leader 选举，Kafka 既能很快恢复，也保障了数据不 丢失。 已同步的副本集。即该分区当前活着并且已跟上 leader 的副本们。 ↩</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/09/浅谈云计算服务模型关键技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/09/浅谈云计算服务模型关键技术/" class="post-title-link" itemprop="url">浅谈云计算服务模型关键技术</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-08-09 16:58:12" itemprop="dateCreated datePublished" datetime="2017-08-09T16:58:12+08:00">2017-08-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-09 17:31:38" itemprop="dateModified" datetime="2019-10-09T17:31:38+08:00">2019-10-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浅谈云计算服务模型关键技术"><a href="#浅谈云计算服务模型关键技术" class="headerlink" title="浅谈云计算服务模型关键技术"></a>浅谈云计算服务模型关键技术</h1><hr>
<ul>
<li>摘要：</li>
</ul>
<p>随着科技水平的不断提高，企业信息化成为企业发展和前进的巨大推动力。然而，传统的企业IT架构存在信息化成本过高以及原有技术基础架构可扩展性低等问题。这些问题逐渐成为企业提高竞争力的瓶颈。定制全新的、模块化的企业应用系统可以在一定程度解决现有问题，但是，由于新旧应用系统在功能上并无太大差异，因此仅仅为了革新软件架构而采购全新应用系统往往成本太高。了降低企业信息化成本、提升企业竞争力，云计算作为一种全新的商业计算模式应运而生。它以高可靠性、高扩展性、低成本等特点吸引了多家企业使用网络云服务来满足自身信息化需求。但是采用网络云服务仍然有以下问题：</p>
<p>1）网络云服务针对性不高，无法满足企业特色需求。</p>
<p>2）无法保留企业原有硬件、软件的投入成本。</p>
<p>3）企业数据存储在“云”端会带来安全风险。</p>
<p>4）云计算对企业过于透明。</p>
<hr>
<h3 id="课题背景"><a href="#课题背景" class="headerlink" title="课题背景"></a>课题背景</h3><p>企业的信息技术发展可以分为基础应用、关键应用、扩展整合与战略应用四个阶段。</p>
<ul>
<li>基础应用仅仅为企业提供日常工作的简单支持，如签到系统、官方网页等；关键应用通常涉及企业核心业务，可以较高提高企业效益；第三阶段则是将基础应用和关键应用整合与扩展。战略应用则是从企业发展战略高度优化升级系统、整合数据服务于高层决策。这四个阶段层层递进，每个阶段都是上一阶段信息化的进步，但这四个阶段发展阶段性差异明显，阶段性问题较为突出，如何减少差异，整合有效资源，实现企业信息化平稳发展，也成为当前企业的一个突出问题。</li>
<li>云计算的出现则在一定程度上解决了这个难题。云计算是一种全新的商业计算模式它是在网格计算、分布式计算和并行计算的基础上发展整合起来的。</li>
<li>云计算的原理是通过计算资源池的方式为用户提供计算、存储等资源。借助于云计算，企业用户可以享受更加方便、更加高效、更加廉价的服务。一方面云计算按需付费的特征可以将企业高额的一次性信息化投入，比如ERP</li>
<li>软件购买和服务器购买，转变为小额的运营费用支出，这样就可以有效的降低了企业的信息化成本；另一方面，云计算高弹性、高可扩展性的特征可以使得企业的IT架构更为灵活，从而可以轻易的应对IT服务需求变化的情况。</li>
</ul>
<hr>
<h3 id="国内外研究现状"><a href="#国内外研究现状" class="headerlink" title="国内外研究现状"></a>国内外研究现状</h3><ul>
<li>应用系统云化决策支持</li>
<li>在应用系统云计算化前期，企业需要考虑经济、风险、安全，合法性和其他非技术类因素。如果这些先决条件没有满足，IaaS层将很难云化。主要关注云迁移方面的决策支持，<br>Sattaluri阐述了各种情况下应用系统IaaS层云化的需要，Yunus研究了应用系统云化的风险和消耗，Mossburg则从整体角度上提出了应用系统云化的4个关键点。 </li>
<li>应用系统角度云化</li>
<li>在应用系统角度上，研究者主要通过对应用系统功能、架构的分析，在根据其普遍功能架构特点的基础上提出了多种应用系统云化方法，Binz把云化方法主要分为两类：应用系统功能模块云化，应用系统整体云化。功能模块云化是把应用系统中的部分功能模块迁移部署到云端。整体云化是把整个应用系统中的所有功能模块分别迁移到云端，从而实现应用系统整体云化方案。对于应用整体云化策略，该文提出的一种云化框架可以利用现有应用系统模型并对复杂应用迁移提供支持。<br>定义了四种应用系统角度云化方法。第一种方法是通过已有的云服务，比如云监控、云存储等服务，替换应用系统现有的服务。第二种方法是把应用的部分功能迁移到云环境中。最常见的方法是把整栈应用迁移到云端。最后一种方法企业需要把原有的数据和商业逻辑全部迁移到云端。</li>
<li>云计算角度云化</li>
<li><h2 id="与应用系统角度相反，在云计算角度上，研究者主要关注的是云计算的特性，以及如何借助这些特性打造云时代的应用系统。Gartner提出了企业IT应用利用云计算的五种建议，这些建议分别是将应用系统完全部署到云端、基于IaaS平台改造应用系统、基于PaaS平台改造应用系统、基于PaaS平台重构应用系统、通过SaaS软件替换企业现有的应用系统。-思科公司在它发布的白皮书中认为，企业只需要根据SaaS、PaaS、IaaS三种模式的特点就可以开展传统应用系统云化工作。它认为SaaS层的云化可以确切地定义未应用系统的替换，即企业放弃现有应用系统，在将数据导入SaaS平台后，完全使用SaaS平台软件工作。对于基于Java-EE和-NET的商业应用来说，PaaS层服务模型下的云化也是一个很好的选择。IaaS层云化策略通常只涉及到应用系统在IaaS云平台的部署。-与思科看待应用系统云计算化的方式相同，Solentive公司同样把云化定义为IaaS、PaaS、SaaS三种方式，他们公司的白皮书详细地分析了这三种方式的优缺点。在IaaS、PaaS层上的云化策略与思科等公司基本一致，但他们把SaaS层的云化策略进一步分为了三种子策略：应用系统完全替换、应用系统部分替换、应用系统改造。"><a href="#与应用系统角度相反，在云计算角度上，研究者主要关注的是云计算的特性，以及如何借助这些特性打造云时代的应用系统。Gartner提出了企业IT应用利用云计算的五种建议，这些建议分别是将应用系统完全部署到云端、基于IaaS平台改造应用系统、基于PaaS平台改造应用系统、基于PaaS平台重构应用系统、通过SaaS软件替换企业现有的应用系统。-思科公司在它发布的白皮书中认为，企业只需要根据SaaS、PaaS、IaaS三种模式的特点就可以开展传统应用系统云化工作。它认为SaaS层的云化可以确切地定义未应用系统的替换，即企业放弃现有应用系统，在将数据导入SaaS平台后，完全使用SaaS平台软件工作。对于基于Java-EE和-NET的商业应用来说，PaaS层服务模型下的云化也是一个很好的选择。IaaS层云化策略通常只涉及到应用系统在IaaS云平台的部署。-与思科看待应用系统云计算化的方式相同，Solentive公司同样把云化定义为IaaS、PaaS、SaaS三种方式，他们公司的白皮书详细地分析了这三种方式的优缺点。在IaaS、PaaS层上的云化策略与思科等公司基本一致，但他们把SaaS层的云化策略进一步分为了三种子策略：应用系统完全替换、应用系统部分替换、应用系统改造。" class="headerlink" title="与应用系统角度相反，在云计算角度上，研究者主要关注的是云计算的特性，以及如何借助这些特性打造云时代的应用系统。Gartner提出了企业IT应用利用云计算的五种建议，这些建议分别是将应用系统完全部署到云端、基于IaaS平台改造应用系统、基于PaaS平台改造应用系统、基于PaaS平台重构应用系统、通过SaaS软件替换企业现有的应用系统。 思科公司在它发布的白皮书中认为，企业只需要根据SaaS、PaaS、IaaS三种模式的特点就可以开展传统应用系统云化工作。它认为SaaS层的云化可以确切地定义未应用系统的替换，即企业放弃现有应用系统，在将数据导入SaaS平台后，完全使用SaaS平台软件工作。对于基于Java EE和.NET的商业应用来说，PaaS层服务模型下的云化也是一个很好的选择。IaaS层云化策略通常只涉及到应用系统在IaaS云平台的部署。 与思科看待应用系统云计算化的方式相同，Solentive公司同样把云化定义为IaaS、PaaS、SaaS三种方式，他们公司的白皮书详细地分析了这三种方式的优缺点。在IaaS、PaaS层上的云化策略与思科等公司基本一致，但他们把SaaS层的云化策略进一步分为了三种子策略：应用系统完全替换、应用系统部分替换、应用系统改造。"></a>与应用系统角度相反，在云计算角度上，研究者主要关注的是云计算的特性，以及如何借助这些特性打造云时代的应用系统。Gartner提出了企业IT应用利用云计算的五种建议，这些建议分别是将应用系统完全部署到云端、基于IaaS平台改造应用系统、基于PaaS平台改造应用系统、基于PaaS平台重构应用系统、通过SaaS软件替换企业现有的应用系统。 思科公司在它发布的白皮书中认为，企业只需要根据SaaS、PaaS、IaaS三种模式的特点就可以开展传统应用系统云化工作。它认为SaaS层的云化可以确切地定义未应用系统的替换，即企业放弃现有应用系统，在将数据导入SaaS平台后，完全使用SaaS平台软件工作。对于基于Java EE和.NET的商业应用来说，PaaS层服务模型下的云化也是一个很好的选择。IaaS层云化策略通常只涉及到应用系统在IaaS云平台的部署。 与思科看待应用系统云计算化的方式相同，Solentive公司同样把云化定义为IaaS、PaaS、SaaS三种方式，他们公司的白皮书详细地分析了这三种方式的优缺点。在IaaS、PaaS层上的云化策略与思科等公司基本一致，但他们把SaaS层的云化策略进一步分为了三种子策略：应用系统完全替换、应用系统部分替换、应用系统改造。</h2></li>
</ul>
<h3 id="云计算服务模型"><a href="#云计算服务模型" class="headerlink" title="云计算服务模型"></a>云计算服务模型</h3><ul>
<li><p>IaaS层服务模型关键技术</p>
</li>
<li><p>基础设施即服务（IaaS）是云计算中最基础的服务模型，它将服务器中的硬件设备整合成一个虚拟的资源池供用户申请使用。在该服务模型下，用户通过网络便可获取包括存储和计算在内的各种资源。<br>本文涉及的IaaS关键技术主要包括虚拟化技术、虚拟机迁移技术和分布式块存储技术。</p>
</li>
<li><p>虚拟化技术</p>
</li>
<li><p>云计算中的虚拟化是指通过虚拟化技术重新组织原有的物理资源。用户在使用云计算提供的资源和服务时，完全不需要关注提供服务的原理和内部细节，他们只需要一个可联网的应用终端就可以在任意位置获取云计算所提供的服务。资源在虚拟化之后被云平台统一组织和管理，用户使用其中资源时的体验与使用本地计算机基本一致。<br>虚拟化技术对于提高服务稳定性也很重要。Linux内核占据了操作系统唯一的地址空间，这意味着内核或任何驱动程序的故障都会导致整个操作系统的崩溃，从而影响操作系统上的其他应用。借助于虚拟化技术，用户可以运行多个操作系统，每个操作系统都有自己的地址空间，其中一个系统发生故障导致崩溃后，不会影响运行在其他操作系统上的应用。<br>虚拟化技术还可以提高系统资源利用率，在一台物理服务器上虚拟出多台虚拟机后，每个虚拟机可以承载一个应用的运行，在应用隔离的前提下，增加了资源利用率。而且，这种方式也可以节约电力、空间、制冷等成本。</p>
</li>
<li><p>虚拟机迁移技术</p>
</li>
<li><p>虚拟机迁移技术是IaaS层服务模型中的核心技术之一，简单点来说，就是对一个虚拟机进行内存复制，然后把该虚拟机从源物理机迁移到目标物理机上运行。<br>在迁移过程中，虚拟机内存状态被不间断地从源物理机迁移到目标物理机，在迁移完成前，虚拟机仍然在源物理机上保持正常运行状态。当最后一部分内存页面被拷贝到目标物理机后，源物理机上的虚拟机将终止运行，目标物理机上的虚拟机将开始运行，至此，整个虚拟机迁移过程完成。<br>在虚拟机文件系统中，需要用到大量的数据，假如要实现文件系统迁移，将耗费非常多的时间。由于共享文件系统既能被源物理机又能被目标物理机访问，这样就可以避免传输大数据量的虚拟机文件，提高虚拟机的迁移效率。因此，很多虚拟化软件都采用共享的网络文件系统来存储虚拟机文件。</p>
</li>
<li><p>分布式块存储技术 </p>
</li>
<li><p>云计算环境下的数据通常有多个备份，被分别存储在一个数据中心的不同节点上，甚至跨数据中心存储。数据的位置和组织方式是由已定义的云计算存储机制管理，对用户来讲是透明的。用户通常只需要通过服务商提供的数据接口向数据中心存取数据即可。云计算将用户从数据中心的构建和管理中解放出来，减轻了用户负担，降低了用户成本。他们只需要根据自身所使用的资源支付相应的费用，就能够方便地把数据存储到数据中心上。<br>分布式存储技术是云计算的基础，主要研究如何存储、组织和管理数据中心上的大规模海量数据。它在可扩展性、容错性等方面都拥有很大优势。<br>分布式块存储是分布式存储中的一种类型，它将不同的块设备整合，提供了弹性扩展能力和容错等特性。<br>块设备是一种具有一定结构的随机存取设备，它将信息存储在固定大小的块中。因此需要按块读写该设备，每个块都有自己的地址，在缓冲区中存放中间状态数据，满足一定条件后，从缓存一次性写入设备或从设备中一次性读出放入到缓冲区，磁盘是最常见的块设备。</p>
</li>
<li><p>PaaS层服务模型关键技术<br>相对于IaaS层，PaaS层中增加了更多软件层面的考量。因此包含的技术种类更加繁杂，本文主要涉及到以下几种技术： </p>
</li>
<li><p>REST机制 </p>
</li>
<li><p>该机制即为表述性状态转移技术。它并不是一种技术标准而是一种设计风格。REST通常基于HTTP，URI和XML以及HTML这些现有的广泛流行的协议和标准[28]。 基于REST的HTTP设计通常具备以下原则：资源是由URI来指定；HTTP协议提供的GET、POST、PUT和DELETE方法对应着资源获取、资源创建、资源修改和资源删除动作；通过操作资源的表现形式来操作资源；资源的表现形式取决于读者。在机器与人之间、消费web服务的客户软件与web浏览器之间，表现形式各不相同。 在PaaS平台中，由于该机制提供了统一接口，从而避免了多个能力组件由于大量接口而导致的不兼容。采用REST技术可以很方便的将这些能力提供给开发者使用。由于REST是无状态的，所以会话状态信息不需要云平台维护，从而使应用服务器的负载大大减轻，提高了系统性能。</p>
</li>
<li><p>负载均衡技术 </p>
</li>
<li><p>负载均衡技术主要用在分布式系统中来提高服务器集群的整体性能。由于集群中服务器性能有差异或者并发访问量过大，会导致某些服务器负载过重而另一些负载过轻的现象，这就需要负载均衡技术来进行调节，提高每个节点的利用率从而减少请求响应时间。<br>从理论上来讲，负载均衡包含两个方面。一个方面是将负载划分成多个无联系可独立执行的部分，并将这些部分分别发送到多个服务器节点上进行处理，每个服务器节点只负责处理本节点获取到的那一部分，而不用关心其他部分。每个节点处理结束之后，将自己的处理结果返回给代理节点，代理节点把所有返回结果综合后返回给客户端[46]。这种并行处理方式可以大大减少一些服务器承载大量运算任务而另外一些服务器出现闲置情况的概率，从而很大程度提高集群的处理能力。<br>另一方面，负载均衡能将海量的用户的并发请求采用某种策略合理透明地分摊到多个处理结点上，使各结点承受相对应其性能的负载量，从而避免出现服务器资源使用上的不平衡，在整体上缩短请求的平均响应时间，达到服务资源优化配置的目标。对于Web服务器、FTP服务器和其它关键应用服务器来说，负载均衡是保证它们正常运行、减少用户等待时间的一项必不可少的措施。单一服务器的处理能力有限，并且可靠性和扩展性都比较差，集群与负载均衡技术可以使这两方面得到改善。 </p>
</li>
<li><p>在负载均衡层面上，负载均衡策略至关重要，负载策略是保证集群达到负载平衡的关键所在，根据负载调节策略的不同，负载均衡可划分为静态负载均衡和动态负载均衡两类。</p>
</li>
<li><p>轮询策略</p>
</li>
<li><p>轮询策略是所有负载均衡策略中实现最简单的一种策略。该策略的核心思想是釆用轮询的方式，将服务请求按照时间顺序依次调度的不同的服务器上，假设Web集群有n台服务器，每次调度到的服务器i=（G+l）mod n台，依次进行循环选择。 </p>
</li>
<li><p>加权轮询策略<br>加权轮询策略的核心是对不同处理能力的服务器分配不同的权值，资源调度的时候只需要给服务器分配相应权值数量的服务请求便可。 </p>
</li>
<li><p>最小链接策略<br>最小链接策略是一种动态调度算法，该策略核心是实时记录每个服务器当前活跃的连接数量，以此数量来预估服务器的负载情况，然后把连接数量最小的服务器分配给当前用户的连接请求。</p>
</li>
<li><p>动态反馈负载均衡策略<br>动态反馈负载均衡策略是通过对每个服务器性能进行监控，通过所得到的监控信息控制新连接的分配，从而控制各个服务器的负载。 </p>
</li>
<li><p>Web服务 </p>
</li>
<li><p>Web服务是面向服务的体系结构（SOA）背后的关键性支持技术之一，它具有自包含、自描述以及模块化应用等特点，可以在Web上发布、被发现与被使用。在面向服务的体系结构中有3个基本的角色：服务提供商、服务代理商、服务请求者。角色之间有三个基本操作：服务的发布、服务的查找和绑定，服务的调用。<br><a href="https://reonyu.github.io/images/Pic2.png" target="_blank" rel="noopener">picture</a></p>
</li>
<li><p>服务的创建、发布、维护由服务提供商实现，服务代理商维护着整个Web服务列表，并自建索引加快服务查询速度，同时它还负责对事务进行监控、对服务安全进行映射以及实现路由等多项工作。服务请求者是互联网上需要通过Web服务进行自身业务处理或请求调用的用户，他们主要提交需求，在服务代理商维护的Web服务列表中发现自身所需服务，然后绑定和调用服务提供商所提供的服务。</p>
</li>
<li><p>服务等级协议SLA </p>
</li>
<li><p>该协议是租用服务的用户与服务提供商所签订的使用协议，该协议规定了服务类型，服务质量以及服务费用等内容。基于该协议，服务供应商首先需要满足用户的最低要求条款，比如，最小带宽，服务响应最长时间。在满足以上条件下，服务提供商可以对用户资源使用等方面进行限制，防止用户资源无节制的占据大量资源。 基于云计算的SLA还没有一个统一标准[36]。在云计算出现以前，通常网络服务提供商和用户会根据服务内容来协商，因为通过物联网来访问或者说享用云计算服务，网络延迟，丢包，或者传输失败率等问题是动态变化的，而且云计算服务提供商通常不享有专有的ISP，而且很多时候应用性能所受到的影响不属于云计算的范畴，云计算通常只是提供第三方应用。 </p>
</li>
<li><p>本文主要介绍云计算IaaS、PaaS层服务模型的关键技术及各个技术之间的不同。</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leon</p>
  <div class="site-description" itemprop="description">挪威的森林</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ReonYu" title="GitHub &rarr; https://github.com/ReonYu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leon</span>
</div>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div>

        












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>

  <script defer src="/lib/three/three.min.js"></script>
    
    <script defer src="/lib/three/three-waves.min.js"></script>
  


  





















  

  

  

</body>
</html>
