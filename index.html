<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=7.4.1">
  <link rel="mask-icon" href="/images/avatar.png?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="挪威的森林">
<meta name="keywords" content="路漫漫其修远兮，吾将上下而求索">
<meta property="og:type" content="website">
<meta property="og:title" content="Leon">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Leon">
<meta property="og:description" content="挪威的森林">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leon">
<meta name="twitter:description" content="挪威的森林">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Leon</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Live for Real</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-commonweal">
      
    

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeats"></i>Commonweal 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/个人简历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/06/14/个人简历/" class="post-title-link" itemprop="url">个人简历</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-06-14 16:35:18" itemprop="dateCreated datePublished" datetime="2019-06-14T16:35:18+08:00">2019-06-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 16:36:26" itemprop="dateModified" datetime="2019-10-10T16:36:26+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul>
<li>喻~/男/1993</li>
<li>本科/西安邮电大学电子信息工程系</li>
<li>工作年限：2年3个月</li>
<li>技术博客：<a href="https://reonyu.github.io" target="_blank" rel="noopener">https://reonyu.github.io</a></li>
<li>Github：<a href="https://github.com/ReonYu" target="_blank" rel="noopener">https://github.com/ReonYu</a></li>
<li>期望薪资：税前月薪15k~20k</li>
<li>所在城市：北京</li>
</ul>
<h3 id="工作-实践经历"><a href="#工作-实践经历" class="headerlink" title="工作 + 实践经历"></a>工作 + 实践经历</h3><ul>
<li>北京东方国信科技股份公司(大数据研发) (2017.7 ~ Now )</li>
<li>2017.1 - 2017.6 东方国信（北京）-云计算部(实习)</li>
<li>2016.9 - 2016.12 神州数码（西安）-技术研发部(实习)</li>
</ul>
<h3 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h3><ul>
<li>项目管理: Svn、Maven、Git、JIRA、Confluence</li>
<li>设计语言: Java、Shell、SQL</li>
<li>应用框架: Spring、Flink、Hadoop、Kafka、Spark、JPA、Zookeeper、Dobbo、Netty</li>
<li>部署测试: Docker、Xcode、GitHub、Jenkins、Sonar</li>
</ul>
<h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><ul>
<li>1 目前工作主要涉及后端应用开发及大数据应用，有大数据企业级应用开发经验，参与过运营商大数据平台建设；</li>
<li>2 熟悉系统对接流程，有分布式系统开发经验；</li>
<li>3 追求高质量代码，有源码阅读经验；</li>
</ul>
<h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><ul>
<li>手机：18829288613 </li>
<li>Email：<a href="mailto:yxy013@163.com" target="_blank" rel="noopener">yxy013@163.com</a> </li>
<li>QQ：43286734</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="流服务应用平台-2019-07-2019-10"><a href="#流服务应用平台-2019-07-2019-10" class="headerlink" title="流服务应用平台(2019/07-2019/10)"></a>流服务应用平台(2019/07-2019/10)</h3><ul>
<li>项目描述:</li>
</ul>
<p>该项目基于B/S前后端分离架构,打造以电信运营商海量数据为基础,针对丰富的数据来源,打造以数流为载体,多租户的数据共享平台.主要功能包括数据源注册,数据服务定义,流服务产品发布,订阅,流程审批,数据源管理等.</p>
<ul>
<li>实现技术:</li>
</ul>
<p>Flink + Kafka + Flume + SpringBoot + MyBatis + Mysql + Redis</p>
<ul>
<li>职责描述:</li>
</ul>
<p>作为两位核心开发之一,主要负责参与需求分析与后台开发,同时负责需求整理与项目推进.主要负责资源管理,服务编排及服务发布订阅模块的开发设计.</p>
<h3 id="云化ETL-2018-08-2019-06"><a href="#云化ETL-2018-08-2019-06" class="headerlink" title="云化ETL(2018/08-2019/06)"></a>云化ETL(2018/08-2019/06)</h3><ul>
<li>项目描述:</li>
</ul>
<p>该项目采用基于B/S的前后端分离架构,提供平台式的可视化数据管理,支持多源、异构数据采集迁移,分布式执行,任务监控预警.以数据的采集、管理为核心，提供可视化、线上配置、自动执行的大数据采集交换平台.支持常用数据源包括oracle、mysql、ftp、hdfs、cirroData、hbase、hive、redis等.</p>
<ul>
<li><p>实现技术:</p>
</li>
<li><p>SpringBoot + MyBatis + Dubbo + ActiveMQ + Redis + MySQL + Shell + Sqoop + Sqlldr + Hadoop</p>
</li>
<li><p>职责描述:</p>
</li>
</ul>
<p>1、独立负责任务定义及调度模块的开发设计工作;<br>2、负责执行代理的开发设计工作;</p>
<h3 id="能力开放平台-2017-10-2018-07"><a href="#能力开放平台-2017-10-2018-07" class="headerlink" title="能力开放平台(2017/10-2018/07)"></a>能力开放平台(2017/10-2018/07)</h3><ul>
<li><p>项目描述:</p>
<p>该项目是依托联通数据中心超大规模计算资源、存储资源及海量数据处理能力，结合特定的业务场景，构建出的一个数据域的企业级云平台.平台包括多租户,安全管理,流程审批,能力管理,云化ETL,数据平台等.项目采用B/S分离架构,后端包括多套微服务系统.</p>
</li>
<li><p>实现技术:</p>
<p>Mysql + SpringMVC + Docker + Feign + Shiro</p>
</li>
<li><p>职责描述:</p>
</li>
</ul>
<p>1、负责对接集成后端工单审批系统,应用Feign+ Rest 完成;<br>2、借助jsch框架,完成大数据组件自动化部署功能;</p>
<h3 id="互联网日志采集-2017-01-2017-09"><a href="#互联网日志采集-2017-01-2017-09" class="headerlink" title="互联网日志采集(2017/01-2017/09)"></a>互联网日志采集(2017/01-2017/09)</h3><ul>
<li><p>项目描述:</p>
<p>该项目主要由互联网日志生产（日志生产），解析（规则库建设），实例库（爬虫，处理），实时引擎（实时解析，场景化营销）四部分组成,各种数据通过各系统解析后即沉淀为信息库,支撑上游需求。</p>
</li>
<li><p>相关技术:</p>
<p>SQL  + ELK + Kafka + Hadoop + Hive + HBase + Mysql</p>
</li>
<li><p>职责描述:</p>
</li>
</ul>
<p>1、负责数据迁移,互联网地址标签梳理,搭建结合爬虫与ELK爬虫的数据可视化;<br>2、编写了Kafka Stream 接入Kafka数据,对对应数据清洗，格式转换，字段提取，与动态更新码表匹配规则，号码数据统计并更新（峰值处理600W每天）;</p>
<h3 id="演讲和讲义"><a href="#演讲和讲义" class="headerlink" title="演讲和讲义"></a>演讲和讲义</h3><ul>
<li>9月公司内部分享：<a href="https://reonyu.github.io/2017/08/09/%E6%B5%85%E8%B0%88%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/" target="_blank" rel="noopener">云计算纵览</a><ul>
<li>小组技术分析：<a href="https://reonyu.github.io/2018/05/10/docker/" target="_blank" rel="noopener">docker</a></li>
</ul>
</li>
</ul>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/10/浅尝Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/02/10/浅尝Spring/" class="post-title-link" itemprop="url">浅尝Spring</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-02-10 12:59:34" itemprop="dateCreated datePublished" datetime="2019-02-10T12:59:34+08:00">2019-02-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-10 13:04:59" itemprop="dateModified" datetime="2019-10-10T13:04:59+08:00">2019-10-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。</p>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><ul>
<li><strong>轻量级</strong>：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。</li>
<li><strong>控制反转(IOC)</strong>：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</li>
<li><strong>面向切面编程(AOP)</strong>： Spring支持面向切面编程，同时把应用的<strong>业务逻辑与系统的服务分离开来</strong>。</li>
<li><strong>容器</strong>：Spring包含并管理应用程序对象的配置及生命周期。</li>
<li><strong>MVC框架</strong>：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。</li>
<li><strong>事务管理</strong>：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。</li>
<li><strong>异常处理</strong>：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</li>
</ul>
<h2 id="Spring框架有哪些模块"><a href="#Spring框架有哪些模块" class="headerlink" title="Spring框架有哪些模块"></a>Spring框架有哪些模块</h2><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成、Web、AOP（面向切面编程）、测试模块。<br><img src="/assets/spring.png" alt></p>
<ul>
<li><strong>核心容器模块</strong>：是spring中最核心的模块。负责Bean的创建、配置和管理。主要包括：beans,core,context,expression等模块。</li>
<li><strong>Spring的AOP模块</strong>：主要负责对面向切面编程的支持，帮助应用对象解耦。</li>
<li><strong>数据访问和集成模块</strong>：包括JDBC，ORM，OXM，JMS和事务处理模块，其细节如下：<ul>
<li>JDBC模块提供了不再需要冗长的JDBC编码相关了JDBC的抽象层。</li>
<li>ORM（Object Relational Mapping，对象关系映射）模块提供的集成层。流行的对象关系映射API，包括JPA，JDO，Hibernate和iBatis。</li>
<li>OXM模块提供了一个支持对象/ XML映射实现对JAXB，Castor，使用XMLBeans，JiBX和XStream 的抽象层。</li>
<li>Java消息服务JMS模块包含的功能为生产和消费的信息。</li>
<li>事务模块支持编程和声明式事务管理实现特殊接口类，并为所有的POJO。</li>
</ul>
</li>
<li><strong>Web和远程调用</strong>：包括web,servlet,struts,portlet模块。</li>
<li><strong>测试模块</strong>：test</li>
</ul>
<h2 id="什么是控制反转-IOC-？什么是依赖注入？"><a href="#什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IOC)？什么是依赖注入？"></a>什么是控制反转(IOC)？什么是依赖注入？</h2><p>传统模式中对象的调用者需要创建被调用对象，两个对象过于耦合，不利于变化和拓展．在spring中，直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理，从而实现对象之间的松耦合。<strong>所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器</strong>。</p>
<p><strong>依赖注入</strong>：对象无需自行创建或管理它们的依赖关系，IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。依赖注入能让相互协作的软件组件保持松散耦合。</p>
<h2 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h2><ul>
<li>Bean工厂(BeanFactory)是Spring框架最核心的接口，提供了高级IOC的配置机制．</li>
<li>应用上下文(ApplicationContext)建立在BeanFacotry基础之上，提供了更多面向应用的功能，如果国际化，属性编辑器，事件等等．</li>
<li>beanFactory是spring框架的基础设施，是面向spring本身。ApplicationContext是面向使用Spring框架的开发者，几乎所有场合都会用到ApplicationContext.</li>
</ul>
<h2 id="Spring有几种配置方式？"><a href="#Spring有几种配置方式？" class="headerlink" title="Spring有几种配置方式？"></a>Spring有几种配置方式？</h2><p>将Spring配置到应用开发中有以下三种方式：</p>
<ul>
<li><strong>基于XML的配置</strong>:</li>
<li><strong>基于注解的配置</strong>： Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果</li>
<li><strong>基于Java的配置</strong>： Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean> 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。</bean></li>
</ul>
<h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p><img src="/assets/beans.png" alt></p>
<p>Bean在Spring中的生命周期如下：</p>
<ul>
<li><strong>实例化</strong>：Spring通过new关键字将一个Bean进行实例化。</li>
<li><strong>填入属性</strong>：spring将值和bean引用注入到bean 的属性中。</li>
<li>如果Bean实现了<strong>BeanNameAware</strong>接口，工厂调用Bean的<strong>setBeanName()</strong>方法传递Bean的ID。</li>
<li>如果Bean实现了<strong>BeanFactoryAware</strong>接口，工厂调用<strong>setBeanFactory()</strong>方法传入工厂自身。</li>
<li>如果实现了<strong>ApplicationContextAware</strong>, spring将调用setApplicationContext()方法，将bean所在的上下文的引用 进来。</li>
<li>如果<strong>BeanPostProcessor</strong>和Bean关联，那么它们的<strong>postProcessBeforeInitialization()</strong>方法将被调用。</li>
<li>如果Bean指定了init-method方法，它将被调用。</li>
<li>如果有<strong>BeanPostProcessor</strong>和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用</li>
<li>最后如果配置了destroy-method方法则注册<strong>DisposableBean</strong>.</li>
</ul>
<p><strong>使用：</strong>到这个时候，Bean已经可以被应用系统使用了，并且将被保留在Bean Factory中知道它不再需要。</p>
<p><strong>销毁</strong>。如果Bean实现了DisposableBean接口，就调用其destroy方法。有两种方法可以把它从Bean Factory中删除掉：</p>
<ol>
<li>如果Bean实现了DisposableBean接口，destory()方法被调用。</li>
<li>如果指定了订制的销毁方法，就调用这个方法。destory-method（）配置时指定。</li>
</ol>
<p>对几个重要接口的解释：</p>
<ul>
<li><strong>BeanNameAware</strong>: 实现该接口可以获得本身bean的id属性，获得在配置文件中定义好的Bean的ID名</li>
<li><strong>BeanFactoryAware</strong>：实现这个接口的bean其实是希望知道自己属于哪一个BeanFactory, 是哪个BeanFactory创建的。</li>
<li><strong>ApplicationContextAware</strong>：当一个类实现了这个接口之后，这个类就可以方便地获得 ApplicationContext 中的所有bean。换句话说，就是这个类可以直接获取Spring配置文件中，所有有引用到的bean对象。</li>
<li><strong>BeanPostProcessor</strong>是Spring中定义的一个接口，其与InitializingBean和DisposableBean接口类似，也是供Spring进行回调的。Spring将在初始化bean前后对BeanPostProcessor实现类进行回调，Spring容器通过BeanPostProcessor给了我们一个机会对Spring管理的bean进行再加工。比如：我们可以修改bean的属性，可以给bean生成一个动态代理实例等等。参考: <a href="https://www.jianshu.com/p/1417eefd2ab1" target="_blank" rel="noopener">利用BeanPostProcessor做版本切换</a></li>
</ul>
<h2 id="Spring-Bean的作用域之间有什么区别"><a href="#Spring-Bean的作用域之间有什么区别" class="headerlink" title="Spring Bean的作用域之间有什么区别"></a>Spring Bean的作用域之间有什么区别</h2><ul>
<li><strong>singleton</strong>：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</li>
<li><strong>prototype</strong>：原形范围与单例范围相反，为每一个bean请求提供一个实例。</li>
<li><strong>request</strong>：在请求bean范围内会每一个来自<strong>客户端的网络请求</strong>创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li>
<li><strong>Session</strong>：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li><strong>global-session</strong>：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</li>
</ul>
<h2 id="请解释自动装配模式的区别"><a href="#请解释自动装配模式的区别" class="headerlink" title="请解释自动装配模式的区别"></a>请解释自动装配模式的区别</h2><ul>
<li><p><strong>no</strong>：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</p>
</li>
<li><p><strong>byName**</strong>：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p>
</li>
<li><p><strong>byType</strong>：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p>
</li>
<li><p><strong>constructor</strong>：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</p>
</li>
<li><p><strong>autodetect</strong>：该模式自动探测<strong>使用构造器自动装配或者byType自动装配</strong>。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</p>
</li>
</ul>
<h2 id="Spring-框架中都用到了哪些设计模式"><a href="#Spring-框架中都用到了哪些设计模式" class="headerlink" title="Spring 框架中都用到了哪些设计模式"></a>Spring 框架中都用到了哪些设计模式</h2><ul>
<li><strong>代理模式</strong>—在AOP和remoting中被用的比较多。 </li>
<li><strong>单例模式</strong>—在spring配置文件中定义的bean默认为单例模式。</li>
<li><strong>模板方法</strong>—用来解决代码重复的问题. 比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li><strong>工厂模式</strong>—BeanFactory用来创建对象的实例。</li>
<li><strong>Builder模式</strong> - 自定义配置文件的解析bean是时采用builder模式，一步一步地构建一个beanDefinition</li>
<li><strong>策略模式</strong> ：Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。这里主要看一下代理对象创建的策略模式的实现。前面已经了解 Spring 的代理方式有两个 <strong>Jdk 动态代理</strong>和<strong>CGLIB 代理</strong>。这两个代理方式的使用正是使用了策略模式。</li>
</ul>
<h2 id="AOP（Aspect-Oriented-Programming）是怎么实现的"><a href="#AOP（Aspect-Oriented-Programming）是怎么实现的" class="headerlink" title="AOP（Aspect-Oriented Programming）是怎么实现的"></a>AOP（Aspect-Oriented Programming）是怎么实现的</h2><p>实现AOP的技术，主要分为两大类：</p>
<ul>
<li>一是采用<strong>动态代理技术</strong>，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>二是采用<strong>静态织入的方式</strong>，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ul>
<p>Spring AOP 的实现原理其实很简单：AOP 框架负责动态地生成 AOP 代理类，这个代理类的方法则由 Advice和回调目标对象的方法所组成, 并将该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异，AOP方法在特定切入点添加了<strong>增强处理，并回调了目标对象的方法</strong>。</p>
<p>Spring AOP使用动态代理技术在运行期织入增强代码。使用两种代理机制：<strong>基于JDK的动态代理</strong>（JDK本身只提供接口的代理）和<strong>基于CGlib的动态代理</strong>。</p>
<ul>
<li><strong>(1) JDK的动态代理</strong></li>
</ul>
<p>JDK的动态代理主要涉及java.lang.reflect包中的两个类：<strong>Proxy和InvocationHandler</strong>。其中InvocationHandler只是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态的将横切逻辑与业务逻辑织在一起。而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</p>
<p>其代理对象<strong>必须是某个接口的实现</strong>, 它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理.只能实现接口的类生成代理,而<strong>不能针对类</strong></p>
<ul>
<li><strong>(2)CGLib</strong></li>
</ul>
<p>CGLib采用<strong>底层的字节码技术</strong>，<strong>为一个类创建子类</strong>，并在子类中采用方法拦截的技术拦截所有父类的调用方法，并顺势织入横切逻辑.它运行期间生成的代理对象是目标类的扩展子类.<strong>所以无法通知final、private的方法</strong>,因为它们不能被覆写.是针对类实现代理,主要是为指定的类生成一个子类,覆盖其中方法.</p>
<p>在spring中默认情况下使用JDK动态代理实现AOP,如果proxy-target-class设置为true或者使用了优化策略那么会使用CGLIB来创建动态代理.Spring　AOP在这两种方式的实现上基本一样．以JDK代理为例，会使用JdkDynamicAopProxy来创建代理，在invoke()方法首先需要织入到当前类的增强器封装到拦截器链中，然后递归的调用这些拦截器完成功能的织入．最终返回代理对象．</p>
<p><a href="http://zhengjianglong.cn/2015/12/12/Spring/spring-source-aop/" target="_blank" rel="noopener">http://zhengjianglong.cn/2015/12/12/Spring/spring-source-aop/</a></p>
<h2 id="介绍spring的IOC实现"><a href="#介绍spring的IOC实现" class="headerlink" title="介绍spring的IOC实现"></a>介绍spring的IOC实现</h2><p>Spring　<strong>IOC主要负责创建和管理bean及bean之间的依赖关系</strong>．Spring　IOC的可分为:IOC容器的初始化和bean的加载．</p>
<p>在IOC容器初始化阶段主要是完成资源的加载(如定义bean的xml文件)，bean的解析及对解析后得到的beanDefinition的进行注册．以xmlBeanFactory为例，XmlBeanFactory继承了DefaultListableBeanFactory，XmlBeanFactory将读取xml配置文件，解析bean和注册解析后的beanDefinition工作交给XmlBeanDefinitionReader(是BeanDefinitionReader接口的一个个性化实现)来执行.</p>
<ul>
<li><p>1) spring中定义了一套资源类，将文件，class等都看做资源．所以首先是将xml文件转化为资源然后用EncodeResouce来封装，该功能主要时考虑Resource可能存在编码要求的情况，如UTF-8等．</p>
</li>
<li><p>2) 然后根据xml文件判断xml的约束模式，是DTD还是Schema,以及寻找模式文档(验证文件)的方法(EntityResolver，这部分采用了代理模式和策略模式)．</p>
</li>
</ul>
<p>完成了前面所有的准备工作以后就可以正式的加载配置文件，获取Document和解析注册BeanDefinition．Document的获取以及BeanDefinition的解析注册并不是由<strong>XmlBeanDefinitionReader</strong>完成，XmlBeanDefinitionReader只是将前面的工作完成以后文档加载交给<strong>DefaultDocumentLoader</strong>类来完成．</p>
<p>而解析交给了<strong>DefaultBeanDefinitionDocumentReader</strong>来处理.bean标签可以分为两种，一种是spring自带的默认标签，另一种就是用户自定义的标签．所以spring针对这两种情况，提供了不同的解析方式. 每种bean的解析完成后都会先注册到容器中然后最后发出响应事件，通知相关的监听器这个bean已经注册完成了．</p>
<p><strong>bean的加载</strong>:</p>
<p><a href="http://zhengjianglong.cn/2015/12/06/Spring/spring-source-ioc-bean-parse/" target="_blank" rel="noopener">http://zhengjianglong.cn/2015/12/06/Spring/spring-source-ioc-bean-parse/</a></p>
<h2 id="spring中bean加载机制，bean生成的具体步骤"><a href="#spring中bean加载机制，bean生成的具体步骤" class="headerlink" title="spring中bean加载机制，bean生成的具体步骤"></a>spring中bean加载机制，bean生成的具体步骤</h2><ol>
<li>容器寻找Bean的定义信息并且将其实例化。</li>
<li>如果允许提前暴露工厂，则提前暴露这个bean的工厂，这个工厂主要是返回该未完全处理的bean．主要是用于避免单例属性循环依赖问题．</li>
<li>受用<strong>依赖注入</strong>，Spring按照Bean定义信息配置Bean的所有属性。</li>
<li>如果Bean实现了<strong>BeanNameAware</strong>接口，工厂调用Bean的<strong>setBeanName()</strong>方法传递Bean的ID。</li>
<li>如果Bean实现了<strong>BeanFactoryAware</strong>接口，工厂调用<strong>setBeanFactory()</strong>方法传入工厂自身。</li>
<li>如果实现了<strong>ApplicationContextAware</strong>, spring将调用setApplicationContext()方法，将bean所在的上下文的引用 进来。</li>
<li>如果<strong>BeanPostProcessor</strong>和Bean关联，那么它们的<strong>postProcessBeforeInitialization()</strong>方法将被调用。</li>
<li>如果Bean指定了init-method方法，它将被调用。</li>
<li>如果有<strong>BeanPostProcessor</strong>和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用</li>
<li>最后如果配置了destroy-method方法则注册<strong>DisposableBean</strong>.</li>
</ol>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3978349.html</a></p>
<h2 id="springMVC流程具体叙述下"><a href="#springMVC流程具体叙述下" class="headerlink" title="springMVC流程具体叙述下"></a>springMVC流程具体叙述下</h2><p>当应用启动时, 容器会加载servlet类并调用<strong>init</strong>方法. 在这个阶段，DispatcherServlet在init()完成初始化参数<strong>init-param</strong>的解析和封装、相关配置：</p>
<ul>
<li>完成了spring的<strong>WebApplicationContext</strong>的初始化，即完成xml文件的加载、bean的解析和注册等工作。</li>
<li>另外为servlet功能所用的变量进行初始化, 如:handlerMapping, viewResolvers等.</li>
</ul>
<p>当用户发送一个请求时，首先根据请求的类型调用DispatcherServlet不同的方法，这些方法都会转发到doService()中执行．在该方法内部完成以下工作：</p>
<ol>
<li><p>spring首先考虑<strong>multipart</strong>的处理, 如果是MultipartContent类型的request,则将该请求转换成MultipartHttpServletRequest类型的request.</p>
</li>
<li><p>根据request信息获取对应的<strong>Handler</strong>. 首先根据request获取访问路径,然后根据该路径可以选择直接匹配或通用匹配的方式寻找Handler,即用户定义的controller. Handler在init()方法时已经完成加载且保存到Map中了,只要根据路径就可以得到对应的Handler. 如果不存在则尝试使用默认的Handler. 如果还是没有找到那么就通过response向用户返回错误信息. 找到handler后会将其包装在一个<strong>执行链</strong>中,然后将所有的拦截器也加入到该链中.</p>
</li>
<li><p>如果存在handler则根据当前的handler寻找对应的<strong>HandlerAdapter</strong>. 通过遍历所有适配器来选择合适的适配器.</p>
</li>
<li><p>SpringMVC允许你通过处理<strong>拦截器</strong>Web请求,进行前置处理和后置处理.所以在正式调用 Handler的逻辑方法时,先执行所有拦截器的<strong>preHandle()</strong>方法.</p>
</li>
<li><p>正式执行handle的业务逻辑方法<strong>handle()</strong>,返回ModelAndView.逻辑处理是通过适配器调用handle并返回视图.这过程其实是调用用户controller的业务逻辑.</p>
</li>
<li><p>调用拦截器的<strong>postHandle()</strong>方法,完成后置处理.</p>
</li>
<li><p>根据视图进行页面跳转.该过程首先会根据视图名字解析得到视图,该过程支持缓存,如果缓存中存在则直接获取,否则创建新的视图并在支持缓存的情况下保存到缓冲中. 该过程完成了像添加前缀后缀, 设置必须的属性等工作.最后就是进行页面跳转处理.</p>
</li>
<li><p>调用拦截器的<strong>afterCompletion()</strong></p>
</li>
</ol>
<p> 核心类说明：</p>
<ul>
<li><strong>HandlerAdapter</strong>：它的作用用一句话概括就是调用具体的方法对用户发来的请求来进行处理。当handlerMapping获取到执行请求的controller时，DispatcherServlet会根据controller对应的controller类型来调用相应的HandlerAdapter来进行处理。 </li>
</ul>
<h2 id="spring各个版本的区别"><a href="#spring各个版本的区别" class="headerlink" title="spring各个版本的区别"></a>spring各个版本的区别</h2><h2 id="ioc注入的方式"><a href="#ioc注入的方式" class="headerlink" title="ioc注入的方式"></a>ioc注入的方式</h2><ul>
<li>setter方法注入</li>
<li>构造器注入</li>
</ul>
<pre><code>&lt;!--普通构造器注入--&gt;
&lt;bean id=&quot;helloAction&quot; class=&quot;org.yoo.action.ConstructorHelloAction&quot;&gt;
&lt;!--type 必须为java.lang.String 因为是按类型匹配的，不是按顺序匹配--&gt;

    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yoo&quot;/&gt;
    &lt;!-- 也可以使用index来匹配--&gt;
    &lt;!--&lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;--&gt;
    &lt;constructor-arg&gt;&lt;ref bean=&quot;helloService&quot;/&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><ul>
<li>静态工厂注入  factory-method参数</li>
<li>实例工厂</li>
</ul>
<p><a href="http://blessht.iteye.com/blog/1162131" target="_blank" rel="noopener">http://blessht.iteye.com/blog/1162131</a></p>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><ul>
<li><p><strong>方面（Aspect）</strong>：一个<strong>关注点</strong>的模块化，这个关注点实现可能横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</p>
</li>
<li><p><strong>连接点（Joinpoint）</strong>: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。可以理解什么时机执行aop的代码。</p>
</li>
<li><p><strong>通知（Advice）:</strong> 在特定的连接点，AOP框架执行的<strong>动作</strong>(怎么执行)。各种类型的通知包括“around”、“before”和“throws”等通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了5个advice:</p>
<ul>
<li>Interception Around：JointPoint前后调用</li>
<li>Before：JointPoint前调用</li>
<li>After Returning：JointPoint后调用</li>
<li>Throw：JoinPoint抛出异常时调用</li>
<li>Introduction：JointPoint调用完毕后调用</li>
</ul>
</li>
<li><p><strong>切入点（Pointcut）</strong>: 一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p>
</li>
<li><p><strong>引入（Introduction）</strong>: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p>
</li>
<li><p><strong>目标对象（Target Object）</strong>: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
</li>
<li><p><strong>AOP代理（AOP Proxy）</strong>: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
</li>
<li><p><strong>织入（Weaving）</strong>: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
</li>
</ul>
<h2 id="spring何时创建applicationContext-web-xml中使用listener-或dispatcherServlet"><a href="#spring何时创建applicationContext-web-xml中使用listener-或dispatcherServlet" class="headerlink" title="spring何时创建applicationContext(web.xml中使用listener 或dispatcherServlet)"></a>spring何时创建applicationContext(web.xml中使用listener 或dispatcherServlet)</h2><h2 id="listener是监听哪个事件-ServletContext创建事件"><a href="#listener是监听哪个事件-ServletContext创建事件" class="headerlink" title="listener是监听哪个事件(ServletContext创建事件)"></a>listener是监听哪个事件(ServletContext创建事件)</h2><p>ServletContextListener 接口用于监听 ServletContext 对象的创建和销毁事件:</p>
<ul>
<li>当 ServletContext 对象被创建时，激发contextInitialized (ServletContextEvent sce)方法</li>
<li>当 ServletContext 对象被销毁时，激发contextDestroyed(ServletContextEvent sce)方法。</li>
</ul>
<h2 id="过滤器与监听器的区别"><a href="#过滤器与监听器的区别" class="headerlink" title="过滤器与监听器的区别"></a>过滤器与监听器的区别</h2><p>Filter可认为是Servlet的一种“变种”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给 Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p>
<p> Java中的Filter 并不是一个标准的Servlet ，它不能处理用户请求，也不能对客户端生成响应。 主要用于对HttpServletRequest 进行预处理，也可以对HttpServletResponse 进行后处理，是个典型的处理链。优点：过滤链的好处是，执行过程中任何时候都可以打断，只要不执行chain.doFilter()就不会再执行后面的过滤器和请求的内容。而在实际使用时，就要特别注意过滤链的执行顺序问题<br> <a href="http://blog.csdn.net/sd0902/article/details/8395641" target="_blank" rel="noopener">http://blog.csdn.net/sd0902/article/details/8395641</a></p>
<p>Servlet,Filter都是针对url之类的，而Listener是针对对象的操作的，如session的创建，session.setAttribute的发生，或者在启动服务器的时候将你需要的数据加载到缓存等，在这样的事件发生时做一些事情。<br><a href="http://www.tuicool.com/articles/bmqMjm" target="_blank" rel="noopener">http://www.tuicool.com/articles/bmqMjm</a></p>
<h2 id="请描述一下java事件监听机制。"><a href="#请描述一下java事件监听机制。" class="headerlink" title="请描述一下java事件监听机制。"></a>请描述一下java事件监听机制。</h2><ul>
<li>Java的事件监听机制涉及到三个组件：事件源、事件监听器、事件对象</li>
<li>当事件源上发生操作时，它将会调用事件监听器的一个方法，并在调用这个方法时，会传递事件对象过来</li>
<li>事件监听器由开发人员编写，开发人员在事件监听器中，通过事件对象可以拿到事件源，从而对事件源上的操作进行处理。</li>
</ul>
<h2 id="解释核心容器-应用上下文-模块"><a href="#解释核心容器-应用上下文-模块" class="headerlink" title="解释核心容器(应用上下文)模块"></a>解释核心容器(应用上下文)模块</h2><p>这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。</p>
<h2 id="BeanFactory-–-BeanFactory-实例"><a href="#BeanFactory-–-BeanFactory-实例" class="headerlink" title="BeanFactory – BeanFactory 实例"></a>BeanFactory – BeanFactory 实例</h2><p>BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。最常用的BeanFactory实现是XmlBeanFactory类。</p>
<h2 id="XmlBeanFactory"><a href="#XmlBeanFactory" class="headerlink" title="XmlBeanFactory"></a>XmlBeanFactory</h2><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。</p>
<h2 id="解释AOP模块"><a href="#解释AOP模块" class="headerlink" title="解释AOP模块"></a>解释AOP模块</h2><p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<h2 id="解释抽象JDBC和DAO模块"><a href="#解释抽象JDBC和DAO模块" class="headerlink" title="解释抽象JDBC和DAO模块"></a>解释抽象JDBC和DAO模块</h2><p>通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。</p>
<h2 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h2><p>Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。</p>
<h2 id="解释web模块"><a href="#解释web模块" class="headerlink" title="解释web模块"></a>解释web模块</h2><p>Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p>
<h2 id="解释Spring-MVC模块"><a href="#解释Spring-MVC模块" class="headerlink" title="解释Spring MVC模块"></a>解释Spring MVC模块</h2><p>Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。</p>
<h2 id="ContextLoaderListener是监听什么事件"><a href="#ContextLoaderListener是监听什么事件" class="headerlink" title="ContextLoaderListener是监听什么事件"></a>ContextLoaderListener是监听什么事件</h2><p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</p>
<h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。</p>
<h2 id="IOC有什么优点？"><a href="#IOC有什么优点？" class="headerlink" title="IOC有什么优点？"></a>IOC有什么优点？</h2><p>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的<strong>测试很简单</strong>，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得<strong>松耦合</strong>得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<h2 id="应用上下文是如何实现的？"><a href="#应用上下文是如何实现的？" class="headerlink" title="应用上下文是如何实现的？"></a>应用上下文是如何实现的？</h2><p>ClassPathXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。</p>
<p>FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。</p>
<p>WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。</p>
<h2 id="有哪些不同类型的IOC-依赖注入"><a href="#有哪些不同类型的IOC-依赖注入" class="headerlink" title="有哪些不同类型的IOC(依赖注入)"></a>有哪些不同类型的IOC(依赖注入)</h2><p><strong>接口注入</strong>:接口注入的意思是通过接口来实现信息的注入，而其它的类要实现该接口时，就可以实现了注入</p>
<p>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</p>
<p>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
<h2 id="你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？"><a href="#你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？" class="headerlink" title="你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？"></a>你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？</h2><p>你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。</p>
<h2 id="什么是Spring-Beans"><a href="#什么是Spring-Beans" class="headerlink" title="什么是Spring Beans"></a>什么是Spring Beans</h2><p>Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。</p>
<p>在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。</p>
<h2 id="Spring-Bean中定义了什么内容？"><a href="#Spring-Bean中定义了什么内容？" class="headerlink" title="Spring Bean中定义了什么内容？"></a>Spring Bean中定义了什么内容？</h2><p>Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p>
<h2 id="如何向Spring-容器提供配置元数据"><a href="#如何向Spring-容器提供配置元数据" class="headerlink" title="如何向Spring 容器提供配置元数据"></a>如何向Spring 容器提供配置元数据</h2><p>有三种方式向Spring 容器提供元数据:</p>
<ul>
<li>XML配置文件</li>
<li>基于注解配置</li>
<li>基于Java的配置</li>
</ul>
<h2 id="Spring框架中单例beans是线程安全的吗？"><a href="#Spring框架中单例beans是线程安全的吗？" class="headerlink" title="Spring框架中单例beans是线程安全的吗？"></a>Spring框架中单例beans是线程安全的吗？</h2><p>不是，Spring框架中的单例beans不是线程安全的。</p>
<p><strong>Spring框架并没有对单例bean进行任何多线程的封装处理</strong>。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</p>
<h2 id="哪些是最重要的bean生命周期方法？能重写它们吗？"><a href="#哪些是最重要的bean生命周期方法？能重写它们吗？" class="headerlink" title="哪些是最重要的bean生命周期方法？能重写它们吗？"></a>哪些是最重要的bean生命周期方法？能重写它们吗？</h2><p>有两个重要的bean生命周期方法。</p>
<ul>
<li>第一个是setup方法，该方法在容器加载bean的时候被调用。</li>
<li>第二个是teardown方法，该方法在bean从容器中移除的时候调用。</li>
<li>bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。</li>
</ul>
<h2 id="什么是Spring的内部bean"><a href="#什么是Spring的内部bean" class="headerlink" title="什么是Spring的内部bean"></a>什么是Spring的内部bean</h2><p>当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。</p>
<h2 id="如何在Spring中注入Java集合类"><a href="#如何在Spring中注入Java集合类" class="headerlink" title="如何在Spring中注入Java集合类"></a>如何在Spring中注入Java集合类</h2><p>Spring提供如下几种类型的集合配置元素：</p>
<ul>
<li>list元素用来注入一系列的值，允许有相同的值。</li>
<li>set元素用来注入一些列的值，不允许有相同的值。</li>
<li>map用来注入一组”键-值”对，键、值可以是任何类型的。</li>
<li>props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</li>
</ul>
<h2 id="什么是bean-wiring？"><a href="#什么是bean-wiring？" class="headerlink" title="什么是bean wiring？"></a>什么是bean wiring？</h2><p>Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。</p>
<h2 id="什么是bean自动装配？"><a href="#什么是bean自动装配？" class="headerlink" title="什么是bean自动装配？"></a>什么是bean自动装配？</h2><p>Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&lt; property&gt;元素。</p>
<h2 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h2><p>自动装配有如下局限性：</p>
<ul>
<li>重写：你仍然需要使用 和&lt; property&gt;设置指明依赖，这意味着总要重写自动装配。</li>
<li>原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。</li>
<li>模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。</li>
</ul>
<h2 id="你可以在Spring中注入null或空字符串吗"><a href="#你可以在Spring中注入null或空字符串吗" class="headerlink" title="你可以在Spring中注入null或空字符串吗"></a>你可以在Spring中注入null或空字符串吗</h2><p>完全可以。</p>
<h2 id="什么是Spring基于Java的配置？给出一些注解的例子"><a href="#什么是Spring基于Java的配置？给出一些注解的例子" class="headerlink" title="什么是Spring基于Java的配置？给出一些注解的例子"></a>什么是Spring基于Java的配置？给出一些注解的例子</h2><p>基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。</p>
<h2 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h2><p>另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。</p>
<h2 id="如何开启注解装配？"><a href="#如何开启注解装配？" class="headerlink" title="如何开启注解装配？"></a>如何开启注解装配？</h2><p>注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。<a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a></p>
<h2 id="Required-注解"><a href="#Required-注解" class="headerlink" title="@Required 注解"></a>@Required 注解</h2><p>@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。</p>
<h2 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired 注解"></a>@Autowired 注解</h2><p>@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<h2 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a>@Qualifier 注解</h2><p>当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。</p>
<h2 id="在Spring框架中如何更有效的使用JDBC？"><a href="#在Spring框架中如何更有效的使用JDBC？" class="headerlink" title="在Spring框架中如何更有效的使用JDBC？"></a>在Spring框架中如何更有效的使用JDBC？</h2><p>使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate。</p>
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p>JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。</p>
<h2 id="Spring对DAO的支持"><a href="#Spring对DAO的支持" class="headerlink" title="Spring对DAO的支持"></a>Spring对DAO的支持</h2><p>Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。</p>
<h2 id="Spring支持的ORM"><a href="#Spring支持的ORM" class="headerlink" title="Spring支持的ORM"></a>Spring支持的ORM</h2><p>Spring支持一下ORM：</p>
<ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA (Java -Persistence API)</li>
<li>TopLink</li>
<li>JDO (Java Data Objects)</li>
<li>OJB</li>
</ul>
<h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持如下两种方式的事务管理：</p>
<ul>
<li><p><strong>编码式事务管理</strong>：sping对编码式事务的支持与EJB有很大区别，不像EJB与java事务API耦合在一起．spring通过回调机制将实际的事务实现从事务性代码中抽象出来．<strong>你能够精确控制事务的边界，它们的开始和结束完全取决于你</strong>．</p>
</li>
<li><p><strong>声明式事务管理</strong>：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。通过传播行为，隔离级别，回滚规则，事务超时，只读提示来定义．</p>
</li>
</ul>
<h2 id="Spring框架的事务管理有哪些优点"><a href="#Spring框架的事务管理有哪些优点" class="headerlink" title="Spring框架的事务管理有哪些优点"></a>Spring框架的事务管理有哪些优点</h2><ul>
<li>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。</li>
<li>它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).</li>
<li>它支持声明式事务管理。</li>
<li>它可以和Spring 的多种数据访问技术很好的融合。</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li><strong>原子性(Atomic)</strong>: 一个操作要么成功，要么全部不执行.</li>
<li><strong>一致性(Consistent)</strong>: 一旦事务完成，系统必须确保它所建模业务处于一致的状态</li>
<li><strong>隔离性(Isolated)</strong>: 事务允许多个用户对相同的数据进行操作，每个用户用户的操作相互隔离互补影响．</li>
<li><strong>持久性(Durable)</strong>: 一旦事务完成，事务的结果应该持久化．</li>
</ul>
<h2 id="spring事务定义的传播规则"><a href="#spring事务定义的传播规则" class="headerlink" title="spring事务定义的传播规则"></a>spring事务定义的传播规则</h2><ul>
<li><strong>PROPAGATION_REQUIRED</strong>: 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li><strong>PROPAGATION_SUPPORTS</strong>: 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li><strong>PROPAGATION_MANDATORY</strong>: 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong>: 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li><strong>PROPAGATION_NOT_SUPPORTED</strong>: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><strong>PROPAGATION_NEVER</strong>: 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><strong>PROPAGATION_NESTED</strong>: 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 </li>
</ul>
<h2 id="spring事务支持的隔离级别"><a href="#spring事务支持的隔离级别" class="headerlink" title="spring事务支持的隔离级别"></a>spring事务支持的隔离级别</h2><p>并发会导致以下问题：</p>
<ul>
<li><strong>脏读</strong>：发生在一个事务读取了另一个事务改写但尚未提交的数据．</li>
<li><strong>不可重复读</strong>：在一个事务执行相同的查询两次或两次以上，每次得到的数据不同．</li>
<li><strong>幻读</strong>：与不可重复读类似，发生在一个事务读取多行数据，接着另一个并发事务插入一些数据，随后查询中，第一个事务发现多了一些原本不存在的数据．</li>
</ul>
<p>spring 事务上提供以下的隔离级别:</p>
<ul>
<li><strong>ISOLATION_DEFAULT</strong>: 使用后端数据库默认的隔离级别，大多数数据库系统的默认隔离级别是READ COMMITTED。</li>
<li><strong>ISOLATION_READ_UNCOMMITTED</strong>: 允许<strong>读取未提交</strong>的数据变更，可能会导致<strong>脏读</strong>，幻读或不可重复读</li>
<li><strong>ISOLATION_READ_COMMITTD</strong>: 允许读取为<strong>提交数据</strong>,可以阻止脏读，当时幻读或不可重复读仍可能发生</li>
<li><strong>ISOLATION_REPEATABLE_READ</strong>: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生</li>
<li><strong>ISOLATION_SERIALIZABLE</strong>:　完全服从ACID</li>
</ul>
<h2 id="你更推荐那种类型的事务管理？"><a href="#你更推荐那种类型的事务管理？" class="headerlink" title="你更推荐那种类型的事务管理？"></a>你更推荐那种类型的事务管理？</h2><p>许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。</p>
<h2 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h2><ul>
<li><strong>BeanNameAutoProxyCreator</strong>：bean名称自动代理创建器</li>
<li><strong>DefaultAdvisorAutoProxyCreator</strong>：默认通知者自动代理创建器</li>
<li><strong>Metadata autoproxying</strong>：元数据自动代理</li>
</ul>
<h2 id="什么是织入？什么是织入应用的不同点？"><a href="#什么是织入？什么是织入应用的不同点？" class="headerlink" title="什么是织入？什么是织入应用的不同点？"></a>什么是织入？什么是织入应用的不同点？</h2><p>织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。</p>
<h2 id="什么是Spring的MVC框架？"><a href="#什么是Spring的MVC框架？" class="headerlink" title="什么是Spring的MVC框架？"></a>什么是Spring的MVC框架？</h2><p>Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><p>WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。</p>
<h2 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h2><p>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</p>
<h2 id="Controller-annotation"><a href="#Controller-annotation" class="headerlink" title="@Controller annotation"></a>@Controller annotation</h2><p>@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。</p>
<h2 id="RequestMapping-annotation"><a href="#RequestMapping-annotation" class="headerlink" title="@RequestMapping annotation"></a>@RequestMapping annotation</h2><p>@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。</p>
<h2 id="MyBatis-与-Hibernate的区别"><a href="#MyBatis-与-Hibernate的区别" class="headerlink" title="MyBatis 与 Hibernate的区别"></a>MyBatis 与 Hibernate的区别</h2><p>（1）<strong>hibernate是全自动，而mybatis是半自动</strong></p>
<p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p>
<p>（2）<strong>hibernate数据库移植性远大于mybatis</strong></p>
<p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p>
<p>（3）<strong>hibernate拥有完整的日志系统，mybatis则欠缺一些</strong></p>
<p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p>
<p>（4）mybatis相比hibernate需要关心很多细节</p>
<p><strong>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高</strong>。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p>
<p>（5）<strong>sql直接优化上，mybatis要比hibernate方便很多</strong></p>
<p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p>
<p>（6）缓存机制上，hibernate要比mybatis更好一些</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>
<h2 id="JDBC-和-Hibernate的区别"><a href="#JDBC-和-Hibernate的区别" class="headerlink" title="JDBC 和　Hibernate的区别"></a>JDBC 和　Hibernate的区别</h2><h2 id="Hibernate的原理体系架构"><a href="#Hibernate的原理体系架构" class="headerlink" title="Hibernate的原理体系架构"></a>Hibernate的原理体系架构</h2><p><img src="http://my.csdn.net/uploads/201205/30/1338346660_4642.gif" alt="图片标题"><br><strong>1) SessionFactory (org.hibernate.SessionFactory)</strong><br>针对单个数据库映射关系经过编译后的内存镜像，是线程安全的（不可变）。它是生成Session的工厂，本身要用到ConnectionProvider。该对象可以在进程或集群的级别上，为那些事务之间可以重用的数据提供可选的二级缓存。</p>
<p><strong>2) Session (org.hibernate.Session)</strong><br>表示应用程序与持久储存层之间交互操作的一个单线程对象，此对象生存期很短。 其隐藏了JDBC连接，也是Transaction的工厂。其会持有一个针对持久化对象的必选（第一级）缓存，在遍历对象图或者根据持久化标识查找对象时会用到。</p>
<p><strong>3) 事务Transaction (org.hibernate.Transaction)</strong><br>（可选的）应用程序用来指定原子操作单元范围的对象，它是单线程的，生命周期很短。 它通过抽象将应用从底层具体的JDBC、JTA以及CORBA事务隔离开。 某些情况下，一个Session之内可能包含多个Transaction对象。 尽管是否使用该对象是可选的，但无论是使用底层的API还是使用Transaction对象，事务边界的开启与关闭是必不可少的。</p>
<p><strong>4) ConnectionProvider  (org.hibernate.connection.ConnectionProvider)</strong><br>（可选的）生成JDBC连接的工厂（同时也起到连接池的作用）。 它通过抽象将应用从底层的Datasource或DriverManager隔离开。 仅供开发者扩展/实现用，并不暴露给应用程序使用。</p>
<p><strong>5)TransactionFactory (org.hibernate.TransactionFactory)</strong><br>（可选的）生成Transaction对象实例的工厂。 仅供开发者扩展/实现用，并不暴露给应用程序使用。</p>
<p><strong>6) 持久的对象及其集合</strong><br>带有持久化状态的、具有业务功能的单线程对象，此对象生存期很短。 这些对象可能是普通的JavaBeans/POJO，唯一特殊的是他们正与（仅仅一个）Session相关联。 一旦这个Session被关闭，这些对象就会脱离持久化状态，这样就可被应用程序的任何层自由使用。 （例如，用作跟表示层打交道的数据传输对象。）</p>
<p><strong>7) 瞬态(transient)和脱管(detached)的对象及其集合</strong><br>那些目前没有与session关联的持久化类实例。他们可能是在被应用程序实例化后，尚未进行持久化的对象。也可能是因为实例化他们的Session已经被关闭而脱离持久化的对象。</p>
<p>参考: <a href="http://blog.sina.com.cn/s/blog_667fe4a501016awl.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_667fe4a501016awl.html</a></p>
<h2 id="五大核心接口，"><a href="#五大核心接口，" class="headerlink" title="五大核心接口，"></a>五大核心接口，</h2><p>Hibernate的核心接口一共有5个，分别为:Session、SessionFactory、Transaction、Query和 Configuration。这5个核心接口在任何开发中都会用到。通过这些接口，不仅可以对持久化对象进行存取，还能够进行事务控制。下面对这五的核心 接口分别加以介绍。 </p>
<p><strong>1) Session接口</strong>:<br>Session接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的 SQL语句。)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSesion对象称为用户session。</p>
<p><strong>2) SessionFactory接口</strong><br>SessionFactroy接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建 Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。</p>
<p><strong>3) Configuration接口</strong><br>Configuration接口负责配置并启动Hibernate，创建SessionFactory对 象。在Hibernate的启动的过程中，Configuration类的实例首先定位映射文档位置、读取配置，然后创建SessionFactory对象。</p>
<p><strong>4) Transaction接口</strong><br>Transaction接口负责事务相关的操作。它是可选的，开发人员也可以设计编写自己的底层事务处理代码。</p>
<p><strong>5) Query和Criteria接口</strong>:<br>Query和Criteria接口负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式。</p>
<p><a href="http://blog.csdn.net/martinmateng/article/details/50879436" target="_blank" rel="noopener">http://blog.csdn.net/martinmateng/article/details/50879436</a></p>
<h2 id="Hibernate对象的三种状态转换"><a href="#Hibernate对象的三种状态转换" class="headerlink" title="Hibernate对象的三种状态转换"></a>Hibernate对象的三种状态转换</h2><h3 id="1-瞬时状态-transient"><a href="#1-瞬时状态-transient" class="headerlink" title="1.瞬时状态 (transient)"></a>1.瞬时状态 (transient)</h3><p>特征：</p>
<ol>
<li>不处于Session 缓存中</li>
<li>数据库中没有对象记录</li>
</ol>
<p>Java如何进入临时状态：</p>
<ol>
<li>通过new语句刚创建一个对象时</li>
<li>当调用Session 的delete()方法，从Session 缓存中删除一个对象时。</li>
</ol>
<h3 id="2-持久化状态-persisted"><a href="#2-持久化状态-persisted" class="headerlink" title="2.持久化状态(persisted)"></a>2.持久化状态(persisted)</h3><p>特征：</p>
<ol>
<li>处于Session 缓存中</li>
<li>持久化对象数据库中设有对象记录</li>
<li>Session 在特定时刻会保持二者同步</li>
</ol>
<p>Java如何进入持久化状态</p>
<ol>
<li>Session 的save()把临时－》持久化状态</li>
<li>Session 的load(),get()方法返回的对象</li>
<li>Session 的find()返回的list集合中存放的对象</li>
<li>session 的update(),saveOrupdate()使游离－》持久化</li>
</ol>
<h3 id="3-游离状态-detached"><a href="#3-游离状态-detached" class="headerlink" title="3.游离状态(detached)"></a>3.游离状态(detached)</h3><p>特征：</p>
<ol>
<li>不再位于Session 缓存中</li>
<li>游离对象由持久化状态转变而来，数据库中可能还有对应记录。</li>
</ol>
<p>Java如何进入持久化状态－》游离状态</p>
<ol>
<li>Session 的close()方法</li>
<li>Session 的evict()方法，从缓存中删除一个对象。提高性能。少用。</li>
</ol>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h2 id="Hibernate对一二级缓存的使用"><a href="#Hibernate对一二级缓存的使用" class="headerlink" title="Hibernate对一二级缓存的使用"></a>Hibernate对一二级缓存的使用</h2><p>（1）一级缓存就是Session级别的缓存，一个Session做了一个查询操作，它会把这个操作的结果放在一级缓存中，如果短时间内这个session（一定要同一个session）又做了同一个操作，那么hibernate直接从一级缓存中拿，而不会再去连数据库，取数据；</p>
<p>（2）二级缓存就是SessionFactory级别的缓存，顾名思义，就是查询的时候会把查询结果缓存到二级缓存中，如果同一个sessionFactory创建的某个session执行了相同的操作，hibernate就会从二级缓存中拿结果，而不会再去连接数据库；</p>
<p>3）Hibernate中提供了两级Cache，第一级别的缓存是Session级别的缓存，它是属于事务范围的缓存。这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存。这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存；</p>
<p><a href="http://www.open-open.com/lib/view/open1413527015465.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1413527015465.html</a></p>
<h2 id="Lazy-Load的理解"><a href="#Lazy-Load的理解" class="headerlink" title="Lazy-Load的理解"></a>Lazy-Load的理解</h2><p>在Hibernate框架中，当我们要访问的数据量过大时，明显用缓存不太合适， 因为内存容量有限，为了减少并发量，减少系统资源的消耗，这时Hibernate用懒加载机制来弥补这种缺陷，但是这只是弥补而不是用了懒加载总体性能就提高了。我们所说的懒加载也被称为延迟加载，它在查询的时候不会立刻访问数据库，而是返回代理对象，当真正去使用对象的时候才会访问数据库。</p>
<p>1、通过Session.load()实现懒加载</p>
<p>load(Object, Serializable)：根据id查询。查询返回的是代理对象，不会立刻访问数据库，是懒加载的。当真正去使用对象的时候才会访问数据库。用load()的时候会发现不会打印出查询语句，而使用get()的时候会打印出查询语句。<br>使用load()时如果在session关闭之后再查询此对象，会报异常：could not initialize proxy - no Session。处理办法：在session关闭之前初始化一下查询出来的对象：Hibernate.initialize(user);使用load()可以提高效率，因为刚开始的时候并没有查询数据库。但很少使用。</p>
<p>2、one-to-one(元素)实现了懒加载。</p>
<p>在一对一的时候，查询主对象时默认不是懒加载。即：查询主对象的时候也会把从对象查询出来。需要把主对象配制成lazy=”true” constrained=”true” fetch=”select”。此时查询主对象的时候就不会查询从对象，从而实现了懒加载。一对一的时候，查询从对象的是默认是懒加载。即：查询从对象的时候不会把主对象查询出来。而是查询出来的是主对象的代理对象。</p>
<p>3、many-to-one（元素）实现了懒加载。<br>多对一的时候，查询主对象时默认是懒加载。即：查询主对象的时候不会把从对象查询出来。</p>
<p>4、one-to-many(元素)懒加载：默认会懒加载，这是必须的，是重常用的。<br>一对多的时候，查询主对象时默认是懒加载。即：查询主对象的时候不会把从对象查询出来。</p>
<p>参考： <a href="http://blog.csdn.net/sanjy523892105/article/details/7071139" target="_blank" rel="noopener">http://blog.csdn.net/sanjy523892105/article/details/7071139</a><br><a href="http://blog.csdn.net/yaorongwang0521/article/details/7074573" target="_blank" rel="noopener">http://blog.csdn.net/yaorongwang0521/article/details/7074573</a></p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p><strong>悲观锁 (Pessimistic Locking)</strong><br>悲观锁，正如其名，他是对数据库而言的，数据库悲观了，他感觉每一个对他操作的程序都有可能产生并发。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p>
<p>优点：数据的一致性保持得很好<br>缺点：不适合多个用户并发访问。</p>
<p><strong>乐观锁</strong><br> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个”version”字段来实现。乐观锁的工作原理：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h2 id="描述-Struts-体系结构？对应各个部分的开发工作主要包括哪些？"><a href="#描述-Struts-体系结构？对应各个部分的开发工作主要包括哪些？" class="headerlink" title="描述 Struts 体系结构？对应各个部分的开发工作主要包括哪些？"></a>描述 Struts 体系结构？对应各个部分的开发工作主要包括哪些？</h2><p>Struts开源架构很好的实现了MVC模式，MVC即Model-View-Controller的缩写，是一种常用的设计模式。MVC 减弱了业务逻辑接口和数据接口之间的耦合，以及让视图层更富于变化。在Struts2的模型 - 视图 - 控制器模式，实现以下五个核心部件：</p>
<ul>
<li>Actions</li>
<li>Interceptors</li>
<li>Value Stack / OGNL</li>
<li>Results / Result types</li>
<li>View technologies</li>
</ul>
<p>Struts 2 从传统的MVC框架操作需要的模型，而不是在控制器角色略有不同，虽然有一些重叠</p>
<p><strong>模型</strong><br>模型以一个或多个java bean的形式存在。这些bean分为三类：Action Form、Action、JavaBean or EJB。Action Form通常称之为FormBean，封装了来自于Client的用户请求信息，如表单信息。Action通常称之为ActionBean，获取从ActionSevlet传来的FormBean，取出FormBean中的相关信息，并做出相关的处理，一般是调用Java Bean或EJB等。</p>
<p><strong>视图</strong><br>主要由JSP生成页面完成视图，Struts提供丰富的JSP 标签库： Html，Bean，Logic，Template等</p>
<p><strong>控制器</strong><br>该控制器负责响应用户输入和执行数据模型对象的相互作用。控制器接收输入，验证输入，然后进行业务操作，修改数据模型的状态。</p>
<p>这个解释比较好：　<a href="http://www.yiibai.com/struts_2/struts_architecture.html" target="_blank" rel="noopener">http://www.yiibai.com/struts_2/struts_architecture.html</a><br><a href="http://www.cnblogs.com/langtianya/archive/2013/04/09/3011090.html" target="_blank" rel="noopener">http://www.cnblogs.com/langtianya/archive/2013/04/09/3011090.html</a></p>
<h2 id="什么是Struts2"><a href="#什么是Struts2" class="headerlink" title="什么是Struts2"></a>什么是Struts2</h2><p>Apache Struts2的是一个在Java中构建<strong>Web应用程序开源框架</strong>。 Struts2是基于OpenSymphony的WebWork的框架。它是Struts1的提高，它更加灵活，易于使用和扩展。 Struts2的核心组成部分是Action，拦截器和结果页。</p>
<p>Struts2提供了许多方法来创建Action类，并<strong>通过struts.xml中或通过注释进行配置</strong>。我们可以创建自己的<strong>拦截器</strong>实现常见任务。 Struts2中自带了很多的<strong>标签，并使用OGNL表达式语言</strong>。我们可以创造我们自己的类型转换器来呈现的结果页面。结果页面可以JSP和FreeMarker的模板。</p>
<h2 id="Struts-与webWork的区别"><a href="#Struts-与webWork的区别" class="headerlink" title="Struts 与webWork的区别"></a>Struts 与webWork的区别</h2><p>Struts 2是Struts的下一代产品。是在 struts 和WebWork的技术基础上进行了合并，全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构的差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与Servlet API完全脱离开，所以Struts 2可以理解为WebWork的更新产品。</p>
<p>Struts和Webwork同为服务于Web的一种MVC框架，从某种程度上看，Struts2是从WebWork2上升级得到的。甚至Apache的官方文档也讲：WebWork2到Struts2是平滑的过渡。我们甚至也可以说Struts2就是WebWork2.3而已。在很多方面Struts仅仅是改变了WebWork下的名称。Struts2对应的有自己的标签，并且功能强大。Webwork也有自己的标签。</p>
<p>1) 在很多方面Struts2仅仅是改变了WebWork下的名称,如DispatcherUtil 改为了Dispatcher.<br>2) AroundInterceptor：Struts 2不再支持WebWork中的AroundInterceptor。如果应用程序中需要使用AroundInterceptor，则应该自己手动导入WebWork中的AroundInterceptor类。<br>3) IoC容器支持：Struts 2不再支持内建的IoC容器，而改为全面支持Spring的IoC容器，以Spring的IoC容器作为默认的Object工厂。<br>4) 富文本编辑器标签：Struts 2不再支持WebWork的富文本编辑器，如果应用中需要使用富文本编辑器，则应该使用<strong>Dojo</strong>的富文本编辑器。</p>
<p><a href="http://developer.51cto.com/art/201106/271744.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201106/271744.htm</a></p>
<h2 id="struts2-与struts1的区别"><a href="#struts2-与struts1的区别" class="headerlink" title="struts2 与struts1的区别"></a>struts2 与struts1的区别</h2><p>Action类,线程安全，测试，标签，验证<br><img src="imgs/struts2-vs-struts1.png"></p>
<p><strong>Action 类:</strong><br>• Struts1要求Action类继承一个<strong>抽象</strong>基类。Struts1的一个普遍问题是使用抽象类编程而不是接口，而struts2的Action是接口。<br>• Struts 2 Action类可以实现一个Action<strong>接口</strong>，也可实现其他接口，<strong>使可选和定制的服务成为可能</strong>。Struts2提供一个ActionSupport基类去 实现 常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。</p>
<p><strong>线程模式</strong>:<br>• Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。(<strong>不是线程安全</strong>)<br>• Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）(<strong>线程安全</strong>)</p>
<p><strong>Servlet 依赖</strong>:<br>• Struts1 Action 依赖于Servlet API ,因为当一个Action被调用时HttpServletRequest 和 HttpServletResponse 被传递给execute方法。<br>• Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2 Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest 和 HttpServletResponse的必要性。</p>
<p><strong>可测性</strong>:<br>• 测试Struts1 Action的一个主要问题是execute方法暴露了servlet API（这使得测试要依赖于容器）。一个第三方扩展－－Struts TestCase－－提供了一套Struts1的模拟对象（来进行测试）。<br>• Struts 2 Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。</p>
<p><strong>表达式语言</strong>：<br>• Struts1 整合了JSTL，因此使用JSTL EL。这种EL有基本对象图遍历，但是对集合和索引属性的支持很弱。<br>• Struts2可以使用JSTL，但是也支持一个更强大和灵活的表达式语言－－”Object Graph Notation Language” (OGNL). </p>
<p><strong>绑定值到页面（view）</strong>:<br>• Struts 1使用标准JSP机制把对象绑定到页面中来访问。<br>• Struts 2 使用 “ValueStack”技术，使taglib能够访问值而不需要把你的页面（view）和对象绑定起来。ValueStack策略允许通过一系列名称相同但类型不同的属性重用页面（view）。</p>
<h2 id="Struts工作流程"><a href="#Struts工作流程" class="headerlink" title="Struts工作流程:"></a>Struts工作流程:</h2><p><img src="http://www.evget.com/images/article/08072801.png" alt="图片标题"><br>Struts2:<br>(1)客户端提交一个HttpServletRequest请求(.action或JSP页面)<br>(2)请求被提交到一系列（主要是三层）的过滤器（Filter），如（ActionContextCleanUp、其他过滤器（SiteMesh等）、 FilterDispatcher）。注意这里是有顺序的，先ActionContextCleanUp，再其他过滤器（SiteMesh等）、最后到FilterDispatcher。<br>(3)FilterDispatcher是Struts2控制器的核心,它通常是过滤器链中的最后一个过滤器,FilterDispatcher进行初始化并启用核心doFilter().FilterDispatcher询问ActionMapper是否需要调用某个Action来处理这个（request）请求，如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy。<br>(6)ActionProxy通过<strong>ConfigurationManager</strong>(它会访问struts.xml)询问框架的配置文件,找到需要调用的Action类.<br>(7)ActionProxy创建一个ActionInvocation实例,而ActionInvocation通过代理模式调用Action,(在调用之前会根据配置文件加载相关的所有Interceptor拦截器)<br>(8)Action执行完毕后,返回一个result字符串,此时再按相反的顺序通过Interceptor拦截器.<br>(9)最后ActionInvocation负责根据struts.xml中配置的result元素,找到与返回值对应的result,决定进行下一步输出.</p>
<h2 id="为什么要使用-Struts2-amp-Struts2-的优点："><a href="#为什么要使用-Struts2-amp-Struts2-的优点：" class="headerlink" title="为什么要使用 Struts2 &amp; Struts2 的优点："></a>为什么要使用 Struts2 &amp; Struts2 的优点：</h2><p>①. 基于 MVC 架构，框架结构清晰。<br>②. 使用 OGNL: OGNL 可以快捷的访问值栈中的数据、调用值栈中对象的方法<br>③. 拦截器: Struts2 的拦截器是一个 Action 级别的 AOP, Struts2 中的许多特性都是通过拦截器来实现的, 例如异常处理，文件上传，验证等。拦截器是可配置与重用的<br>④. 多种表现层技术. 如：JSP、FreeMarker、Velocity 等</p>
<h2 id="SpringMVC-与-Struts2区别"><a href="#SpringMVC-与-Struts2区别" class="headerlink" title="SpringMVC 与　Struts2区别"></a>SpringMVC 与　Struts2区别</h2><p>1.核心控制器（前端控制器、预处理控制器）：对于使用过mvc框架的人来说这个词应该不会陌生，核心控制器的主要用途是处理所有的请求，然后对那些特殊的请求 （控制器）统一的进行处理(字符编码、文件上传、参数接受、异常处理等等),spring mvc核心控制器是Servlet，而Struts2是Filter。<br>2.控制器实例：Spring Mvc会比Struts快一些（理论上）。Spring Mvc是基于方法设计，而Sturts是基于对象，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring更像Servlet一样，只有一个实例，每次请求执行对应的方法即可(注意：由于是单例实例，所以应当避免全局变量的修改，这样会产生线程安全问题)。<br>3. 管理方式：大部分的公司的核心架构中，就会使用到spring,而spring mvc又是spring中的一个模块，所以spring对于spring mvc的控制器管理更加简单方便，而且提供了全 注解方式进行管理，各种功能的注解都比较全面，使用简单，而struts2需要采用XML很多的配置参数来管理（虽然也可以采用注解，但是几乎没有公司那 样使用）。<br>4.参数传递：Struts2中自身提供多种参数接受，其实都是通过（ValueStack）进行传递和赋值，而SpringMvc是通过方法的参数进行接收。<br>5.intercepter 的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。这样导致struts的配置文件量还是比spring mvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上spring3 mvc就容易实现restful url。struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而struts2搞的就比较乱，虽然方法之间 也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。<br>7.spring mvc处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，spring mvc自动帮我们对象转换为JSON数据。</p>
<h2 id="Filter-Listener-Servlet区别"><a href="#Filter-Listener-Servlet区别" class="headerlink" title="Filter,Listener,Servlet区别"></a>Filter,Listener,Servlet区别</h2><p>1) Filter　实现javax.servlet.Filter接口，在web.xml中配置与标签指定使用哪个Filter实现类过滤哪些URL链接。只在web启动时进行初始化操作。filter流程是<strong>线性</strong>的， url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个filter, servlet接收等，而servlet 处理之后，不会继续向下传递。filter功能可用来保持流程继续按照原来的方式进行下去，或者主导流程，而servlet的功能主要用来主导流程。<br>特点：可以在响应之前修改Request和Response的头部，只能转发请求，不能直接发出响应。filter可用来进行字符编码的过滤，检测用户是否登陆的过滤，禁止页面缓存等<br>2) Servlet 流程是短的，url传来之后，就对其进行处理，之后返回或转向到某一自己指定的页面。它主要用来在业务处理之前进行控制。<br>3) Listener<br>servlet,filter都是针对url之类的，而listener是针对<strong>对象操作</strong>的，如session的创建，session.setAttribute的发生，在这样的事件发<br>生时做一些事情。</p>
<h2 id="Struts2拦截器和过滤器的区别"><a href="#Struts2拦截器和过滤器的区别" class="headerlink" title="Struts2拦截器和过滤器的区别"></a>Struts2拦截器和过滤器的区别</h2><p>①、过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器。<br>②、Struts2 拦截器只能对 Action 请求起作用，而过滤器则可以对几乎所有请求起作用。<br>③、拦截器可以访问 Action 上下文(ActionContext)、值栈里的对象(ValueStack)，而过滤器不能.<br>④、在 Action 的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。</p>
<h2 id="Struts的Action是不是线程安全的"><a href="#Struts的Action是不是线程安全的" class="headerlink" title="Struts的Action是不是线程安全的"></a>Struts的Action是不是线程安全的</h2><p> struts2的action是线程安全的，struts1的action不是线程安全的 。<br>对于struts1 ，Action是单例模式，一个实例来处理所有的请求。当第一次**.do的请求过来时，在内存中的actionmapping中找到相对应的action，然后new出这个action放在缓存中，当第二次一样的请求过来时，还是找的这个action，所以对于struts1来说，action是单实例的，只有一个，如果在action中定义变量，就要非常小心了，因为并发问题，可能带来灾难性的后果，也不是不可以，我们可以加锁达到同步，只是在性能上就 要折衷了。<br>声明局部变量，或者扩展RequestProcessor，让每次都创建一个Action，或者在spring中用scope=”prototype”来管理，不申明类变量就可以保证线程安全。因为只存在一个Action类实例，所有线程会共享类变量。<br>struts2 在struts1的基础上做了改进 ，对于struts2 ，每次请求过来都会new一个新的action, 所以说struts2的action没有线程安全问题，是线程安全的，但同时也带来一个问题，每次都new一个action ，这样action的实例太多 ， 在性能方面还是存在一定的缺陷的。</p>
<h2 id="struts2-0的mvc模式与struts1-0的区别"><a href="#struts2-0的mvc模式与struts1-0的区别" class="headerlink" title="struts2.0的mvc模式与struts1.0的区别?"></a>struts2.0的mvc模式与struts1.0的区别?</h2><p>与struts1最大的不同是：struts2的控制器。struts2的控制器不再像struts1的控制器,需要<strong>继承</strong>一个Action父类,甚至可以无需实现任何接口,struts2的Action就是一个普通的POJO。实际上，Struts2 的Action就是一个包含execute方法的普通Java类该类里包含的多个属性用于封装用户的请求参数。</p>
<h2 id="你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？"><a href="#你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？" class="headerlink" title="你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？"></a>你对MVC的理解，MVC有什么优缺点？结合Struts，说明在一个Web应用如何去使用？</h2><p>MVC设计模式（应用观察者模式的框架模式）<br>M: Model(Business process layer)，模型，是应用程序中用于处理应用程序数据逻辑的部分,通常模型对象负责在数据库中存取数据。,并独立于表现层 (Independent of presentation)。<br>V: View(Presentation layer)，视图，通过客户端数据类型显示数据,并回显模型层的执行结果。<br>C: Controller(Control layer)，控制器，也就是<strong>视图层和模型层桥梁</strong>，控制数据的流向，接受视图层发出的事件，并重绘视图<br>优点：<br>1）视图控制模型分离，提高代码重用性。<br>2）提高开发效率。<br>3）便于后期维护，降低维护成本。<br>4）方便多开发人员间的分工。<br>5)结构清晰<br>缺点：<br>1）清晰的构架以代码的复杂性为代价， 对小项目优可能反而降低开发效率。<br>2）运行效率相对较低 </p>
<p>MVC框架的一种实现模型<br>模型二(Servlet-centric)： JSP+Servlet+JavaBean，以控制为核心，JSP只负责显示和收集数据，Sevlet，连接视图和模型，将视图层数据，发送给模型层，JavaBean，分为业务类和数据实体，业务类处理业务数据，数据实体，承载数据，基本上大多数的项目都是使用这种MVC的实现模式。</p>
<p>Struts MVC框架(Web application frameworks)  :Struts是使用MVC的实现模式二来实现的，也就是以控制器为核心。</p>
<p>Struts提供了一些组件使用MVC开发应用程序：<br>Model：Struts 没有提供model 类。这个商业逻辑必须由Web 应用程序的开发者以JavaBean或EJB的形式提供<br>View：Struts提供了action form创建form bean, 用于在controller和view间传输数据。此外，Struts提供了自定义JSP标签库，辅助开发者用JSP创建交互式的以表单为基础的应用程序，应用程序资源文件保留了一些文本常量和错误消息，可转变为其它语言， 可用于JSP中。<br>Controller：Struts提供了一个核心的控制器FilterDispatcher，通过这个核心的控制器来调用其他用户注册了的自定义的控制器Action，自定义Action需要符合Struts的自定义Action规范，还需要在struts-config.xml的特定配置文件中进行配置，接收JSP输入字段形成Action form，然后调用一个Action控制器。Action控制器中提供了model的逻辑接口。</p>
<h2 id="说出-struts2-中至少-5-个的默认拦截器"><a href="#说出-struts2-中至少-5-个的默认拦截器" class="headerlink" title="说出 struts2 中至少 5 个的默认拦截器"></a>说出 struts2 中至少 5 个的默认拦截器</h2><p>exception；fileUpload；i18n；modelDriven；params；prepare；token；tokenSession；validation 等<br>拦截器的生命周期与工作过程 ?</p>
<h2 id="每个拦截器都是需要实现-Interceptor-接口"><a href="#每个拦截器都是需要实现-Interceptor-接口" class="headerlink" title="每个拦截器都是需要实现 Interceptor 接口"></a>每个拦截器都是需要实现 Interceptor 接口</h2><p>init()：在拦截器被创建后立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化；<br>intercept(ActionInvocation invocation)：每拦截一个动作请求，该方法就会被调用一次；<br>destroy：该方法将在拦截器被销毁之前被调用, 它在拦截器的生命周期内也只被调用一次；</p>
<h2 id="创建Action类有几种方法？"><a href="#创建Action类有几种方法？" class="headerlink" title="创建Action类有几种方法？"></a>创建Action类有几种方法？</h2><p>实现Action 接口<br>使用Struts2 @Action 元注解<br>继承ActionSupport类，必须实现 execute() 方法，返回一个可配置的字符串</p>
<p>##Struts2的拦截器执行什么模式？<br><strong>责任链模式</strong><br>过滤器decorator模式和职责链模式</p>
<h1 id="web-部分"><a href="#web-部分" class="headerlink" title="web 部分"></a>web 部分</h1><h2 id="1-servlet生命周期"><a href="#1-servlet生命周期" class="headerlink" title="1. servlet生命周期"></a>1. servlet生命周期</h2><p>servlet的声明周期周期是由servlet的容器来控制,它可以分为3个阶段:初始化,运行和销毁. </p>
<h3 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="1) 初始化阶段"></a>1) 初始化阶段</h3><p>初始化阶段主要完成以下任务: </p>
<ul>
<li>servlet容器加载servlet类,把servlet类的.class文件中的数据读到内存中. </li>
<li>servlet容器创建一个ServletConfig对象,ServletConfig对象包含了servlet的初始化配置信息. </li>
<li>servlet容器创建一个servlet对象 </li>
<li>servlet容器调用servlet的init方法进行初始化. </li>
</ul>
<h3 id="2-运行阶段"><a href="#2-运行阶段" class="headerlink" title="2) 运行阶段"></a>2) 运行阶段</h3><p>当servlet容器收到一个请求时,servlet容器会针对这个请求创建servletRequest和servletResponse对象,然后调用service方法.并把这两个参数传递给service方法.service方法通过servletRequest对象获得请求的信息,并处理该请求. 再通过servletResponse对象生成这个请求的相应结果.然后销毁servletRequest和servletResponse对象. 不管这个请求时post还是get提交的,最终这个请求都会由service方法来处理. </p>
<h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3) 销毁阶段"></a>3) 销毁阶段</h3><p>当web应用被终止时,servlet容器会调用servlet对象的destroy方法,然后销毁servlet对象. 同时也会销毁servlet对象相关联的servletConfig对象. 我们可以通过destroy方法释放servlet占用的资源.</p>
<p><a href="https://reonyu.github.io/" target="_blank" rel="noopener">https://reonyu.github.io/</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/15/面向对象-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/01/15/面向对象-Java/" class="post-title-link" itemprop="url">面向对象-Java</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-01-15 15:18:11" itemprop="dateCreated datePublished" datetime="2019-01-15T15:18:11+08:00">2019-01-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 17:08:13" itemprop="dateModified" datetime="2019-10-11T17:08:13+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- GFM-TOC -->
<ul>
<li><a href="#一三大特性">一、三大特性</a><ul>
<li><a href="#封装">封装</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#多态">多态</a></li>
</ul>
</li>
<li><a href="#二类图">二、类图</a><ul>
<li><a href="#泛化关系-generalization">泛化关系 (Generalization)</a></li>
<li><a href="#实现关系-realization">实现关系 (Realization)</a></li>
<li><a href="#聚合关系-aggregation">聚合关系 (Aggregation)</a></li>
<li><a href="#组合关系-composition">组合关系 (Composition)</a></li>
<li><a href="#关联关系-association">关联关系 (Association)</a></li>
<li><a href="#依赖关系-dependency">依赖关系 (Dependency)</a></li>
</ul>
</li>
<li><a href="#三设计原则">三、设计原则</a><ul>
<li><a href="#solid">S.O.L.I.D</a></li>
<li><a href="#其他常见原则">其他常见原则</a></li>
</ul>
</li>
<li><a href="#四、JavaIO/NIO">四、Java IO/NIO</a></li>
<li><a href="#五、JVM">五、JVM</a></li>
<li><a href="#六、thread">六、thread</a></li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
<h1 id="一、三大特性"><a href="#一、三大特性" class="headerlink" title="一、三大特性"></a>一、三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure>

<h1 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h1><p>以下类图使用 <a href="https://www.planttext.com/" target="_blank" rel="noopener">PlantUML</a> 绘制，更多语法及使用请参考：<a href="http://plantuml.com/" target="_blank" rel="noopener">http://plantuml.com/</a> 。</p>
<h2 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h2><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Generalization</span><br><span class="line"></span><br><span class="line">class Vihical</span><br><span class="line">class Car</span><br><span class="line">class Trunck</span><br><span class="line"></span><br><span class="line">Vihical &lt;|-- Car</span><br><span class="line">Vihical &lt;|-- Trunck</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h2><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Realization</span><br><span class="line"></span><br><span class="line">interface MoveBehavior</span><br><span class="line">class Fly</span><br><span class="line">class Run</span><br><span class="line"></span><br><span class="line">MoveBehavior &lt;|.. Fly</span><br><span class="line">MoveBehavior &lt;|.. Run</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h2><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Aggregation</span><br><span class="line"></span><br><span class="line">class Computer</span><br><span class="line">class Keyboard</span><br><span class="line">class Mouse</span><br><span class="line">class Screen</span><br><span class="line"></span><br><span class="line">Computer o-- Keyboard</span><br><span class="line">Computer o-- Mouse</span><br><span class="line">Computer o-- Screen</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h2><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Composition</span><br><span class="line"></span><br><span class="line">class Company</span><br><span class="line">class DepartmentA</span><br><span class="line">class DepartmentB</span><br><span class="line"></span><br><span class="line">Company *-- DepartmentA</span><br><span class="line">Company *-- DepartmentB</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h2><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Association</span><br><span class="line"></span><br><span class="line">class School</span><br><span class="line">class Student</span><br><span class="line"></span><br><span class="line">School &quot;1&quot; - &quot;n&quot; Student</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h2><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Dependency</span><br><span class="line"></span><br><span class="line">class Vihicle &#123;</span><br><span class="line">    move(MoveBehavior)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MoveBehavior &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note &quot;MoveBehavior.move()&quot; as N</span><br><span class="line"></span><br><span class="line">Vihicle ..&gt; MoveBehavior</span><br><span class="line"></span><br><span class="line">Vihicle .. N</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h1 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h1><h2 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h2><table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">全拼</th>
<th align="center">中文翻译</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SRP</td>
<td align="center">The Single Responsibility Principle</td>
<td align="center">单一责任原则</td>
</tr>
<tr>
<td align="center">OCP</td>
<td align="center">The Open Closed Principle</td>
<td align="center">开放封闭原则</td>
</tr>
<tr>
<td align="center">LSP</td>
<td align="center">The Liskov Substitution Principle</td>
<td align="center">里氏替换原则</td>
</tr>
<tr>
<td align="center">ISP</td>
<td align="center">The Interface Segregation Principle</td>
<td align="center">接口分离原则</td>
</tr>
<tr>
<td align="center">DIP</td>
<td align="center">The Dependency Inversion Principle</td>
<td align="center">依赖倒置原则</td>
</tr>
</tbody></table>
<h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h3><blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h3><blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h2 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h2><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">全拼</th>
<th align="center">中文翻译</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOD</td>
<td align="center">The Law of Demeter</td>
<td align="center">迪米特法则</td>
</tr>
<tr>
<td align="center">CRP</td>
<td align="center">The Composite Reuse Principle</td>
<td align="center">合成复用原则</td>
</tr>
<tr>
<td align="center">CCP</td>
<td align="center">The Common Closure Principle</td>
<td align="center">共同封闭原则</td>
</tr>
<tr>
<td align="center">SAP</td>
<td align="center">The Stable Abstractions Principle</td>
<td align="center">稳定抽象原则</td>
</tr>
<tr>
<td align="center">SDP</td>
<td align="center">The Stable Dependencies Principle</td>
<td align="center">稳定依赖原则</td>
</tr>
</tbody></table>
<h3 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<h3 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h3><p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h3 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h3><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<h3 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h3><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<h3 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h3><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h1 id="四、Java-IO-NIO"><a href="#四、Java-IO-NIO" class="headerlink" title="四、Java IO/NIO"></a>四、Java IO/NIO</h1><h2 id="1-1-kernel-IO-linux-IO"><a href="#1-1-kernel-IO-linux-IO" class="headerlink" title="1.1 kernel IO/linux IO"></a>1.1 kernel IO/linux IO</h2><p>用户进程进行I/O操作的时候实际上交给了kernel进行执行，kernel执行的I/O操作可以分为两个阶段：</p>
<div align="center"> <img src="../images/15267089312034.jpg" width="400"> </div>


<ul>
<li><strong>准备阶段</strong>：在执行I/O操作的时候需要等待I/O是否就绪，因为此刻IO设备在忙状态。以网络IO为例，在读取远程数据时，需要阻塞等待远程将数据发送过来，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。 </li>
</ul>
<div align="center"> <img src="../images/15267023963428.jpg" width="400"> </div>

<ul>
<li><strong>用户进程空间和内核空间的数据拷贝</strong> : 当等到数据准备好了，kernel就会将数据从从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</li>
</ul>
<p>准备阶段时，CPU内容发送指令给IO通道，让IO通道负责执行IO的读写操作。CPU不用一直阻塞可以继续执行别的逻辑，但此刻IO线程会挂起，等待IO通道读写操作完成通知。 IO通道将操作交给DMA，DMA直接连接设备控制器负责将设备控制器中的数据直接读入到内核内存中。读完成后通知通道告知IO处理完成，IO通道发送中断给CPU，原内核IO线程醒来继续执行后续工作</p>
<h2 id="1-1-I-O-模型"><a href="#1-1-I-O-模型" class="headerlink" title="1.1 I/O 模型"></a>1.1 I/O 模型</h2><p>根据IO对kernel IO操作两个阶段的感知能力可以分为一下四种IO模型：</p>
<ul>
<li><strong>阻塞（Blocking）</strong>：阻塞等待IO就绪，这期间用户线程不可以做其他事情。</li>
<li><strong>非阻塞（Non-blocking）</strong>：轮询感知IO就绪，用户线程可以做其他事情。</li>
<li><strong>同步（Synchronous）</strong>：同步等待读IO读写结果。</li>
<li><strong>异步（Asynchronous）</strong>：异步等待kernel通知IO读写结果。</li>
</ul>
<p><strong>IO阻塞和非阻塞主要关注IO的就绪状态的感知方式，同步和异步关注IO读写操作的结果获取方式</strong>。同步是指函数完成之前会一直等待；阻塞 是指系统调用的时候进程会被设置为Sleep状态直到等待的事件发生（比如有新的数据）。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞是一种<strong>调用机制</strong>，用来描述进程处理调用的方式。在IO中两者的<strong>区别主要体现在I/O未准备好时，用户线程是否可以做其他事情</strong>。比如网络读操作，根据是否需要等待kernel数据准备好。</p>
<p>阻塞是等待某个事件的就绪/发生，当前线程会被<strong>挂起</strong>，一直处于等待消息通知，不能执行其他业务。<strong>阻塞通信意味着通信方法在尝试访问套接字或者读写数据时阻塞了对套接字的访问</strong>。以网络读操作为例，用户线程在socket中调用recv函数时，如果缓冲区中没有数据，则需要一直阻塞等待服务端发来的数据，这时候线程会挂起等待。 </p>
<p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。非阻塞IO是用户线程不会一直阻塞待待IO就绪，通过不断轮询的方式来查看就绪状态。。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步是一种<strong>通信机制</strong>，涉及到调用方和被调用方，<strong>关注的是IO操作结果的获知方式，主要区别在于IO结果未返回时用户线程是否可以做其他事情</strong>：</p>
<ul>
<li><strong>同步</strong>是调用方需要保持等待直到IO操作完成，进而通过返回获得结果；</li>
<li><strong>异步</strong>则调用方在IO操作的执行过程中不需要保持等待，而是在操作完成后被动的接受（通过消息或回调）被调用方推送的结果。</li>
</ul>
<p>以下是同步和异步定义：</p>
<blockquote>
<p><strong>A synchronous I/O</strong> operation causes the requesting process to be blocked until that I/O operation completes;<br><strong>An asynchronous I/O</strong> operation does not cause the requesting process to be blocked;</p>
</blockquote>
<p>同步和异步的区别也在于在进行整个IO操作的时候会用户进程<strong>是否会阻塞等待结果</strong>，linux中IO模型中blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<h2 id="1-2-linux-I-O-模型"><a href="#1-2-linux-I-O-模型" class="headerlink" title="1.2 linux I/O 模型"></a>1.2 linux I/O 模型</h2><p>linux根据用户进程对这个两个阶段的感知方式分为5中I/O模型：</p>
<ul>
<li>阻塞I/O（bloking IO）</li>
<li>非阻塞I/O（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li>异步IO（asynchronous IO）</li>
</ul>
<h3 id="1）-阻塞IO（blocking-IO）"><a href="#1）-阻塞IO（blocking-IO）" class="headerlink" title="1） 阻塞IO（blocking IO）"></a>1） 阻塞IO（blocking IO）</h3><p>默认情况下所有的socket都是blocking</p>
<div align="center"> <img src="../images/15263482717424.jpg" width="500"> </div>

<p> 当用户进程调用了recvfrom这个系统调用，就<strong>阻塞等待结果</strong>。kernel负责完成IO操作，完成后返回给用户。用户进程需要阻塞等待kernel完成两个阶段操作：<strong>准备数据(wait for data)</strong>、 <strong>数据拷贝到用户进程空间(copy data from kenel to user)</strong>。 阻塞IO是同步阻塞IO, 准备数据阶段会阻塞并同步等待I/O结果。在准备阶段和数据拷贝阶段中，用户线程都会被阻塞。</p>
<p>使用linux中进行网络编程时，一般都从listen()、send()、recv() 等接口开始，这些接口都是阻塞型。使用这些接口可以方便构建服务器/客户机模型。下面是一个简单地“一问一答”服务器。 整体流程如下:</p>
<div align="center"> <img src="../images/15263488660716.jpg" width="300"> </div>


<p><strong>服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销。通常会对它的线程模型进行优化，后端通过一个线程池来处理多个客户端的请求接入。通过“线程池”减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务，提高系统性能。</p>
<div align="center"> <img src="../images/15263493121606.jpg" width="600"> </div>


<p>java 的BIO就是采用这种模式实现的。</p>
<h3 id="2）非阻塞IO（non-blocking-IO）"><a href="#2）非阻塞IO（non-blocking-IO）" class="headerlink" title="2）非阻塞IO（non-blocking IO）"></a>2）非阻塞IO（non-blocking IO）</h3><div align="center"> <img src="../images/15263496139671.jpg" width="500"> </div>

<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它<strong>并不会block用户进程，而是立刻返回一个error</strong>。整体流程是：</p>
<ol>
<li>用户线程轮询查看kernel是否准备好数据（datagram ready）。这个过程kernel主要处于wait for data阶段。</li>
<li>当用户调用read, kernel已准备好数据，则执行数据拷贝操作，<strong>用户线程阻塞直到数据读取完成</strong>。kernel读取数据完成后，返回给用户数据。 </li>
</ol>
<p>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p><strong>在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有，非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。</strong></p>
<p><strong>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的</strong>，因此属于同步IO。</p>
<p>优点：</p>
<ol>
<li>用户进程不会被阻塞，可以在期间做一些别的事情。</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户线程不知道什么时候完成，需要不断的轮询查看I/O操作结果。看是否已经读取完成，增加了用户使用的复杂度。</li>
<li>在数据copy部分用户进程还是需要阻塞。</li>
</ol>
<h3 id="3）多路复用IO（IO-multiplexing）"><a href="#3）多路复用IO（IO-multiplexing）" class="headerlink" title="3）多路复用IO（IO multiplexing）"></a>3）多路复用IO（IO multiplexing）</h3><p>IO multiplexing，也称这种IO方式为<strong>事件驱动IO(event driven IO)</strong>。非阻塞IO（non-blocking IO）模式需要用户自己去轮询查看是否数据准备好，如果准备好则阻塞调用kernel进行copy。多路复用IO就是解决这种轮询问题，linux内部提供了select/poll/epoll来完成IO复用。</p>
<p>select/poll/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<div align="center"> <img src="../images/15263505327822.jpg" width="500"> </div>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select的调用过程如下所示：</p>
<div align="center"> <img src="../images/15263523909429.jpg" width="400"> </div>

<p>select负责管理多个FD文件描述符，kernel就会<strong>轮询</strong>检查所有select负责的fd，看是否有一个FD的数据已准备好。select会返回kernel数据准备就绪的FD， FD调用read操作让kernel完成数据的拷贝。 select解决了非阻塞状态下用户进程需要自己轮询的问题，同时可以用一个线程管理多个用户进程的读写操作。</p>
<p>select的缺点：</p>
<ul>
<li>单个进程能够监视的文件描述符的<strong>数量存在最大限制</strong>，<strong>通常是1024</strong>，当然可以更改数量。</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</li>
<li>内核/用户空间内存拷贝问题。每次调用select，<strong>都需要把fd集合从用户态拷贝到内核态</strong>，这个开销在fd(客户端套接字)很多时会很大。</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</strong>。然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的</strong>，但是同样有一个缺点：</p>
<ul>
<li>1）大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>2）poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<strong>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的copy只需一次。</p>
<p>基本原理：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，<strong>epoll使用“事件”的就绪通知方式</strong>，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似<strong>callback的回调机制来激活该fd</strong>，epoll_wait便可以收到通知。</p>
<p>epoll的优点：</p>
<ol>
<li><strong>没有最大并发连接的限制</strong>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li><strong>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</strong>。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li><strong>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递</strong>；即epoll使用mmap减少复制开销。</li>
</ol>
<h3 id="4）信号驱动式IO"><a href="#4）信号驱动式IO" class="headerlink" title="4）信号驱动式IO"></a>4）信号驱动式IO</h3><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它<strong>并不会block用户进程，而是立刻返回一个, 用户进程可以执行自己的程序不用轮询结果。kernel在IO就绪时会发送一个信号给用户进程告知IO准备好，可以执行后续操作</strong>。整体流程是：</p>
<ol>
<li>用户线程调用read, kernel执行IO准备阶段，这个过程不阻塞用户线程。</li>
<li>数据就绪后内核给用户线程发signal。 </li>
<li>当用户调用read, kernel执行数据拷贝操作，<strong>用户线程阻塞直到数据读取完成</strong>。kernel读取数据完成后，返回给用户数据。 </li>
</ol>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。这样避免了用户线程进行不断轮询的操作。</p>
<div align="center"> <img src="../images/15276920363669.jpg" width="500"> </div>


<h3 id="5）异步IO（Asynchronous-I-O）"><a href="#5）异步IO（Asynchronous-I-O）" class="headerlink" title="5）异步IO（Asynchronous I/O）"></a>5）异步IO（Asynchronous I/O）</h3><div align="center"> <img src="../images/15264350580615.jpg" width="500"> </div>

<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以<strong>不会对用户进程产生任何block</strong>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<strong>当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了</strong>。 </p>
<p>和同步方式不同，kernel的数据准备好以后不需要用户进程再次发送拷贝指令并阻塞等待kernel拷贝完成。</p>
<h2 id="Java-IO-分类"><a href="#Java-IO-分类" class="headerlink" title="Java IO 分类"></a>Java IO 分类</h2><ul>
<li><p><strong>Java BIO</strong>： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 </p>
</li>
<li><p><strong>Java NIO</strong> ： 同步非阻塞，服务器实现模式为一个请求一个线程，即当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。</p>
</li>
<li><p><strong>Java AIO(NIO.2)</strong> ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
</li>
</ul>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><strong>同步</strong>:指的是用户进程触发IO操作需要等待或者轮询的去查看IO操作执行完成才能执行其他操作.这种方式性能比较差，只有一些对数据安全性要求比较高的场景中才会使用．</li>
<li><strong>异步</strong>:异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）</li>
<li><strong>阻塞</strong>：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止</li>
<li><strong>非阻塞</strong>：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待</li>
</ul>
<h2 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h2><p>在JDK 1.4推出Java NIO之前，基于Java的所有Socket通信都采用了同步阻塞模式（BIO），<strong>这种一请求一应答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈</strong>。当并发访问量增大、响应时间延迟增大之后，采用Java BIO开发的服务端软件只有通过硬件的不断扩容来满足高并发和低时延，它极大地增加了企业的成本，并且随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战，只能通过采购性能更高的硬件服务器来解决问题，这会导致恶性循环,传统采用BIO的Java Web服务器如下所示（典型的如Tomcat的BIO模式）：</p>
<div align="center"> <img src="../images/15263490496683.jpg" width="600"> </div>


<p>采用该线程模型的服务器调度特点如下：</p>
<ol>
<li>服务端监听线程Acceptor负责客户端连接的接入，每当有新的客户端接入，就会创建一个新的I/O线程负责处理Socket</li>
<li>客户端请求消息的读取和应答的发送，都有I/O线程负责</li>
<li>除了I/O读写操作，默认情况下业务的逻辑处理，例如DB操作等，也都在I/O线程处理</li>
<li>I/O操作采用同步阻塞操作，读写没有完成，I/O线程会同步阻塞</li>
</ol>
<p>BIO线程模型主要存在如下三个问题：</p>
<ol>
<li><strong>性能问题</strong>：一连接一线程模型导致服务端的并发接入数和系统吞吐量受到极大限制</li>
<li><strong>可靠性问题</strong>：由于I/O操作采用同步阻塞模式，当网络拥塞或者通信对端处理缓慢会导致I/O线程被挂住，阻塞时间无法预测</li>
<li><strong>可维护性问题</strong>：I/O线程数无法有效控制、资源无法有效共享（多线程并发问题），系统可维护性差</li>
</ol>
<h2 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h2><ul>
<li>BIO方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器<strong>资源要求比较高</strong>，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 </li>
</ul>
<h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><ol>
<li>面向流与面向缓冲.</li>
</ol>
<p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。</p>
<ol start="2">
<li>阻塞与非阻塞IO</li>
</ol>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<ol start="3">
<li>选择器（Selectors）</li>
</ol>
<p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<h1 id="五、JVM"><a href="#五、JVM" class="headerlink" title="五、JVM"></a>五、JVM</h1><p>虚拟机面试一般包含以下几个知识点：</p>
<ul>
<li>JVM内存划分</li>
<li>JVM垃圾回收，垃圾回收可从几个点出发：<ul>
<li>什么对象需要回收</li>
<li>什么时候回收</li>
<li>怎么回收<ul>
<li>垃圾回收算法</li>
<li>垃圾收集器</li>
</ul>
</li>
</ul>
</li>
<li>如何使用工具观察和解决虚拟机问题</li>
<li>参数调优</li>
<li>类加载机制<ul>
<li>加载过程</li>
<li>双亲委派原理<ul>
<li>执行引擎</li>
</ul>
</li>
<li>动态委派和静态委派。这里涉及到java多态的概念。   </li>
</ul>
</li>
</ul>
<h2 id="介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明"><a href="#介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明" class="headerlink" title="介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明"></a>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</h2><ul>
<li><p><strong>程序计数器</strong>：看做当前线程所执行的<strong>字节码行号指示器</strong>。是线程<strong>私有</strong>的内存，且唯一一块不报OutOfMemoryError异常的内存区域。</p>
</li>
<li><p><strong>Java虚拟机栈</strong>：用于描述java方法的<strong>内存模型</strong>：每个方法被执行时都会同时创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的深度就报StackOverflowError, 如果虚拟机栈可以动态<strong>扩展</strong>，当拓展时无法申请到足够的内存会抛出OutOfMemoryError. 是线程<strong>私有</strong>的。</p>
</li>
<li><p><strong>本地方法栈</strong>：与虚拟机栈相似，不同的在于它是为虚拟机使用到<strong>Native</strong>方法服务的。会抛出StackOverflowError和OutOfMemoryError。是线程<strong>私有</strong>的。</p>
</li>
<li><p><strong>Java堆</strong>: 是所有线程共享的一块内存，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。如果堆上没有内存完成实例的分配就会报OutOfMemoryError.</p>
</li>
<li><p><strong>方法区（永久代）</strong>：用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。是共享内存。</p>
</li>
<li><p><strong>运行时常量池</strong>：用于存放编译器生成的各种字面量和符号引用，是方法区的一部分。无法申请内存时抛出OutOfMemoryError。</p>
</li>
<li><p><strong>直接内存</strong>：不是虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的区域，是计算机直接的内存空间。这部分也被频繁使用，如JAVA NIO的引入基于通道和缓存区的I/O使用native函数直接分配堆外内存。如果内存不足会报OutOfMemoryError。</p>
</li>
</ul>
<h2 id="GC的两种判定方法：引用计数与根搜索算法"><a href="#GC的两种判定方法：引用计数与根搜索算法" class="headerlink" title="GC的两种判定方法：引用计数与根搜索算法"></a>GC的两种判定方法：引用计数与根搜索算法</h2><ul>
<li><p><strong>引用计数</strong>： 给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1，当引用失效时，计数器值减1,。任何时候计数器都为0的对象就是不可能再被使用的。它很难解决对象之间相互<strong>循环引用</strong>问题。</p>
</li>
<li><p><strong>根搜索算法（GC Roots Traceing）:</strong> 通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。</p>
<p>GC Roots对象一般是：虚拟机栈中的引用对象，方法区中类静态属性引用的对象，方法区常量引用的对象等。</p>
</li>
</ul>
<h2 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。</p>
<ul>
<li><p><strong>强引用</strong>：程序代码中的普通引用。如Object obj = new Object(),只要强引用存在，垃圾回收器就不会回收。在不使用对象时应及时将引用设置为null，便于垃圾回收。</p>
</li>
<li><p><strong>软引用</strong>：描述一些有用但并非必须的对象。对于软引用关联的对象在系统将要<strong>发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第二次回收。<strong>SoftRefence</strong></p>
</li>
<li><p><strong>弱引用</strong>：描述非必须对象，比软引用弱一些。被弱引用关联的对象只能<strong>生存到下一次垃圾收集发生之前</strong>。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<strong>WeakRefence</strong></p>
</li>
<li><p><strong>虚引用</strong>：最弱的引用，不管是否有虚引用存在，完全不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的是希望能够在这个对象被垃圾回收器之前收到系统通知。<strong>PhantomReference</strong></p>
</li>
</ul>
<p>相关参考：<a href="https://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p>
<h2 id="对象创建方法，对象的内存分配，对象的访问定位。"><a href="#对象创建方法，对象的内存分配，对象的访问定位。" class="headerlink" title="对象创建方法，对象的内存分配，对象的访问定位。"></a>对象创建方法，对象的内存分配，对象的访问定位。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br></pre></td></tr></table></figure>

<p>obj 保存在java栈中的局部变量表里，作为一个引用数据出现。 New Object()会在java堆上分配一块存储Object类型实例的所有数值的结构化内存，根据类型以及虚拟机实现的对象内存布局不同。这块内存是不固定的。</p>
<p>对象访问方式有两种：<strong>句柄和直接指针</strong>。</p>
<ul>
<li><p><strong>句柄</strong>：在java堆中会划分出一块内存作为句柄池，reference中存储的对象是句柄地址。<strong>而句柄中包含对象实例数据和类型数据各自的具体地址信息</strong>。最大的好处是如果对象地址发生变化不需要改变reference的值，只需要改变句柄中实例数据指针。</p>
</li>
<li><p><strong>直接指针访问</strong>：reference直接存储对象的地址，最大的好处是<strong>速度更快</strong>。</p>
</li>
</ul>
<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><ul>
<li><p><strong>内存溢出</strong>：通俗理解就是<strong>内存不够</strong>，程序所需要的内存远远超出了你虚拟机分配的内存大小，就叫内存溢出</p>
</li>
<li><p><strong>内存泄露</strong>：内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在<strong>使用完毕后未释放</strong>，结果导致<strong>一直占据该内存单元</strong>。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏</p>
</li>
</ul>
<h2 id="内存溢出了怎么办"><a href="#内存溢出了怎么办" class="headerlink" title="内存溢出了怎么办"></a>内存溢出了怎么办</h2><p>通过内存映像工具如jhat、jconsole等对dump出来的堆转存储快照进行分析，重点是确认内存是出现内存泄露还是内存溢出。</p>
<p>如果是<strong>内存泄露</strong>进一步使用工具查看泄露的对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握泄露对象的信息，以及GC Roots引用链的信息，就可以比较准确定位泄露代码的位置。</p>
<p>如果不存在<strong>内存泄露</strong>，那就需要通过jinfo、Jconsole等工具分析java堆参数与机器物理内存对比是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态过长的情况，尝试减少程序的运行消耗。</p>
<h2 id="Java-中有内存泄露吗？"><a href="#Java-中有内存泄露吗？" class="headerlink" title="Java 中有内存泄露吗？"></a>Java 中有内存泄露吗？</h2><p>有，Java中，造成内存泄露的原因有很多种。典型的例子是<strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</p>
<p>检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。（采用什么工具？）</p>
<p><strong>如果一个外部类的实例对象的方法返回了一个内部类的实例对象</strong>，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p>
<p><a href="http://www.mamicode.com/info-detail-504269.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-504269.html</a></p>
<h2 id="什么时候会发生jvm堆（持久区）内存溢出"><a href="#什么时候会发生jvm堆（持久区）内存溢出" class="headerlink" title="什么时候会发生jvm堆（持久区）内存溢出"></a>什么时候会发生jvm堆（持久区）内存溢出</h2><p>简单的来说 java的堆内存分为两块:permantspace（持久代） 和 heap space。</p>
<p>持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。</p>
<p>而heapspace分为年轻代和年老代:</p>
<ul>
<li>年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。</li>
<li>在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象</li>
<li>年老代溢出原因有  循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存</li>
</ul>
<p><strong>持久代溢出原因动态加载了大量Java类而导致溢出，以及生产大量的常量</strong>。 </p>
<p><strong>永久代内存泄露</strong>: 以一个部署到应用程序服务器的Java web程序来说，当该应用程序被卸载的时候，你的EAR/WAR包中的所有类都将变得无用。只要应用程序服务器还活着，JVM将继续运行，但是一大堆的类定义将不再使用，理应将它们从永久代（PermGen）中移除。如果不移除的话，我们在永久代（PermGen）区域就会有内存泄漏。</p>
<h2 id="堆里面的分区：Eden，survivor-from-to，老年代，各自的特点。"><a href="#堆里面的分区：Eden，survivor-from-to，老年代，各自的特点。" class="headerlink" title="堆里面的分区：Eden，survivor from to，老年代，各自的特点。"></a>堆里面的分区：Eden，survivor from to，老年代，各自的特点。</h2><p>新生代：朝生夕死</p>
<p>老年代一般是放对象和长期存活对象。当一个对象分配的内存空间大于某个阈值时或则年龄增加到一定程度（默认15岁）就进入老年代。</p>
<h2 id="OOM你遇到过哪些情况"><a href="#OOM你遇到过哪些情况" class="headerlink" title="OOM你遇到过哪些情况"></a>OOM你遇到过哪些情况</h2><ul>
<li><p>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。 </p>
</li>
<li><p>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，<strong>一般出现于大量Class或者jsp页面</strong>，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。 </p>
</li>
<li><p>java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在<strong>死循环或者深度递归调用</strong>造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数<strong>-Xss</strong>来设置栈的大小。</p>
</li>
</ul>
<h2 id="GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h2><ul>
<li><p><strong>标记清理</strong>：首先标记所有需要回收的对象，在标记完成后<strong>统一回收掉</strong>所有被标记的对象，它的标记的对象。缺点是<strong>效率低</strong>，且存在<strong>内存碎片</strong>。主要用于老生代垃圾回收。</p>
</li>
<li><p><strong>标记整理</strong>：首先标记所有需要回收的对象，在标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。用于老年代。</p>
</li>
<li><p><strong>复制算法</strong>：将内存按容量划分为大小相等的一块，每次只用其中一块。当内存用完了，将还存活的对象复制到另一块内存，然后把已使用过的内存空间一次清理掉。实现简单，高效。一般用于新生代。一般是将内存分为一块较大的<strong>Eden空间</strong>和两块较小的<strong>Survivor</strong>空间。HotSpot虚拟机默认比例是<strong>8:1</strong>,。每次使用Eden和一块Survivor，当回收时将这两块内存中还存活的对象复制到Survivor然后清理掉刚才Eden和Survivor的空间。如果复制过程内存不够使用则向老年代分配担保。</p>
</li>
<li><p><strong>分代收集算法</strong>：根据对象的生存周期将内存划分为新生代和老年代，根据年代的特点采用最适当的收集算法。</p>
</li>
</ul>
<h2 id="GC收集器有哪些？CMS收集器与G1收集器的特点。"><a href="#GC收集器有哪些？CMS收集器与G1收集器的特点。" class="headerlink" title="GC收集器有哪些？CMS收集器与G1收集器的特点。"></a>GC收集器有哪些？CMS收集器与G1收集器的特点。</h2><ul>
<li><p><strong>Serial</strong>: 单线程收集器，只会使用一个CPU或一条收集器线程去完成，垃圾回收工作，更重要的是在进行垃圾回收时，必须暂停其他所有的工作线程。（Stop the world）。简单高效，用于新生代。</p>
</li>
<li><p><strong>ParNew</strong>: 是Serial收集器的<strong>多线程版本</strong>，垃圾回收时采用多线程方式进行回收。默认情况下使用的线程数是cpu数量。除了serial收集器，目前只有它能和CMS收集器配合工作。是server模式下首选的新生代收集器。</p>
</li>
<li><p><strong>Parallel Scavenge</strong>: 使用<strong>复制算法</strong>收集器，也是一个并行的多线程收集器。Parallel Scavenge收集器与其他收集器关注点不同，其它收集器主要关注缩短垃圾回收时用户线程的停顿时间。而它关心<strong>吞吐量</strong>，即<strong>运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)</strong>。停顿时间越短越适合需要与用户交互的程序，高吞吐量则可以最高效率的利用CPU时间。</p>
</li>
<li><p><strong>Serial Old</strong>: 老年代，单线程收集器，使用<strong>标记整理算法</strong>。主要有两个用途，一是和Parallel Scavenge 收集器配合使用，二是作为CMS的后备方案在并发收集器发生<strong>Concurrent Mode Failure</strong>时候使用。</p>
</li>
<li><p><strong>Parallel Old</strong>:并行的老年代版本收集器，使用标记整理算法。主要与Parallel Scavenge配合使用。</p>
</li>
<li><p><strong>CMS</strong>：是以获得<strong>最短回收停顿时间为</strong>目标的收集器，使用<strong>标记清除算法</strong>。整个过程包括4个：</p>
<ul>
<li><strong>初始标记</strong>: 标记Gc ROOTS能直接关联到的对象</li>
<li><strong>并发标记</strong>：进行Roots Traceing的过程</li>
<li><strong>重新标记</strong>：修正并发标记期间因用户继续工作导致标记产生变动</li>
<li><strong>并发清除</strong>：并发清除数据。<br>初始标记和重新标记需要stop the world. 并发标记和并发清除过程用户线程和收集器线程可以并行执行。</li>
</ul>
</li>
<li><p><strong>G1(Garbage First):</strong> 基于<strong>标记-整理算法</strong>的收集器,不会产生空间碎片.它可以精确控制停顿,能够让使用者明确指定一个长度为M毫秒的时间片段内,消耗集上的时间不超过N秒.是不牺牲吞吐量的前提下完成低停顿的.<strong>G1将整个java堆(新生和老生)划分为大小相同的区,并跟踪这些区上发生的变化.在后台维护一个优先列表,每次根据允许的收集时间优先回收垃圾最多的区域</strong>.</p>
</li>
</ul>
<p>现在公司中很多都采用了G1 垃圾回收期，建议大家多深入了解下G1，更多参考: <a href="./G1垃圾回收器.md">G1垃圾回收器</a></p>
<h2 id="Minor-GC与Full-GC分别在什么时候发生？"><a href="#Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="Minor GC与Full GC分别在什么时候发生？"></a>Minor GC与Full GC分别在什么时候发生？</h2><p>FullGC 一般是发生在老年代的GC，出现一个FullGC经常会伴随至少一次的Minor GC。速度比MinorGC慢10倍以上。</p>
<h3 id="FUll-GC"><a href="#FUll-GC" class="headerlink" title="FUll GC"></a>FUll GC</h3><p>FULL GC发生的情况:</p>
<ul>
<li><strong>1) 老年代空间不足</strong><br>老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space.</li>
</ul>
<p>措施:为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组</p>
<ul>
<li><p><strong>2) Permanet Generation(方法区或永久代)空间满</strong><br>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space </p>
<p>措施:为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
</li>
<li><p><strong>3) CMS GC时出现promotion failed和concurrent mode failure</strong><br>对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；</p>
<p>concurrent mode failure: CMS在执行垃圾回收时需要一部分的内存空间并且此刻用户程序也在运行需要预留一部分内存给用户程序，如果预留的内存无法满足程序需求就出现一次”Concurrent mod failure”,并触发一次Full GC。</p>
<p>应对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，</p>
</li>
<li><p><strong>4) 空间分配担保</strong><br>统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，Hotspot为了避免由于新生代对象晋升到老年代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断。如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发Full GC。如果小于并且不允许担保失败也会发生一次Full GC。</p>
</li>
</ul>
<h3 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h3><p>MinorGC 指发生在新生代的垃圾收集动作，非常频繁，回收速度也快。一般发生在新生代空间不足时,另外一个FullGC经常会伴随至少一次的Minor GC. 当虚拟检测晋升到到老年代的平均大小是否小于老年代剩余空间大小,如果小于并且允许担保失败,则执行Minor GC.</p>
<h2 id="几种常用的内存调试工具：jmap、jstack、jconsole。"><a href="#几种常用的内存调试工具：jmap、jstack、jconsole。" class="headerlink" title="几种常用的内存调试工具：jmap、jstack、jconsole。"></a>几种常用的内存调试工具：jmap、jstack、jconsole。</h2><p>(如何用工具分析jvm状态)</p>
<ul>
<li><strong>jps</strong>: 列出正在虚拟机运行的虚拟机进程，并显示虚拟机执行主类的名称，以及这些进程的本地虚拟机的唯一ID。</li>
<li><strong>jstat</strong> : 监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中<strong>类装载、垃圾收集、JIT编译、内存</strong>等数据。</li>
<li><strong>jinfo</strong>: 实时查看和调整虚拟机的各项参数。</li>
<li><strong>jmap</strong>: 生成<strong>堆转存储快照</strong>，查询fianlize执行队列、java堆和永生代详细信息，如空间使用率，当前用的是那种收集器。</li>
<li><strong>Jhat</strong>: 和jmap搭配使用，来分析jmap生成的堆转存储快照。内置一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以通过浏览器查看。</li>
<li><strong>jstack</strong>:用于生成当前时刻<strong>线程快照</strong>.线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合.生成线程快照的主要目的是为了定位线程长时间停顿的原因.如死锁、死循环、请求外部资源导致的长时间等待.</li>
<li><strong>JConsole</strong>: 可视化监视和管理工具,几乎包括以上工具的所有功能</li>
<li><strong>VisualVM</strong></li>
</ul>
<h2 id="GC-是什么？为什么要有-GC"><a href="#GC-是什么？为什么要有-GC" class="headerlink" title="GC 是什么？为什么要有 GC"></a>GC 是什么？为什么要有 GC</h2><p>GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显示的垃圾回收调用。</p>
<p>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。</p>
<h2 id="JVM-加载-class-文件的原理机制"><a href="#JVM-加载-class-文件的原理机制" class="headerlink" title="JVM 加载 class 文件的原理机制"></a>JVM 加载 class 文件的原理机制</h2><p>JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<p>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的 .class 文件中的数据读入到内存中，通常是创建一个字节数组读入 .class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后 JVM 对类进行初始化，包括：</p>
<ol>
<li>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；</li>
<li>如果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ol>
<p>类的加载是由类加载器完成的，类加载器包括：<strong>启动类加载器（BootStrap）、扩展加载器（Extension）、应用程序加载器（Application）和用户自定义类加载器（java.lang.ClassLoader的子类）</strong>。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：</p>
<ul>
<li><strong>Bootstrap</strong>：启动类加载器，一般用本地代码实现，负责加载JVM基础核心类库。加载存放在<java_home>/lib目录中的类库（如rt.jar）；</java_home></li>
<li><strong>Extension ClassLoader</strong>：扩展加载器， 负责加载<java_home>/lib/ext目录中的<br>，或被java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；</java_home></li>
<li><strong>Application ClassLoader</strong>：应用程序加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
<p>缺点: </p>
<ul>
<li>双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码时，双亲委派模型无法满足要求。 因为Bootstrap加载器无法找到永不代码类。</li>
</ul>
<p>为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文件类加载器(Thread Context ClassLoader)</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。<strong>Java中所有涉及SPI的加载动作基本上都采用这种方式</strong>，例如JNDI,JDBC,JCE,JAXB和JBI等。 Dubbo的SPI也是采用这种机制实现。</p>
<h2 id="类加载的五个过程：加载、验证、准备、解析、初始化。"><a href="#类加载的五个过程：加载、验证、准备、解析、初始化。" class="headerlink" title="类加载的五个过程：加载、验证、准备、解析、初始化。"></a>类加载的五个过程：加载、验证、准备、解析、初始化。</h2><ul>
<li><p><strong>加载</strong>: 根据全限定名来获取定义类的二进制字节流,然后将该字节流所代表的静态结构转化为方法区的运行时数据结构,最后在生成一个代表该类的Class对象,作为方法区这些数据的访问入口.</p>
</li>
<li><p><strong>验证</strong>:主要时为了确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.包含四个阶段的验证过程:</p>
<ul>
<li><strong>文件格式验证</strong>:保证输入的字节流能够正确地解析并存储在方法区之内,格式上符合描述一个java类型信息的要求</li>
<li><strong>元数据验证</strong>:字节码语义信息的验证,以保证描述的信息符合java语言规范.验证点有:这个类是否有父类等.</li>
<li><strong>字节码验证</strong>:主要是进行数据流和控制流分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为.</li>
<li><strong>符号引用验证</strong>:对符号引用转化为直接引用过程的验证.</li>
</ul>
</li>
<li><p><strong>准备</strong>:为类变量分配内存并设置变量的初始值,这些内存在方法区进行分配.</p>
</li>
<li><p><strong>解析</strong>:将虚拟机常量池中的符号引用转化为直接引用的过程.解析主要是针对类或接口、字段、类方法、类接口方法四类.</p>
</li>
<li><p><strong>初始化</strong>:执行静态变量的赋值操作以及静态代码块,完成初识化.初始化过程保证了父类中定义的初始化优先于子类的初始化.但接口不需要执行父类的初始化.</p>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器.顺序依次是:</p>
<ul>
<li>Bootstrap ClassLoader: 启动类加载器,加载java_home/lib中的类</li>
<li>Extension ClassLoader: 扩展类加载器,加载java_home/lib/ext目录下的类库</li>
<li>Application ClassLoader: 应用程序类加载器,加载用户类路径上指定类库.</li>
</ul>
<p>双亲委派模型的工作原理是:如果一个类加载器受到了类加载请求,它首先不会自己去尝试加载这个类,而把这个请求委派给父类加载器去完成,每一层次的类加载器都是如此,因此所有的加载请求最终都应该传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成加载请求时,加载器才尝试自己加载.这种方式保证了Oject类(JDK 核心类)在各个加载器加载环境中都是同一个类.</p>
<h2 id="分派：静态分派与动态分派。"><a href="#分派：静态分派与动态分派。" class="headerlink" title="分派：静态分派与动态分派。"></a>分派：静态分派与动态分派。</h2><p>多态性特征的一些最基本的体现. <strong>静态类型是编译期可知的,动态类型是在运行时可知</strong>.Human h =new Man(); Human是静态类型,Man时动态类型.</p>
<p>所有依赖于静态类型定位方法执行版本的分派动作称作<strong>静态分派</strong>,最典型的应用是方法重载.静态分派发生在编译阶段。</p>
<p><strong>动态分派</strong>是根据动态类型来确定执行的版本,所以只有到运行时才能确定具体的执行方法版本.典型的代表时重写.其过程如下:</p>
<ul>
<li>1) 首先找到操作数栈栈顶的第一个元素所执向对象的实际类型,记做C.</li>
<li>2) 如果在类型C中找到和常量中的描述符和简单名称都相符的方法,则进行范围权限校验.如果通过则返回该方法的直接引用,否则抛出IllegalAccessError异常.</li>
<li>3) 否则按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程.</li>
<li>4) 如果始终没有找到就抛出AbstractMethodError异常.<br>方法的接受者和方法的参数统称方法宗量,根据分配基于多少中宗量可以分为单分派和多分派.java是静态多分派,动态分派属于单分派.</li>
</ul>
<p><strong>动态分派的实现:</strong><br>动态分派时非常频繁的动作,而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法,因此出于性能的考虑,在方法区中建立一个<strong>虚方法表</strong>,用来保存各个方法的实际入口地址.如果某个方法的子类中没有被重写,那么子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的.都是指向父类的实现入口,如果子类中重写了这个方法,子类方法表中的地址将会被替换为指向子类实现版本的入口地址.虚方法表在类加载的连接阶段进行初始化.</p>
<h2 id="Jvm-自动内存管理（什么时候触发-gc-）"><a href="#Jvm-自动内存管理（什么时候触发-gc-）" class="headerlink" title="Jvm 自动内存管理（什么时候触发 gc ）"></a>Jvm 自动内存管理（什么时候触发 gc ）</h2><p><a href="http://jeromecen1021.blog.163.com/blog/static/18851527120117274624888/" target="_blank" rel="noopener">http://jeromecen1021.blog.163.com/blog/static/18851527120117274624888/</a><br>FULL GC 和 Minor GC 的触发时间<br>程序员不能具体控制时间，系统在不可预测的时间调用System.gc()函数的时候；当然可以通过调优，用NewRatio控制newObject和oldObject的比例，用MaxTenuringThreshold 控制进入oldObject的次数，使得oldObject 存储空间延迟达到full gc,从而使得计时器引发gc时间延迟OOM的时间延迟，以延长对象生存期。</p>
<h2 id="GC停顿原因，如何降低停顿"><a href="#GC停顿原因，如何降低停顿" class="headerlink" title="GC停顿原因，如何降低停顿"></a>GC停顿原因，如何降低停顿</h2><h2 id="JVM如何调优、参数怎么调"><a href="#JVM如何调优、参数怎么调" class="headerlink" title="JVM如何调优、参数怎么调"></a>JVM如何调优、参数怎么调</h2><h2 id="jvm的体系结构及各个部分的职责"><a href="#jvm的体系结构及各个部分的职责" class="headerlink" title="jvm的体系结构及各个部分的职责"></a>jvm的体系结构及各个部分的职责</h2><p>JVM都有两种机制，一个是装载具有合适名称的类(类或是接口)，包含类的装载 连接 初始化的过程叫做<strong>类装载子系统</strong>；另外的一个负责执行包含在已装载的类或接口中的指令，叫做<strong>运行引擎</strong>。每个JVM又包括方法区、堆、Java栈、程序计数器和本地方法栈这五个部分，这几个部分和类装载机制与运行引擎机制一起组成的体系结构图为:</p>
<img src="../images/15268031792473.jpg" width="340px">

<ul>
<li>JVM的每个实例都有一个它自己的方法域和一个堆，运行于JVM内的所有的线程都共享这些区域；</li>
<li>当虚拟机装载类文件的时候，它解析其中的二进制数据所包含的类信息，并把它们放到方法域中；</li>
<li>当程序运行的时候，JVM把程序初始化的所有对象置于堆上；</li>
<li>而每个线程创建的时候，都会拥有自己的程序计数器和Java栈，其中程序计数器中的值指向下一条即将被执行的指令，线程的Java栈则存储为该线程调用Java方法的状态；</li>
<li>本地方法调用的状态被存储在本地方法栈，该方法栈依赖于具体的实现。</li>
</ul>
<p><a href="http://blog.csdn.net/dongdong_java/article/details/24797307" target="_blank" rel="noopener">http://blog.csdn.net/dongdong_java/article/details/24797307</a><br><a href="http://blog.csdn.net/longyulu/article/details/8350622" target="_blank" rel="noopener">http://blog.csdn.net/longyulu/article/details/8350622</a></p>
<h2 id="如果想不被-GC-怎么办"><a href="#如果想不被-GC-怎么办" class="headerlink" title="如果想不被 GC 怎么办"></a>如果想不被 GC 怎么办</h2><p>可以先说那些对象可以被GC,然后说java对象会不会回收，决定于是否还被引用，不被引用了就有可能被GC回收，一直被引用着就不会被回收. </p>
<ol start="2">
<li>jvm性能调优都做了什么</li>
<li>介绍GC 和GC Root不正常引用。</li>
<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>
<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>
<li>老年代中数组的访问方式</li>
<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>
<li>jvm 如何分配直接内存??</li>
<li>new 对象如何不分配在堆而是栈上?</li>
<li>常量池解析</li>
</ol>
<h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="Student-s-new-Student-在内存中做了那些事情"><a href="#Student-s-new-Student-在内存中做了那些事情" class="headerlink" title="Student s= new Student(),在内存中做了那些事情"></a>Student s= new Student(),在内存中做了那些事情</h2><ol>
<li>加载Student.class 文件进内存</li>
<li>在栈内存为s开辟空间</li>
<li>在堆内存为Student对象开辟空间</li>
<li>学生对象的成员变量进行显示初始化</li>
<li>通过构造方法对学生对象变量赋值</li>
<li>学生对象初始完毕，把对象地址赋值给s变量</li>
</ol>
<h2 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h2><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>表示初始堆大小</td>
<td>默认为物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小(1.4or lator)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1/64</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4</td>
<td></td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话-Xss is translated in a VM flag named ThreadStackSize一般设置这个值就可以了。</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>=4表示年轻代与年老代所占比值为1:4, 年轻代占整个堆栈的1/5 Xms = Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄</td>
<td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效.</td>
<td></td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0    单位字节</td>
<td>新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
</tbody></table>
<h1 id="六、thread"><a href="#六、thread" class="headerlink" title="六、thread"></a>六、thread</h1><h2 id="什么叫线程安全？举例说明"><a href="#什么叫线程安全？举例说明" class="headerlink" title="什么叫线程安全？举例说明"></a>什么叫线程安全？举例说明</h2><p>多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。<br>比如无状态对象一定是线程安全的。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>调度: 线程是调度的基本单位，进程是拥有资源的基本单位。同一进程的中线程的切换不会引起进程的切换，不同进程中进行线程切换会引起进程的切换。</p>
<p>拥有资源：进程是拥有资源的基本单位，线程除了自身的栈外一般不拥有资源。而是和其他线程共享同一进程中的资源。</p>
<p>系统开销：由于创建进程或者撤销进程时，系统都要分配和回收资源，如内存空间，I/O设备等，操作系统所付出的开销远大于创建或撤销进程时的开销。</p>
<h2 id="volatile的理解"><a href="#volatile的理解" class="headerlink" title="volatile的理解"></a>volatile的理解</h2><p><strong>Volatile自身特性</strong>：</p>
<ol>
<li>Volatile 是轻量级的synchronized，它在多处理器开发过程中保证了共享变量的“<strong>可见性</strong>”，可见性是指当一个线程的某个共享变量发生改变时，另一个线程能够读取到这个修改的值。Voaltile变量修饰的变量在进行写操作时在多核处理器下首先将当前处理器缓存行的数据写回到系统内存中。为了保证一致性，其他处理器嗅探到总线上传播的数据，发现数据被修改了使自己缓存地址的数据无效。</li>
<li>Volatile 可以<strong>禁止重排序</strong>，</li>
<li>Volatile 能保持单个简单volatile变量的读/写操作的具有原子性。但不能保证自增自减的<strong>原子性</strong>。</li>
</ol>
<p>从<strong>内存语义</strong>来讲:</p>
<ul>
<li>volatile变量的写-读与锁的释放-获取具有相同语义，volatile的写与锁的释放有相同的内存语义，volatile读与锁的获取具有相同语义。</li>
<li>线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出消息</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的消息。</li>
<li>线程A写volatile变量，随后线程B读这个变量，这个过程实质上线程A通过内存向B发送消息。</li>
</ul>
<p>内存语义的实现，也是禁止重排序特性：<br>为了实现volatile内存语义，JMM限制了对volatile重排序做了限制：</p>
<ol>
<li>当第二个操作是volatile写时，不管第一个操作时什么，都不能重排序。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不重排序。</li>
</ol>
<p>为了实现volatile的内存语义，编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。JMM采取保守策略:</p>
<ol>
<li>在每个volatile写操作前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作后面插入一个LoadStore屏障</li>
</ol>
<p>具体参考《java并发编程的艺术》</p>
<h2 id="原子性实现机制"><a href="#原子性实现机制" class="headerlink" title="原子性实现机制"></a>原子性实现机制</h2><p>处理器提供总线锁定和缓存锁定两种方式来保证复杂内存操作的原子性。</p>
<ul>
<li><p>总线型：就是使用处理器提供一个LOCK信号，当一个处理器在总线传输信号时，其他处理器的请求将被阻塞住，那么该处理独占内存。所以总线锁定开销大。</p>
</li>
<li><p>缓存锁定：内存区域如果被缓存在缓存行中，且在在lock期间被锁定，当它执行锁操作写回内存时，处理器总线不在锁定而是通过修改内部的内存地址并使用缓存一致性制阻止同时修改保证操作的原子性。缓存一致性进制两个以上的处理器同时修改内存区域数据，其他处理器回写被锁定并且使其缓存行无效。</p>
</li>
</ul>
<h2 id="Java原子性操作实现原理"><a href="#Java原子性操作实现原理" class="headerlink" title="Java原子性操作实现原理"></a>Java原子性操作实现原理</h2><p>使用循环CAS实现原子性操作，CAS是在操作期间先比较旧值，如果旧值没有发生改变，才交换成新值，发生了变化则不交换。这种方式会产生以下几种问题：</p>
<ol>
<li>ABA问题，通过加版本号解决；</li>
<li>循环时间过长开销大，一般采用自旋方式实现；</li>
<li>只能保证一个共享变量的原子操作。 </li>
</ol>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型控制线程之间的通信，决定了一个线程对共享变量的写入何时对另一个线程可见。它属于语言级的内存模型，它确保在不同编译器和不同的处理平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。JMM的核心目标是找到一个好的平衡点，一方面是为程序员提供足够强的内存可见性保证（提供happens-before规则），另一方面对编译器和处理器的限制尽可能地放松（只要不改变程序结果，怎么优化都可以）</p>
<p>1) <strong>可见性保证</strong></p>
<p>为了提供内存可见性保证，JMM向程序员保证了以下hapens-before规则:</p>
<ol>
<li><strong>程序顺序规则</strong>：一个线程的每个操作happen-before与该线程的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：一个锁的解锁，happens-before于随后这个锁的加锁。</li>
<li><strong>Volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续这个域的读。</li>
<li><strong>传递性</strong>, 如果A happens-before B, 且B happens-before C 那么A happens-before C</li>
<li><strong>线程启动规则</strong>：如果线程A执行操作ThreadB.start().那么线程A中的任意操作happens-before与线程B中的任意操作。</li>
<li><strong>线程结束规则</strong>: 线程中的任何操作都必须在其线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者在调用Thread.isAlive时返回false.</li>
<li><strong>中断规则</strong>:当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行(通过抛出InterruptedException,或者调用isInterrupted和interrupted)</li>
<li><strong>终结器规则</strong>: 对象的构造函数必须在启动该对象的终结器之前执行完成。</li>
</ol>
<p><strong>2) 禁止重排序</strong></p>
<p>为了保证内存可见性，java编辑器在生成指令序列的适当位置插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<p>重排序：编译器和处理器为了优化程序性能对指令进行重新排序的一种手段。</p>
<ul>
<li>1) 编译器优化的重排序: 编译器在不改变单线程程序语义的前提下可以重新安排语句顺序。</li>
<li>2) 指令级并行的重排序.现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变对应指令的执行顺序。</li>
<li>3) 内存系统重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能在乱序执行。</li>
</ul>
<h2 id="Final域的内存语义"><a href="#Final域的内存语义" class="headerlink" title="Final域的内存语义"></a>Final域的内存语义</h2><p>对于final域编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造器函数内对final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（保证了对象引用为任何线程可见之前，对象的final域已经被正确初始化过）</li>
<li>初次读一个包含final域的对象引用，与随后初次读这个final域这两个操作不能重排序。</li>
</ol>
<p>为何保证其内存语义：可以为java程序员提供安全保证，只要对象是正确构造的，那么不需要使用同步就可以保证线程都能看到这个fianal域在构造函数中被初始化之后的值。</p>
<h2 id="避免死锁的常见方法："><a href="#避免死锁的常见方法：" class="headerlink" title="避免死锁的常见方法："></a>避免死锁的常见方法：</h2><ul>
<li>1)避免一个线程同时获取多个锁</li>
<li>2)避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>3)尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。</li>
<li>4)对数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h2 id="死锁的必要条件？怎么克服？"><a href="#死锁的必要条件？怎么克服？" class="headerlink" title="死锁的必要条件？怎么克服？"></a>死锁的必要条件？怎么克服？</h2><p>答：产生死锁的四个必要条件：</p>
<ul>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li>
<li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>死锁的解决方法:</p>
<ul>
<li>撤消陷于死锁的全部进程；</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在；</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态</li>
</ul>
<h2 id="CountDownLatch-闭锁-与CyclicBarrier-栅栏-的区别"><a href="#CountDownLatch-闭锁-与CyclicBarrier-栅栏-的区别" class="headerlink" title="CountDownLatch(闭锁) 与CyclicBarrier(栅栏)的区别"></a>CountDownLatch(闭锁) 与CyclicBarrier(栅栏)的区别</h2><p>CountDownLatch: <strong>允许一个或多个线程等待其他线程完成操作</strong>. </p>
<p>CyclicBarrier：<strong>让一组线程到达一个屏障(同步点)被阻塞，直到最后一个线程到达屏障时，所有被屏障拦截的线程才会往下执行</strong>。 </p>
<ol>
<li>闭锁用于等待事件、栅栏是等待线程.</li>
<li>闭锁CountDownLatch做减计数，而栅栏CyclicBarrier则是加计数。</li>
<li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li>
<li>CountDownLatch一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行。CyclicBarrier是N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 </li>
</ol>
<p>CountDownLatch 是<strong>计数器</strong>, 线程完成一个就记一个,就像报数一样, 只不过是递减的.</p>
<p>而CyclicBarrier更像一个<strong>水闸</strong>, 线程执行就像水流, 在水闸处都会堵住, 等到水满(线程到齐)了, 才开始泄流.</p>
<h2 id="execute-和submit的区别"><a href="#execute-和submit的区别" class="headerlink" title="execute 和submit的区别"></a>execute 和submit的区别</h2><p>Execute()用于提交不需要返回值得任务，submit()用于提交需要返回值的任务，发挥Future类型的对象。</p>
<h2 id="Shutdown和shutdownNow的区别"><a href="#Shutdown和shutdownNow的区别" class="headerlink" title="Shutdown和shutdownNow的区别"></a>Shutdown和shutdownNow的区别</h2><p>它们的原理都是遍历线程池中的工作线程，然后逐个调用线程的Internet方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<p>ShutdownNow首先将线程池的状态设置成STOP, 然后尝试停止所有正在执行或暂停的任务，并返回等待执行任务的列表。而shutdown只是将线程池设置成SHUTDOWN状态，然后中断没有正在执行任务的线程。</p>
<h2 id="ThreadLocal的设计理念与作用。"><a href="#ThreadLocal的设计理念与作用。" class="headerlink" title="ThreadLocal的设计理念与作用。"></a>ThreadLocal的设计理念与作用。</h2><p>ThreadLocal并不是一个Thread，而是Thread的局部变量, 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</p>
<p><a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">http://blog.csdn.net/lufeng20/article/details/24314381</a></p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步就是协同步调，按预定的先后次序进行运行。</p>
<h2 id="sleep-和-wait-区别"><a href="#sleep-和-wait-区别" class="headerlink" title="sleep() 和 wait() 区别"></a>sleep() 和 wait() 区别</h2><p>答：sleep()方法是<strong>线程类（Thread）的静态方法</strong>，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用 sleep <strong>不会释放对象锁</strong>。</p>
<p>wait() 是 <strong>Object 类的方法</strong>，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)，<strong>释放资源并</strong>进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</p>
<h2 id="sleep-和-yield-区别"><a href="#sleep-和-yield-区别" class="headerlink" title="sleep() 和 yield() 区别"></a>sleep() 和 yield() 区别</h2><ul>
<li>① sleep() 方法给其他线程运行机会时<strong>不考虑线程的优先级</strong>，因此会给低优先级的线程以运行的机会；yield() 方法<strong>只会给相同优先级或更高优先级</strong>的线程以运行的机会；</li>
<li>② 线程执行 sleep() 方法后转入<strong>阻塞</strong>（blocked）状态，而执行 yield() 方法后转入<strong>就绪（ready）</strong>状态；</li>
<li>③ sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常；</li>
<li>④ sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。</li>
</ul>
<h2 id="线程同步相关的方法。"><a href="#线程同步相关的方法。" class="headerlink" title="线程同步相关的方法。"></a>线程同步相关的方法。</h2><ul>
<li><strong>wait()</strong>:使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li><strong>sleep()</strong>:使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；</li>
<li><strong>notify()</strong>:唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li>
<li><strong>notityAll()</strong>:唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争；</li>
</ul>
<h2 id="什么是线程池（thread-pool）"><a href="#什么是线程池（thread-pool）" class="headerlink" title="什么是线程池（thread pool）"></a>什么是线程池（thread pool）</h2><p>在面向对象编程中，<strong>创建和销毁对象是很费时间的</strong>，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是<strong>尽可能减少创建和销毁对象的次数</strong>，特别是一些很耗资源的对象创建和销毁，这就是”<strong>池化资源</strong>“技术产生的原因。</p>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>
<h2 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h2><p>ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度以及如何锁。<br>Hashtabl在竞争激烈的环境下表现效率低下的原因是一把锁锁住整张表，导致所有线程同时竞争一个锁。ConcurrentHashMap采用<strong>分段锁</strong>，每把锁锁住容器中的一个Segment。那么多线程访问容器里不同的Segment的数据时线程就不会存在竞争，从而有效提高并发访问效率。首先是将数据分层多个Segment存储，并为每个Segment分配一把锁，当一个线程范围其中一段数据时，其他线程可以访问其他段的数据。</p>
<p>数据结构：</p>
<p>ConcurrentHashMap内部是有<strong>Segment</strong>数组和<strong>HashEntry</strong>数组组成。一个ConcurrentHashMap里包含一个Segment数组，而Segment的结构和HashMap一样，里面是由一个数组和链表结构组成，所以一个Segment内部包含一个HashEntry数组。每个HashEntry是一个链表结构，对于HashEntry数组进行修改时首先需要获取与它对应的Segment锁。默认情况下有16个Segment</p>
<p>Segment的定位:</p>
<p>使用Wang/Jenkins hash变种算法对元素的hashCode进行一次再散列，目的是为了减少散列冲突。</p>
<p>ConcurrentHashMap的操作:</p>
<ul>
<li>get</li>
</ul>
<p>get操作实现非常简单高效。先经过一次<strong>再散列</strong>，然后用这个散列值通过散列运算定位到Segment，<strong>再通过散列算法定位到元素</strong>。get之所以高效是因为整个get过程不需要加锁，除非读到空值才会加锁重读。实现该技术的技术保证是保证<strong>HashEntry是不可变的</strong>。</p>
<p>第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count 变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。接下来就是根据hash和key对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。</p>
<p>对hash链进行遍历<strong>不需要加锁的原因在于链指针next是final的、entry是不可变类</strong>。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在 table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。</p>
<ul>
<li>put</li>
</ul>
<p>该方法也是在持有段锁(锁定当前segment)的情况下执行的，这当然是为了并发的安全，修改数据是不能并发进行的，必须得有个判断是否超限的语句以确保容量不足时能够rehash。首先根据计算得到的散列值定位到segment及该segment中的散列桶中。接着判断是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。</p>
<ul>
<li>remove<br>HashEntry中除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next 引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。</li>
</ul>
<p>首先定位到要删除的节点e。如果不存在这个节点就直接返回null，否则就要将e前面的结点复制一遍，尾结点指向e的下一个结点。e后面的结点不需要复制，它们可以重用。</p>
<ul>
<li>size()<br>每个Segment都有一个count变量，是一个volatile变量。当调用size方法时，首先先尝试2次通过不锁住segment的方式统计各个Segment的count值得总和，如果两次值不同则将锁住整个ConcurrentHashMap然后进行计算。</li>
</ul>
<p>参见《java并发编程的艺术》P156<br><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3948786.html</a></p>
<h2 id="线程的几种可用状态"><a href="#线程的几种可用状态" class="headerlink" title="线程的几种可用状态"></a>线程的几种可用状态</h2><p>线程在运行周期里有6中不同的状态：</p>
<ol>
<li>New 新建</li>
<li>RUNNABLE 运行状态,操作系统中运行与就绪两种状态统称运行中</li>
<li>BLOCKED 阻塞状态</li>
<li>WAITING    等待状态</li>
<li>TIME_WAITING 超时等待</li>
<li>TERMINATED    终止状态</li>
</ol>
<h2 id="同步方法和同步代码块的区别是什么"><a href="#同步方法和同步代码块的区别是什么" class="headerlink" title="同步方法和同步代码块的区别是什么"></a>同步方法和同步代码块的区别是什么</h2><ol>
<li><p>同步方法只能锁定当前对象或class对象， 而同步方法块可以使用其他对象、当前对象及当前对象的class作为锁。</p>
</li>
<li><p>从反编译后的结果看，对于同步块使用了<strong>monitorenter</strong>和<strong>monitorexit</strong>指令，而同步方法则是依靠方法上的修饰符<strong>ACC_SYNCHRONIZED</strong>来完成，但它们的本质都是对一个对象监视器进行获取，而这个获取过程是排他的。这一步执行时会由用户态切换到内核态,所以又称之为重量级锁.</p>
</li>
</ol>
<h3 id="显示锁ReentrantLock与内置锁synchronized的相同与区别"><a href="#显示锁ReentrantLock与内置锁synchronized的相同与区别" class="headerlink" title="显示锁ReentrantLock与内置锁synchronized的相同与区别"></a>显示锁ReentrantLock与内置锁synchronized的相同与区别</h3><p>相同：显示锁与内置锁在加锁和内存上提供的语义相同(互斥访问临界区)</p>
<p>不同：</p>
<ol>
<li><strong>使用方式</strong>：内置无需指定释放锁，简化锁操作。显示锁拥有锁获取和释放的可操作性。</li>
<li><strong>功能上</strong>：显示锁提供了其他很多功能如定时锁等待、可中断锁等待、公平性、尝试非阻塞获取锁、以及实现非结构化的加锁。（一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断表示为会被修改，但线程依旧会被阻塞在synchronized上，等待获取锁。）</li>
<li><strong>对死锁的处理</strong>：内置只能重启，显示可以通过设置超时获取锁来避免</li>
<li><strong>性能上</strong>：java1.5 显示远超内置，java1.6 显示锁稍微比内置好</li>
<li>atomicinteger和Volatile等线程安全操作的关键字的理解和使用</li>
</ol>
<p>SOF你遇到过哪些情况。</p>
<h3 id="实现多线程的3种方法：Thread与Runable。"><a href="#实现多线程的3种方法：Thread与Runable。" class="headerlink" title="实现多线程的3种方法：Thread与Runable。"></a>实现多线程的3种方法：Thread与Runable。</h3><ul>
<li><strong>1)继承Tread类，重写run函数</strong></li>
<li><strong>2)实现Runnable接口</strong></li>
<li><strong>3)实现Callable接口</strong></li>
</ul>
<h3 id="如何选择多线程池"><a href="#如何选择多线程池" class="headerlink" title="如何选择多线程池"></a>如何选择多线程池</h3><ol start="22">
<li>线程同步的方法：sychronized、lock、reentrantLock等。</li>
<li>锁的等级：方法锁、对象锁、类锁。</li>
<li>ThreadPool用法与优势。</li>
<li>Callable和Runnable的区别</li>
<li>Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</li>
<li>foreach与正常for循环效率对比。</li>
<li>反射的作用于原理。</li>
<li>泛型常用特点，List<string>能否转为List<object>。</object></string></li>
<li>设计模式：单例、工厂、适配器、责任链、观察者等等。</li>
<li>JNI的使用。</li>
<li>java的代理是怎么实现的  </li>
<li>Java1.7与1.8新特性。</li>
<li>lmbda表达式</li>
<li>Java8新特性</li>
<li>连接池使用使用什么数据结构实现</li>
<li>实现连接池</li>
<li>结束一条 Thread 有什么方法？ interrupt 底层实现有看过吗？线程的状态是怎么样的？如果给你实现会怎么样做？</li>
<li>Java 中有内存泄露吗？是怎么样的情景？为什么不用循环计数？</li>
<li>java都有哪些加锁方式</li>
<li>AIO与BIO的区别</li>
<li>生产者与消费者，手写代码</li>
<li>Java创建线程之后，直接调用start()方法和run()的区别</li>
<li>常用的线程池模式以及不同线程池的使用场景</li>
<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>
<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>
<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>
<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>
<li>线程间通信，wait和notify</li>
<li>定时线程的使用</li>
<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>
<li>并发、同步的接口或方法</li>
<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>
<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>
<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法</li>
</ol>
<h2 id="写出生产者消费者模式。"><a href="#写出生产者消费者模式。" class="headerlink" title="写出生产者消费者模式。"></a>写出生产者消费者模式。</h2><pre><code>public class ProducerConsumerPattern {
    public static void main(String args[]){
     BlockingQueue sharedQueue = new LinkedBlockingQueue();
     Thread prodThread = new Thread(new Producer(sharedQueue));
     Thread consThread = new Thread(new Consumer(sharedQueue));
     prodThread.start();
     consThread.start();
    }
}

//Producer Class in java
class Producer implements Runnable {
    private final BlockingQueue sharedQueue;
    public Producer(BlockingQueue sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
    @Override
    public void run() {
        for(int i=0; i&lt;10; i++){
            try {
                System.out.println(&quot;Produced: &quot; + i);
                sharedQueue.put(i);
            } catch (InterruptedException ex) {
                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

//Consumer Class in Java
class Consumer implements Runnable{
    private final BlockingQueue sharedQueue;
    public Consumer (BlockingQueue sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
    @Override
    public void run() {
        while(true){
            try {
                System.out.println(&quot;Consumed: &quot;+ sharedQueue.take());
            } catch (InterruptedException ex) {
                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://bbym010.iteye.com/blog/2100868" target="_blank" rel="noopener">http://bbym010.iteye.com/blog/2100868</a></li>
<li><a href="http://developer.51cto.com/art/201112/307463.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201112/307463.htm</a></li>
<li><a href="http://ifeve.com/java-nio-vs-io/" target="_blank" rel="noopener">http://ifeve.com/java-nio-vs-io/</a></li>
<li><a href="https://www.cnblogs.com/findumars/p/6361627.html" target="_blank" rel="noopener">5种网络IO模型（有图，很清楚）</a></li>
<li><a href="http://www.uml.org.cn/zjjs/201711241.asp" target="_blank" rel="noopener">gRPC线程模型分析</a> | InfoQ</li>
<li><a href="https://blog.csdn.net/qq546770908/article/details/53082870" target="_blank" rel="noopener"></a></li>
<li><a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">IO多路复用之select总结</a></li>
<li><a href="https://www.cnblogs.com/jeakeven/p/5435916.html" target="_blank" rel="noopener">IO多路复用之select、poll、epoll详解</a></li>
<li><a href="https://blog.csdn.net/a627088424/article/details/54582360" target="_blank" rel="noopener">透彻 Linux (Unix) 五种 IO 模型</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32400397" target="_blank" rel="noopener">设备管理 | I/O软件</a></li>
<li><a href="https://tech.meituan.com/about-desk-io.html" target="_blank" rel="noopener">磁盘I/O那些事</a> | 美团</li>
<li><a href="https://www.kancloud.cn/kancloud/ldd3/61083" target="_blank" rel="noopener">《Linux 设备驱动 Edition 3》</a></li>
<li><a href="https://segmentfault.com/a/1190000007692223" target="_blank" rel="noopener">磁盘及网络IO工作方式解析</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Socket.md" target="_blank" rel="noopener">Socket</a></li>
<li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener">面向对象设计的 SOLID 原则</a></li>
<li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener">看懂 UML 类图和时序图</a></li>
<li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener">UML 系列——时序图（顺序图）sequence diagram</a></li>
<li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener">面向对象编程三大特性 —— 封装、继承、多态</a></li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/code-软件基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/01/09/code-软件基础/" class="post-title-link" itemprop="url">code -- 软件基础</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-01-09 09:05:39" itemprop="dateCreated datePublished" datetime="2019-01-09T09:05:39+08:00">2019-01-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-09 09:55:34" itemprop="dateModified" datetime="2019-10-09T09:55:34+08:00">2019-10-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pencil2-算法"><a href="#pencil2-算法" class="headerlink" title=":pencil2: 算法"></a>:pencil2: 算法</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/剑指%20Offer%20题解%20-%20目录.md" target="_blank" rel="noopener">剑指 Offer 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20题解%20-%20目录.md" target="_blank" rel="noopener">Leetcode 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/算法%20-%20目录.md" target="_blank" rel="noopener">算法</a></li>
</ul>
<h2 id="computer-操作系统"><a href="#computer-操作系统" class="headerlink" title=":computer: 操作系统"></a>:computer: 操作系统</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统%20-%20目录.md" target="_blank" rel="noopener">计算机操作系统</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md" target="_blank" rel="noopener">Linux</a></li>
</ul>
<h2 id="cloud-网络"><a href="#cloud-网络" class="headerlink" title=":cloud: 网络"></a>:cloud: 网络</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络%20-%20目录.md" target="_blank" rel="noopener">计算机网络</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md" target="_blank" rel="noopener">HTTP</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">Socket</a></li>
</ul>
<h2 id="art-面向对象"><a href="#art-面向对象" class="headerlink" title=":art: 面向对象"></a>:art: 面向对象</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式.md" target="_blank" rel="noopener">设计模式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/面向对象思想.md" target="_blank" rel="noopener">面向对象思想</a></li>
</ul>
<h2 id="floppy-disk-数据库"><a href="#floppy-disk-数据库" class="headerlink" title=":floppy_disk: 数据库"></a>:floppy_disk: 数据库</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/数据库系统原理.md" target="_blank" rel="noopener">数据库系统原理</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL.md" target="_blank" rel="noopener">SQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode-Database%20题解.md" target="_blank" rel="noopener">Leetcode-Database 题解</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md" target="_blank" rel="noopener">MySQL</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md" target="_blank" rel="noopener">Redis</a></li>
</ul>
<h2 id="coffee-Java"><a href="#coffee-Java" class="headerlink" title=":coffee: Java"></a>:coffee: Java</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20基础.md" target="_blank" rel="noopener">Java 基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20容器.md" target="_blank" rel="noopener">Java 容器</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20并发.md" target="_blank" rel="noopener">Java 并发</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20虚拟机.md" target="_blank" rel="noopener">Java 虚拟机</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md" target="_blank" rel="noopener">Java I/O</a></li>
</ul>
<h2 id="bulb-系统设计"><a href="#bulb-系统设计" class="headerlink" title=":bulb: 系统设计"></a>:bulb: 系统设计</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/系统设计基础.md" target="_blank" rel="noopener">系统设计基础</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/分布式.md" target="_blank" rel="noopener">分布式</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/集群.md" target="_blank" rel="noopener">集群</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/攻击技术.md" target="_blank" rel="noopener">攻击技术</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/缓存.md" target="_blank" rel="noopener">缓存</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/消息队列.md" target="_blank" rel="noopener">消息队列</a></li>
</ul>
<h2 id="wrench-工具"><a href="#wrench-工具" class="headerlink" title=":wrench: 工具"></a>:wrench: 工具</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md" target="_blank" rel="noopener">Git</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md" target="_blank" rel="noopener">Docker</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/构建工具.md" target="_blank" rel="noopener">构建工具</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/正则表达式.md" target="_blank" rel="noopener">正则表达式</a></li>
</ul>
<h2 id="watermelon-编码实践"><a href="#watermelon-编码实践" class="headerlink" title=":watermelon: 编码实践"></a>:watermelon: 编码实践</h2><ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/代码可读性.md" target="_blank" rel="noopener">代码可读性</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/代码风格规范.md" target="_blank" rel="noopener">代码风格规范</a></li>
</ul>
<h2 id="转载自"><a href="#转载自" class="headerlink" title=":转载自"></a>:转载自</h2><ul>
<li><a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">CyC2018</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/浅尝-MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/09/13/浅尝-MQ/" class="post-title-link" itemprop="url">浅尝 MQ</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-09-13 14:39:09" itemprop="dateCreated datePublished" datetime="2018-09-13T14:39:09+08:00">2018-09-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 17:29:44" itemprop="dateModified" datetime="2019-10-11T17:29:44+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>消息队列技术(Message Queue) 是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上, 队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行 ———— 它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。</p>
<h2 id="MQ使用场景"><a href="#MQ使用场景" class="headerlink" title="MQ使用场景"></a>MQ使用场景</h2><ol>
<li><p><strong>异步通信</strong>：有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
</li>
<li><p><strong>解耦</strong>：降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</p>
</li>
<li><p><strong>冗余</strong>：有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
</li>
<li><p><strong>扩展性</strong>：因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容</p>
</li>
<li><p><strong>过载保护</strong>：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃</p>
</li>
<li><p><strong>可恢复性</strong>：系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 </p>
</li>
<li><p><strong>顺序保证</strong>：在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。 </p>
</li>
<li><p><strong>缓冲</strong>：在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。</p>
</li>
<li><p><strong>数据流处理</strong>：分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择</p>
</li>
</ol>
<h2 id="MQ缺点"><a href="#MQ缺点" class="headerlink" title="MQ缺点"></a>MQ缺点</h2><ol>
<li><p>系统可用性降低：系统引入的外部依赖越多，越容易挂掉。本来你就是 <code>A</code> 系统调用 <code>BCD</code> 三个系统的接口就好了， <code>ABCD</code> 四个系统好好的，没啥问题，你偏加个 <code>MQ</code> 进来，万一 <code>MQ</code> <code>挂了咋整，MQ</code> 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用。</p>
</li>
<li><p>系统复杂度提高：硬生生加个 <code>MQ</code> 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p>
</li>
<li><p>一致性问题： <code>A</code> 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 <code>BCD</code> 三个系统那里， <code>BD</code> 两个系统写库成功了，结果 <code>C</code> 系统写库失败了，咋整？你这数据就不一致了。</p>
</li>
</ol>
<h2 id="MQ常用协议"><a href="#MQ常用协议" class="headerlink" title="MQ常用协议"></a>MQ常用协议</h2><ul>
<li><p><strong>AMQP协议</strong> AMQP即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。</p>
<blockquote>
<p>优点：可靠、通用</p>
</blockquote>
</li>
<li><p><strong>MQTT协议</strong> MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。 </p>
<blockquote>
<p>优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统</p>
</blockquote>
</li>
<li><p><strong>STOMP协议</strong> STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。 </p>
<blockquote>
<p>优点：命令模式（非topic/queue模式）</p>
</blockquote>
</li>
<li><p><strong>XMPP协议</strong> XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。</p>
<blockquote>
<p>优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大</p>
</blockquote>
</li>
<li><p><strong>其他基于TCP/IP自定义的协议</strong>：有些特殊框架（如：redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。</p>
</li>
</ul>
<h2 id="MQ的通讯模式"><a href="#MQ的通讯模式" class="headerlink" title="MQ的通讯模式"></a>MQ的通讯模式</h2><ol>
<li><p><strong>点对点通讯</strong>：点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</p>
</li>
<li><p><strong>多点广播</strong>：MQ适用于不同类型的应用。其中重要的，也是正在发展中的是”多点广播”应用，即能够将消息发送到多个目标站点(Destination List)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</p>
</li>
<li><p><strong>发布/订阅(Publish/Subscribe)模式</strong>：发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。在MQ家族产品中，MQ Event Broker是专门用于使用发布/订阅技术进行数据通讯的产品，它支持基于队列和直接基于TCP/IP两种方式的发布和订阅。</p>
</li>
<li><p><strong>集群(Cluster)</strong>：为了简化点对点通讯模式中的系统配置，MQ提供 Cluster 的解决方案。集群类似于一个 域(Domain) ，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用 Cluster 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性</p>
</li>
</ol>
<h2 id="消息投递保证"><a href="#消息投递保证" class="headerlink" title="消息投递保证"></a>消息投递保证</h2><ul>
<li><code>At most once</code>：消息可能会丢，但绝不会重复投递</li>
<li><code>At least one</code>：消息绝不会丢，但可能会重复投递</li>
<li><code>Exactly once</code>：每条消息肯定会被投递一次且仅投递一次，很多时候这是用户所想要的。</li>
</ul>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><strong>Broker</strong>：Kafka 集群包含一个或多个服务器，这种服务器被称为 <code>broker</code> 。</li>
<li><strong>Topic</strong>：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。</li>
<li><strong>Partition</strong>： <code>Partition</code> 是物理上的概念，每个 <code>Topic</code> 包含一个或多个 <code>Partition</code> 。</li>
<li><strong>Producer</strong>：负责发布消息到 Kafka broker。</li>
<li><strong>Consumer</strong>：消息消费者，向 Kafka broker 读取消息的客户端。</li>
<li><strong>Consumer Group</strong>：每个 <code>Consumer</code> 属于一个特定的 <code>Consumer Group</code>（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</li>
</ul>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p><img src="images/9a9bab37c896c086e2fee7b3e15a9ae3.png" alt="image"></p>
<p>如上图所示，一个典型的 <code>Kafka</code> 集群中包含若干 <code>Producer</code> （可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干 <code>broker</code> （Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干 <code>Consumer Group</code> ，以及一个 <code>Zookeeper</code> 集群。 <code>Kafka</code> 通过 <code>Zookeeper</code> 管理集群配置，选举 <code>leader</code> ，以及在 <code>Consumer Group</code> 发生变化时进行 rebalance。 <code>Producer</code> 使用 push 模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h2 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h2><p><strong>Topic 在逻辑上可以被认为是一个 queue</strong> ，每条消费都必须指定它的 <code>Topic</code> ，可以简单理解为必须指明把这条消息放进哪个 <code>queue</code> 里。为了使得 Kafka 的吞吐率可以线性提高，<strong>物理上把 <code>Topic</code> 分成一个或多个 <code>Partition</code></strong> ，每个 <code>Partition</code> 在物理上对应一个文件夹，该文件夹下存储这个 <code>Partition</code> 的所有消息和索引文件。若创建 <code>topic1</code> 和 <code>topic2</code> 两个 <code>topic</code> ，且分别有 13 个和 19 个分区，则整个集群上会相应会生成共 32 个文件夹（本文所用集群共8个节点，此处 <code>topic1</code> 和 <code>topic2</code> <code>replication-factor</code> 均为1）。</p>
<blockquote>
<p>Partition 都是通过 顺序读写，所以效率很高</p>
</blockquote>
<blockquote>
<p>replication-factor 配置 partition 副本数。配置副本之后,每个 partition 都有一个唯一的 leader ，有 0 个或多个 follower 。所有的读写操作都在 leader 上完成，followers 从 leader 消费消息来复制 message，就跟普通的 consumer 消费消息一样。一般情况下 partition 的数量大于等于 broker 的数量，并且所有 partition 的 leader 均匀分布在 broker 上。</p>
</blockquote>
<p>对于传统的 MQ 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。一是基于时间，二是基于 Partition 文件大小。</p>
<h2 id="Producer-消息路由"><a href="#Producer-消息路由" class="headerlink" title="Producer 消息路由"></a>Producer 消息路由</h2><p>Producer 发送消息到 broker 时，会根据 Paritition 机制选择将其存储到哪一个 Partition 。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition 里，这样就实现了负载均衡。如果一个 Topic 对应一个文件，那这个文件所在的机器I/O将会成为这个 Topic 的性能瓶颈，而有了 Partition 后，不同的消息可以并行写入不同 broker 的不同 Partition 里，极大的提高了吞吐率。</p>
<p>可以在 <code>$KAFKA_HOME/config/server.properties</code> 中通过配置项 <code>num.partitions</code> 来指定新建 <code>Topic</code> 的默认 <code>Partition</code> 数量，也可在创建 <code>Topic</code> 时通过参数指定，同时也可以在 Topic 创建之后通过 Kafka 提供的工具修改。</p>
<p>在发送一条消息时，可以指定这条消息的 <code>key</code> ，Producer 根据这个 <code>key</code> 和 Partition 机制来判断应该将这条消息发送到哪个 Parition 。Paritition机制可以通过指定 Producer 的 <code>paritition.class</code> 这一参数来指定，该 class 必须实现 <code>kafka.producer.Partitioner</code> 接口。</p>
<h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><p><img src="images/e54deac5512215cfc6801890bb83d792.png" alt="image"></p>
<p>这是 Kafka 用来实现一个 Topic 消息的广播（发给所有的 Consumer ）和单播（发给某一个 Consumer ）的手段。一个 Topic 可以对应多个 Consumer Group 。如果需要实现广播，只要每个 Consumer 有一个独立的 Group 就可以了。要实现单播只要所有的 Consumer 在同一个 Group 里。用 Consumer Group 还可以将 Consumer 进行自由的分组而不需要多次发送消息到不同的 Topic 。</p>
<h2 id="Consumer-个数与-Parition-数有什么关系？"><a href="#Consumer-个数与-Parition-数有什么关系？" class="headerlink" title="Consumer 个数与 Parition 数有什么关系？"></a>Consumer 个数与 Parition 数有什么关系？</h2><p><strong>topic 下的一个分区只能被同一个 consumer group 下的一个 consumer 线程来消费</strong>，但反之并不成立，即一个 consumer 线程可以消费多个分区的数据。比如 Kafka 提供的 <code>ConsoleConsumer</code> ，默认就只是一个线程来消费所有分区的数据。</p>
<blockquote>
<p>即分区数决定了同组消费者个数的上限</p>
</blockquote>
<p><img src="images/5290a719713da5ce4e83422ded5bdf0c.png" alt="image"></p>
<p>所以，如果你的分区数是 N ，那么最好线程数也保持为 N ，这样通常能够达到最大的吞吐量。超过 N 的配置只是浪费系统资源，因为多出的线程不会被分配到任何分区。</p>
<h2 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs. Pull　　"></a>Push vs. Pull　　</h2><p>作为一个消息系统，Kafka 遵循了传统的方式，选择由 Producer 向 broker <code>push</code> 消息并由 Consumer 从 broker <code>pull</code> 消息。事实上，push 模式和 pull 模式各有优劣。</p>
<ul>
<li>Push模式 很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成 Consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。</li>
<li>Pull模式 可以根据Consumer的消费能力以适当的速率消费消息。</li>
</ul>
<p>对于 Kafka 而言，Pull模式 更合适。Pull模式 可简化 broker 的设计，Consumer 可自主控制消费消息的速率，同时 Consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>
<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p><code>Kafka 0.8</code> 以前，是没有 HA 机制的，就是任何一个 <code>broker</code> 宕机了，那个 <code>broker</code> 上的 <code>partition</code> 就废了，没法写也没法读，没有什么高可用性可言。</p>
<p>比如说，我们假设创建了一个 <code>topic</code> ，指定其 <code>partition</code> 数量是 <code>3</code> 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 <code>topic</code> 的 <code>1/3</code> 的数据就丢了，因此这个是做不到高可用的。</p>
<p><img src="images/ab965081f1e5ff28386d90ba18a17d6d.png" alt="image"></p>
<p><code>Kafka 0.8</code> 以后，提供了 <code>HA</code> 机制，就是 <code>replica</code> <strong>副本机制</strong>。每个 <code>partition</code> 的数据都会同步到其它机器上，形成自己的多个 <code>replica</code> 副本。所有 <code>replica</code> 会选举一个 <code>leader</code> 出来，那么生产和消费都跟这个 <code>leader</code> 打交道，然后其他 <code>replica</code> 就是 <code>follower</code> 。写的时候， <code>leader</code> 会负责把数据同步到所有 <code>follower</code> 上去，读的时候就直接读 <code>leader</code> 上的数据即可。 <code>Kafka</code> 会均匀地将一个 <code>partition</code> 的所有 <code>replica</code> 分布在不同的机器上，这样才可以提高容错性。</p>
<p><img src="images/a0de8d416add777aef97683192fd15db.png" alt="image"></p>
<p>这么搞，就有所谓的高可用性了，因为如果某个 <code>broker</code> 宕机了，没事儿，那个 <code>broker</code> 上面的 <code>partition</code> 在其他机器上都有副本的，如果这上面有某个 <code>partition</code> 的 <code>leader</code> ，那么此时会从 <code>follower</code> 中 <strong>重新选举</strong> 一个新的 <code>leader</code> 出来，大家继续读写那个新的 <code>leader</code> 即可。这就有所谓的高可用性了。</p>
<ul>
<li><strong>写数据</strong> 的时候，生产者就写 <code>leader</code> ，然后 <code>leader</code> 将数据落地写本地磁盘，接着其他 <code>follower</code> 自己主动从 <code>leader</code> 来 <code>pull</code> 数据。一旦所有 <code>follower</code> 同步好数据了，就会发送 <code>ack</code> 给 <code>leader</code> ， <strong><code>leader</code> 收到所有 <code>follower</code> 的 <code>ack</code> 之后，就会返回写成功的消息给生产者</strong>。（当然，这只是其中一种模式，还可以适当调整这个行为）</li>
<li><strong>消费</strong> 的时候，只会从 <code>leader</code> 去读，但是 <strong>只有当一个消息已经被所有 <code>follower</code> 都同步成功返回 <code>ack</code> 的时候，这个消息才会被消费者读到</strong>。</li>
</ul>
<h2 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h2><p><code>Kafka</code> 实际上有个 <code>offset</code> 的概念，就是每个消息写进去，都有一个 <code>offset</code> ，代表消息的序号，然后 <strong><code>consumer</code> 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 <code>offset</code> 提交一下</strong>，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 <code>offset</code> 来继续消费吧”。</p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 <code>kill</code> 进程了，再重启。这会导致 <code>consumer</code> 有些消息处理了，但是没来得及提交 <code>offset</code> ，尴尬了。重启之后，<strong>少数消息会再次消费一次</strong>。</p>
<p>幂等性，通俗点说，<strong>一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错</strong>。其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性？其实还是得 <strong>结合业务来思考</strong>，这里给几个思路：</p>
<ul>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis ，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
<h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><h3 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h3><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边 <strong>自动提交了 <code>offset</code></strong> ，让 <code>Kafka</code> 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>
<p><code>Kafka</code> 会自动提交 <code>offset</code> ，那么只要关闭自动提交 <code>offset</code> ，在处理完之后自己手动提交 <code>offset</code> ，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 <code>offset</code> ，结果自己挂了，此时肯定会重复消费一次，自己 <strong>保证幂等性</strong> 就好了。</p>
<h3 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h3><p>这块比较常见的一个场景，就是 <code>Kafka</code> 某个 <code>broker</code> 宕机，然后重新选举 <code>partition</code> 的 <code>leader</code> 。大家想想，要是此时其他的 <code>follower</code> 刚好还有些数据没有同步，结果此时 <code>leader</code> 挂了，然后选举某个 <code>follower</code> 成 <code>leader</code> 之后，不就少了一些数据？这就丢了一些数据啊。</p>
<p>此时一般是要求起码设置如下 4 个参数：</p>
<ul>
<li>给 <code>topic</code> 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 <code>partition</code> 必须有 <strong>至少</strong> 2 个副本。</li>
<li>在 <code>Kafka</code> 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是 <strong>要求一个 <code>leader</code> 至少感知到有至少一个 <code>follower</code> 还跟自己保持联系</strong>，没掉队，这样才能确保 <code>leader</code> 挂了还有一个 <code>follower</code> 吧。</li>
<li>在 <code>producer</code> 端设置 <code>acks=all</code>：这个是要求每条数据，<strong>必须是写入所有 <code>replica</code> 之后，才能认为是写成功了</strong>。</li>
<li>在 <code>producer</code> 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是要求 <strong>一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<p>这样配置之后，至少在 Kafka <code>broker</code> 端就可以保证在 <code>leader</code> 所在 <code>broker</code> 发生故障，进行 <code>leader</code> 切换时，数据不会丢失。</p>
<h3 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h3><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 <code>leader</code> 接收到消息，所有的 <code>follower</code> 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者可以自动不断的重试，重试无限次。</p>
<h2 id="消息的顺序性"><a href="#消息的顺序性" class="headerlink" title="消息的顺序性"></a>消息的顺序性</h2><p>比如说我们建了一个 <code>topic</code> ，有三个 <code>partition</code> 。生产者在写的时候，其实可以指定一个 <code>key</code> ，比如说我们指定了某个订单 <code>id</code> 作为 <code>key</code> ，那么这个订单相关的数据，一定会被分发到同一个 <code>partition</code> 中去，而且这个 <code>partition</code> 中的数据一定是有顺序的。</p>
<p>消费者从 <code>partition</code> 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 <code>ok</code> 的，没有错乱。接着，我们在消费者里可能会搞 <strong>多个线程来并发处理消息</strong>。而多个线程并发跑的话，顺序可能就乱掉了。</p>
<p><img src="images/7d529fbf2f856582c2eb3ee787ede5fd.png" alt="image"></p>
<p>解决方案：</p>
<ul>
<li>一个 <code>topic</code> ，一个 <code>partition</code> ，一个 <code>consumer</code> ，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li>写 <code>N</code> 个内存 <code>queue</code> ，具有相同 <code>key</code> 的数据都到同一个内存 <code>queue</code> ；然后对于 N 个线程，每个线程分别消费一个内存 <code>queue</code> 即可，这样就能保证顺序性。</li>
</ul>
<p><img src="images/09d68167fcb34b075259add9b81809cd.png" alt="image"></p>
<ul>
<li>1、kafka在高并发的情况下,如何避免消息丢失和消息重复?</li>
</ul>
<p>消息丢失解决方案:</p>
<p>首先对kafka进行限速， 其次启用重试机制，重试间隔时间设置长一些，最后Kafka设置acks=all，即需要相应的所有处于ISR的分区都确认收到该消息后，才算发送成功</p>
<p>消息重复解决方案:</p>
<p>消息可以使用唯一id标识</p>
<p>生产者（ack=all 代表至少成功发送一次)</p>
<p>消费者 （offset手动提交，业务逻辑成功处理后，提交offset）</p>
<p>落表（主键或者唯一索引的方式，避免重复数据）</p>
<p>业务逻辑处理（选择唯一主键存储到Redis或者mongdb中，先查询是否存在，若存在则不处理；若不存在，先插入Redis或Mongdb,再进行业务逻辑处理）</p>
<ul>
<li>2、kafka怎么保证数据消费一次且仅消费一次</li>
</ul>
<p>幂等producer：保证发送单个分区的消息只会发送一次，不会出现重复消息</p>
<p>事务(transaction)：保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚流处理EOS：流处理本质上可看成是“读取-处理-写入”的管道。此EOS保证整个过程的操作是原子性。注意，这只适用于Kafka Streams</p>
<ul>
<li>3、kafka保证数据一致性和可靠性</li>
</ul>
<p>数据一致性保证</p>
<p>一致性定义：若某条消息对client可见，那么即使Leader挂了，在新Leader上数据依然可以被读到</p>
<p>HW-HighWaterMark: client可以从Leader读到的最大msg offset，即对外可见的最大offset， HW=max(replica.offset)</p>
<p>对于Leader新收到的msg，client不能立刻消费，Leader会等待该消息被所有ISR中的replica同步后，更新HW，此时该消息才能被client消费，这样就保证了如果Leader fail，该消息仍然可以从新选举的Leader中获取。</p>
<p>对于来自内部Broker的读取请求，没有HW的限制。同时，Follower也会维护一份自己的HW，Folloer.HW = min(Leader.HW, Follower.offset)</p>
<p>数据可靠性保证</p>
<p>当Producer向Leader发送数据时，可以通过acks参数设置数据可靠性的级别</p>
<p>0: 不论写入是否成功，server不需要给Producer发送Response，如果发生异常，server会终止连接，触发Producer更新meta数据；</p>
<p>1: Leader写入成功后即发送Response，此种情况如果Leader fail，会丢失数据</p>
<p>-1: 等待所有ISR接收到消息后再给Producer发送Response，这是最强保证</p>
<ul>
<li>4、kafka到spark streaming怎么保证数据完整性，怎么保证数据不重复消费？</li>
</ul>
<p>保证数据不丢失（at-least）</p>
<p>spark RDD内部机制可以保证数据at-least语义。</p>
<p>Receiver方式</p>
<p>开启WAL（预写日志），将从kafka中接受到的数据写入到日志文件中，所有数据从失败中可恢复。</p>
<p>Direct方式</p>
<p>依靠checkpoint机制来保证。</p>
<p>保证数据不重复（exactly-once）</p>
<p>要保证数据不重复，即Exactly once语义。</p>
<ul>
<li><p>幂等操作：重复执行不会产生问题，不需要做额外的工作即可保证数据不重复。</p>
</li>
<li><p>业务代码添加事务操作</p>
</li>
</ul>
<p>就是说针对每个partition的数据，产生一个uniqueId，只有这个partition的所有数据被完全消费，则算成功，否则算失效，要回滚。下次重复执行这个uniqueId时，如果已经被执行成功，则skip掉。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jasongj.com/2015/03/10/KafkaColumn1/" target="_blank" rel="noopener">Kafka设计解析</a><br><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md#kafka-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" target="_blank" rel="noopener">Kafka的高可用</a><br><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md" target="_blank" rel="noopener">Kafka幂等性</a><br><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md#kafka" target="_blank" rel="noopener">Kafka消息丢失</a><br><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-interview.md" target="_blank" rel="noopener">消息队列面试场景</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/dubbo-相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/08/22/dubbo-相关/" class="post-title-link" itemprop="url">dubbo 相关</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-08-22 14:00:42" itemprop="dateCreated datePublished" datetime="2018-08-22T14:00:42+08:00">2018-08-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 14:31:29" itemprop="dateModified" datetime="2019-10-11T14:31:29+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><a href="https://zhuanlan.zhihu.com/p/45846108" target="_blank" rel="noopener">Dubbo</a></h1><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>在 Dubbo 的核心领域模型中：</p>
<ul>
<li><code>Protocol</code> 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</li>
<li><code>Invoker</code> 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li>
<li><code>Invocation</code> 是会话域，它持有调用过程中的变量，比如方法名，参数等。</li>
</ul>
<h2 id="基本设计原则"><a href="#基本设计原则" class="headerlink" title="基本设计原则"></a>基本设计原则</h2><ul>
<li>采用 <code>Microkernel + Plugin</code> 模式，Microkernel 只负责组装 Plugin，Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换。</li>
<li>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。</li>
</ul>
<h2 id="Dubbo-服务暴露过程"><a href="#Dubbo-服务暴露过程" class="headerlink" title="Dubbo 服务暴露过程"></a>Dubbo 服务暴露过程</h2><p><a href="https://dubbo.incubator.apache.org/zh-cn/docs/source_code_guide/export-service.html" target="_blank" rel="noopener">官方文档–服务导出</a></p>
<p><img src="images/fce799af888ea1e2b757476b03d4ded7.png" alt="image"></p>
<h2 id="Dubbo-结构"><a href="#Dubbo-结构" class="headerlink" title="Dubbo 结构"></a>Dubbo 结构</h2><ul>
<li>第一层：service 层，接口层，给服务提供者和消费者来实现的</li>
<li>第二层：config 层，配置层，主要是对 dubbo 进行各种配置的</li>
<li>第三层：proxy 层，服务代理层，无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信</li>
<li>第四层：registry 层，服务注册层，负责服务的注册与发现</li>
<li>第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li>
<li>第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控</li>
<li>第七层：protocal 层，远程调用层，封装 rpc 调用</li>
<li>第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步</li>
<li>第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口</li>
<li>第十层：serialize 层，数据序列化层</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>第一步：provider 向注册中心去注册</li>
<li>第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务</li>
<li>第三步：consumer 调用 provider</li>
<li>第四步：consumer 和 provider 都异步通知监控中心</li>
</ul>
<p><img src="images/075a4cbace1c6874c04ae34c6b91c7ad.png" alt="image"></p>
<h2 id="注册中心挂了可以继续通信吗？"><a href="#注册中心挂了可以继续通信吗？" class="headerlink" title="注册中心挂了可以继续通信吗？"></a>注册中心挂了可以继续通信吗？</h2><p>可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到 <strong>本地缓存</strong>，所以注册中心挂了可以继续通信。</p>
<h2 id="Dubbo-支持哪些序列化协议？说一下-Hessian-的数据结构？PB-知道吗？为什么-PB-的效率是最高的？"><a href="#Dubbo-支持哪些序列化协议？说一下-Hessian-的数据结构？PB-知道吗？为什么-PB-的效率是最高的？" class="headerlink" title="Dubbo 支持哪些序列化协议？说一下 Hessian 的数据结构？PB 知道吗？为什么 PB 的效率是最高的？"></a>Dubbo 支持哪些序列化协议？说一下 Hessian 的数据结构？PB 知道吗？为什么 PB 的效率是最高的？</h2><h3 id="Dubbo-支持不同的通信协议"><a href="#Dubbo-支持不同的通信协议" class="headerlink" title="Dubbo 支持不同的通信协议"></a>Dubbo 支持不同的通信协议</h3><ul>
<li><strong>dubbo 协议</strong>：默认就是走 dubbo 协议，<strong>单一长连接</strong>，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。</li>
<li><strong>rmi 协议</strong>：走 Java 二进制序列化，<strong>多个短连接</strong>，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</li>
<li><strong>hessian 协议</strong>：走 hessian 序列化协议，<strong>多个短连接</strong>，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</li>
<li><strong>http 协议</strong>：走 json 序列化</li>
<li><strong>webservice</strong>：走 SOAP 文本序列化</li>
</ul>
<h3 id="Dubbo-支持的序列化协议"><a href="#Dubbo-支持的序列化协议" class="headerlink" title="Dubbo 支持的序列化协议"></a>Dubbo 支持的序列化协议</h3><p><code>dubbo</code> 支持 <code>hession</code> 、 Java 二进制序列化、<code>json</code>、<code>SOAP</code> 文本序列化多种序列化协议。但是 <strong><code>hessian</code> 是其默认的序列化协议</strong>。</p>
<h3 id="为什么-PB-的效率是最高的？"><a href="#为什么-PB-的效率是最高的？" class="headerlink" title="为什么 PB 的效率是最高的？"></a>为什么 PB 的效率是最高的？</h3><p>其实 PB 之所以性能如此好，主要得益于两个：</p>
<ul>
<li>它使用 <code>proto</code> 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 <code>20~100</code> 倍；</li>
<li>它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</li>
</ul>
<h2 id="dubbo-负载均衡策略和集群容错策略都有哪些？动态代理策略呢？"><a href="#dubbo-负载均衡策略和集群容错策略都有哪些？动态代理策略呢？" class="headerlink" title="dubbo 负载均衡策略和集群容错策略都有哪些？动态代理策略呢？"></a>dubbo 负载均衡策略和集群容错策略都有哪些？动态代理策略呢？</h2><h3 id="dubbo-负载均衡策略"><a href="#dubbo-负载均衡策略" class="headerlink" title="dubbo 负载均衡策略"></a>dubbo 负载均衡策略</h3><h4 id="random-loadbalance"><a href="#random-loadbalance" class="headerlink" title="random loadbalance"></a>random loadbalance</h4><p>默认情况下，dubbo 是 <code>random load balance</code> ，即 <strong>随机</strong> 调用实现负载均衡，可以对 <code>provider</code> 不同实例 <strong>设置不同的权重</strong>，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。</p>
<h4 id="roundrobin-loadbalance"><a href="#roundrobin-loadbalance" class="headerlink" title="roundrobin loadbalance"></a>roundrobin loadbalance</h4><p>这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。</p>
<h4 id="leastactive-loadbalance"><a href="#leastactive-loadbalance" class="headerlink" title="leastactive loadbalance"></a>leastactive loadbalance</h4><p>这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给 <strong>不活跃的性能差的机器更少的请求</strong>。</p>
<h4 id="consistanthash-loadbalance"><a href="#consistanthash-loadbalance" class="headerlink" title="consistanthash loadbalance"></a>consistanthash loadbalance</h4><p>一致性 Hash 算法，相同参数的请求一定分发到一个 <code>provider</code> 上去， <code>provider</code> 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。<strong>如果你需要的不是随机负载均衡</strong>，是要一类请求都到一个节点，那就走这个一致性 <code>Hash</code> 策略。</p>
<h3 id="dubbo-集群容错策略"><a href="#dubbo-集群容错策略" class="headerlink" title="dubbo 集群容错策略"></a>dubbo 集群容错策略</h3><h4 id="failover-cluster-模式"><a href="#failover-cluster-模式" class="headerlink" title="failover cluster 模式"></a>failover cluster 模式</h4><p>失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器）</p>
<h4 id="failfast-cluster模式"><a href="#failfast-cluster模式" class="headerlink" title="failfast cluster模式"></a>failfast cluster模式</h4><p>一次调用失败就立即失败，常见于写操作。（调用失败就立即失败）</p>
<h4 id="failsafe-cluster-模式"><a href="#failsafe-cluster-模式" class="headerlink" title="failsafe cluster 模式"></a>failsafe cluster 模式</h4><p>出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。</p>
<h4 id="failback-cluster-模式"><a href="#failback-cluster-模式" class="headerlink" title="failback cluster 模式"></a>failback cluster 模式</h4><p>失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。</p>
<h4 id="forking-cluster-模式"><a href="#forking-cluster-模式" class="headerlink" title="forking cluster 模式"></a>forking cluster 模式</h4><p><strong>并行调用</strong> 多个 <code>provider</code> ，只要一个成功就立即返回。</p>
<h4 id="broadcacst-cluster"><a href="#broadcacst-cluster" class="headerlink" title="broadcacst cluster"></a>broadcacst cluster</h4><p>逐个调用所有的 <code>provider。</code></p>
<h3 id="dubbo动态代理策略"><a href="#dubbo动态代理策略" class="headerlink" title="dubbo动态代理策略"></a>dubbo动态代理策略</h3><p>默认使用 <code>javassist</code> 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。</p>
<h2 id="dubbo-的-spi-思想是什么？"><a href="#dubbo-的-spi-思想是什么？" class="headerlink" title="dubbo 的 spi 思想是什么？"></a>dubbo 的 spi 思想是什么？</h2><p><code>spi</code> ，简单来说，就是 <code>service provider interface</code>，说白了是什么意思呢，比如你有个接口，现在这个接口有 3 个实现类，那么在系统运行的时候对这个接口到底选择哪个实现类呢？这就需要 <code>spi</code> 了，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。</p>
<p><code>dubbo</code> 也用了 <code>spi</code> 思想，不过没有用 <code>jdk</code> 的 <code>spi</code> 机制，是自己实现的一套 <code>spi</code> 机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<p><code>Protocol</code> 接口，在系统运行的时候， <code>dubbo</code> 会判断一下应该选用这个 <code>Protocol</code> 接口的哪个实现类来实例化对象来使用。</p>
<p>它会去找一个你配置的 <code>Protocol</code> ，将你配置的 <code>Protocol</code> 实现类，加载到 <code>jvm</code> 中来，然后实例化对象，就用你的那个 <code>Protocol</code> 实现类就可以了。</p>
<h2 id="如何基于-Dubbo-进行服务治理、服务降级、失败重试以及超时重试？"><a href="#如何基于-Dubbo-进行服务治理、服务降级、失败重试以及超时重试？" class="headerlink" title="如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？"></a>如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</h2><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><h4 id="1-调用链路自动生成"><a href="#1-调用链路自动生成" class="headerlink" title="1. 调用链路自动生成"></a>1. 调用链路自动生成</h4><p>一个大型的分布式系统，或者说是用现在流行的微服务架构来说吧，<strong>分布式系统由大量的服务组成</strong>。那么这些服务之间互相是如何调用的？调用链路是啥？说实话，几乎到后面没人搞的清楚了，因为服务实在太多了，可能几百个甚至几千个服务。</p>
<p>那就需要基于 dubbo 做的分布式系统中，对各个服务之间的调用自动记录下来，然后自动将 <strong>各个服务之间的依赖关系和调用链路生成出来</strong>，做成一张图，显示出来，大家才可以看到对吧。</p>
<p><img src="images/c48a88cbce65d737293a41250ea58d72.png" alt="image"></p>
<h4 id="2-服务访问压力以及时长统计"><a href="#2-服务访问压力以及时长统计" class="headerlink" title="2. 服务访问压力以及时长统计"></a>2. 服务访问压力以及时长统计</h4><p>需要自动统计 <strong>各个接口和服务之间的调用次数以及访问延时</strong>，而且要分成两个级别。</p>
<ul>
<li>一个级别是接口粒度，就是每个服务的每个接口每天被调用多少次，<code>TP50/TP90/TP99</code>，三个档次的请求延时分别是多少；</li>
<li>第二个级别是从源头入口开始，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的 <code>TP50/TP90/TP99</code>，分别是多少。</li>
</ul>
<p>这些东西都搞定了之后，后面才可以来看当前系统的压力主要在哪里，如何来扩容和优化啊。</p>
<h4 id="3-其它"><a href="#3-其它" class="headerlink" title="3. 其它"></a>3. 其它</h4><ul>
<li>服务分层（避免循环依赖）</li>
<li>调用链路失败监控和报警</li>
<li>服务鉴权</li>
<li>每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）</li>
</ul>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。</p>
<p>举个栗子，我们有接口 <code>HelloService</code>。<code>HelloServiceImpl</code> 有该接口的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span><br><span class="line">   void sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello world......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-provider"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.zhss.service.HelloService"</span> <span class="attr">ref</span>=<span class="string">"helloServiceImpl"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.zhss.service.HelloServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-consumer"</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"fooService"</span> <span class="attr">interface</span>=<span class="string">"com.test.service.FooService"</span>  <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">mock</span>=<span class="string">"return null"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们调用接口失败的时候，可以通过 <code>mock</code> 统一返回 <code>null</code> 。</p>
<p>mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+<code>Mock</code>” 后缀。然后在 Mock 类里实现自己的降级逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServiceMock implements HelloService &#123;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        // 降级逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="失败重试和超时重试"><a href="#失败重试和超时重试" class="headerlink" title="失败重试和超时重试"></a>失败重试和超时重试</h3><p>所谓失败重试，就是 <code>consumer</code> 调用 <code>provider</code> 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"xxxx"</span> <span class="attr">interface</span>=<span class="string">"xx"</span> <span class="attr">check</span>=<span class="string">"true"</span> <span class="attr">async</span>=<span class="string">"false"</span> <span class="attr">retries</span>=<span class="string">"3"</span> <span class="attr">timeout</span>=<span class="string">"2000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">advanced-java</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/mysql-配置安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/08/12/mysql-配置安装/" class="post-title-link" itemprop="url">mysql 配置安装</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-08-12 18:33:28" itemprop="dateCreated datePublished" datetime="2018-08-12T18:33:28+08:00">2018-08-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 18:34:37" itemprop="dateModified" datetime="2019-10-11T18:34:37+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux-CentOS6-7-环境Mysql-5-7-17安装教程分享给大家，供大家参考，具体内容如下："><a href="#linux-CentOS6-7-环境Mysql-5-7-17安装教程分享给大家，供大家参考，具体内容如下：" class="headerlink" title="linux(CentOS6.7) 环境Mysql 5.7.17安装教程分享给大家，供大家参考，具体内容如下："></a>linux(CentOS6.7) 环境Mysql 5.7.17安装教程分享给大家，供大家参考，具体内容如下：</h1><p>1系统约定<br>安装文件下载目录：/data/software<br>Mysql目录安装位置：/usr/local/mysql<br>数据库保存位置：/data/mysql<br>日志保存位置：/data/log/mysql</p>
<p>2下载mysql<br>在官网：<a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/</a> 中，选择以下版本的mysql下载：</p>
<p>执行如下命名：<br>#mkdir /data/software<br>#cd /data/software</p>
<p>–下载安装包 </p>
<p>–建议：在windows上使用迅雷下载，速度很快（我的是1M/s），然后用工具（Xftp）上传到 /data/software目录下；<br>#wget <a href="http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz" target="_blank" rel="noopener">http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz</a></p>
<p>3解压压缩包到目标位置</p>
<p>#cd /data/software</p>
<p>–解压压缩包</p>
<p>#tar -xzvf /data/software/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz</p>
<p>–移动并修改文件名</p>
<p>#mv /data/software/mysql-5.7.17-linux-glibc2.5-x86_64 /usr/local/mysql</p>
<p>4创建数据仓库目录</p>
<p>–/data/mysql 数据仓库目录</p>
<h1 id="mkdir-data-mysql"><a href="#mkdir-data-mysql" class="headerlink" title="mkdir /data/mysql"></a>mkdir /data/mysql</h1><p>#ls /data/</p>
<p>5新建mysql用户、组及目录</p>
<h1 id="—新建一个msyql组"><a href="#—新建一个msyql组" class="headerlink" title="—新建一个msyql组"></a>—新建一个msyql组</h1><h1 id="useradd-r-s-sbin-nologin-g-mysql-mysql-d-usr-local-mysql-—新建msyql用户禁止登录shell"><a href="#useradd-r-s-sbin-nologin-g-mysql-mysql-d-usr-local-mysql-—新建msyql用户禁止登录shell" class="headerlink" title="useradd -r -s /sbin/nologin -g mysql mysql -d /usr/local/mysql     —新建msyql用户禁止登录shell"></a>useradd -r -s /sbin/nologin -g mysql mysql -d /usr/local/mysql     —新建msyql用户禁止登录shell</h1><p>6改变目录属有者</p>
<p>#cd /usr/local/mysql<br>#pwd<br>#chown -R mysql .<br>#chgrp -R mysql .</p>
<p>#chown -R mysql /data/mysql</p>
<p>7配置参数</p>
<h1 id="bin-mysqld-–initialize-–user-mysql-–basedir-usr-local-mysql-–datadir-data-mysql"><a href="#bin-mysqld-–initialize-–user-mysql-–basedir-usr-local-mysql-–datadir-data-mysql" class="headerlink" title="bin/mysqld –initialize –user=mysql –basedir=/usr/local/mysql –datadir=/data/mysql"></a>bin/mysqld –initialize –user=mysql –basedir=/usr/local/mysql –datadir=/data/mysql</h1><p> 此处需要注意记录生成的临时密码，如上文结尾处的：YLi&gt;7ecpe;YP<br>#bin/mysql_ssl_rsa_setup  –datadir=/data/mysql</p>
<p>8修改系统配置文件</p>
<p>#cd /usr/local/mysql/support-files</p>
<h1 id="cp-my-default-cnf-etc-my-cnf"><a href="#cp-my-default-cnf-etc-my-cnf" class="headerlink" title="cp my-default.cnf /etc/my.cnf"></a>cp my-default.cnf /etc/my.cnf</h1><h1 id="cp-mysql-server-etc-init-d-mysql"><a href="#cp-mysql-server-etc-init-d-mysql" class="headerlink" title="cp mysql.server /etc/init.d/mysql"></a>cp mysql.server /etc/init.d/mysql</h1><h1 id="vim-etc-init-d-mysql"><a href="#vim-etc-init-d-mysql" class="headerlink" title="vim /etc/init.d/mysql"></a>vim /etc/init.d/mysql</h1><p>修改以下内容：</p>
<p>9启动mysql</p>
<h1 id="etc-init-d-mysql-start"><a href="#etc-init-d-mysql-start" class="headerlink" title="/etc/init.d/mysql start"></a>/etc/init.d/mysql start</h1><p>–登陆</p>
<h1 id="mysql-hlocalhost-uroot-p"><a href="#mysql-hlocalhost-uroot-p" class="headerlink" title="mysql -hlocalhost -uroot -p"></a>mysql -hlocalhost -uroot -p</h1><p>　　–如果出现：-bash: mysql: command not found</p>
<p>　　–就执行： # ln -s /usr/local/mysql/bin/mysql /usr/bin –没有出现就不用执行</p>
<p>–输入第6步生成的临时密码</p>
<p>–修改密码</p>
<p>mysql&gt; set password=password(‘root’);</p>
<p>–设置root账户的host地址（修改了才可以远程连接）</p>
<p>mysql&gt;grant all privileges on <em>.</em> to ‘root’@’%’ identified by ‘root’;<br>mysql&gt;flush privileges;</p>
<p>–查看表</p>
<p>mysql&gt; use mysql;<br>mysql&gt; select host,user from user;</p>
<p>–这里就可以使用远程连接测试了；</p>
<p>10添加系统路径</p>
<h1 id="vim-etc-profile"><a href="#vim-etc-profile" class="headerlink" title="vim /etc/profile"></a>vim /etc/profile</h1><p>添加：<br>export PATH=/usr/local/mysql/bin:$PATH<br>如下：</p>
<h1 id="source-etc-profile"><a href="#source-etc-profile" class="headerlink" title="source /etc/profile"></a>source /etc/profile</h1><p>11配置mysql自动启动</p>
<h1 id="chmod-755-etc-init-d-mysql"><a href="#chmod-755-etc-init-d-mysql" class="headerlink" title="chmod 755 /etc/init.d/mysql"></a>chmod 755 /etc/init.d/mysql</h1><h1 id="chkconfig-–add-mysql"><a href="#chkconfig-–add-mysql" class="headerlink" title="chkconfig –add mysql"></a>chkconfig –add mysql</h1><h1 id="chkconfig-–level-345-mysql-on"><a href="#chkconfig-–level-345-mysql-on" class="headerlink" title="chkconfig –level 345 mysql on"></a>chkconfig –level 345 mysql on</h1><p>以上就是linux环境Mysql 5.7.13安装教程，希望对大家的学习有所帮助。</p>
<p>补充：</p>
<p>–退出mysql命令窗口</p>
<p>#exit</p>
<p> –查看mysql状态</p>
<p>#service mysql status</p>
<p>–停止mysql</p>
<p>#service mysql stop</p>
<p>–启动mysql</p>
<p>#service mysql start</p>
<p>附my.cnf（这是一个配置mysql配置文件，暂时可以不用管，如你想钻研 你可以百度或google “mysql my.cnf 配置详情”）</p>
<p>/etc/my.cnf</p>
<h1 id="For-advice-on-how-to-change-settings-please-see"><a href="#For-advice-on-how-to-change-settings-please-see" class="headerlink" title="For advice on how to change settings please see"></a>For advice on how to change settings please see</h1><h1 id="http-dev-mysql-com-doc-refman-5-7-en-server-configuration-defaults-html"><a href="#http-dev-mysql-com-doc-refman-5-7-en-server-configuration-defaults-html" class="headerlink" title="http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html"></a><a href="http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</a></h1><h1 id="DO-NOT-EDIT-THIS-FILE-It’s-a-template-which-will-be-copied-to-the"><a href="#DO-NOT-EDIT-THIS-FILE-It’s-a-template-which-will-be-copied-to-the" class="headerlink" title="*** DO NOT EDIT THIS FILE. It’s a template which will be copied to the"></a>*** DO NOT EDIT THIS FILE. It’s a template which will be copied to the</h1><h1 id="default-location-during-install-and-will-be-replaced-if-you"><a href="#default-location-during-install-and-will-be-replaced-if-you" class="headerlink" title="*** default location during install, and will be replaced if you"></a>*** default location during install, and will be replaced if you</h1><h1 id="upgrade-to-a-newer-version-of-MySQL"><a href="#upgrade-to-a-newer-version-of-MySQL" class="headerlink" title="*** upgrade to a newer version of MySQL."></a>*** upgrade to a newer version of MySQL.</h1><p>[mysqld]</p>
<h1 id="Remove-leading-and-set-to-the-amount-of-RAM-for-the-most-important-data"><a href="#Remove-leading-and-set-to-the-amount-of-RAM-for-the-most-important-data" class="headerlink" title="Remove leading # and set to the amount of RAM for the most important data"></a>Remove leading # and set to the amount of RAM for the most important data</h1><h1 id="cache-in-MySQL-Start-at-70-of-total-RAM-for-dedicated-server-else-10"><a href="#cache-in-MySQL-Start-at-70-of-total-RAM-for-dedicated-server-else-10" class="headerlink" title="cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%."></a>cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</h1><p>innodb_buffer_pool_size = 10G</p>
<h1 id="Remove-leading-to-turn-on-a-very-important-data-integrity-option-logging"><a href="#Remove-leading-to-turn-on-a-very-important-data-integrity-option-logging" class="headerlink" title="Remove leading # to turn on a very important data integrity option: logging"></a>Remove leading # to turn on a very important data integrity option: logging</h1><h1 id="changes-to-the-binary-log-between-backups"><a href="#changes-to-the-binary-log-between-backups" class="headerlink" title="changes to the binary log between backups."></a>changes to the binary log between backups.</h1><p>log_bin<br>character-set-server=utf8<br>collation-server=utf8_bin<br>init-connect=’SET NAMES utf8’</p>
<h1 id="These-are-commonly-set-remove-the-and-set-as-required"><a href="#These-are-commonly-set-remove-the-and-set-as-required" class="headerlink" title="These are commonly set, remove the # and set as required."></a>These are commonly set, remove the # and set as required.</h1><p>basedir = /usr/local/mysql<br>datadir = /export/mysql/var<br>port = 3306       q<br>server_id = 22206<br>socket = /export/mysql/mysql.sock<br>binlog_format = statement</p>
<h1 id="Remove-leading-to-set-options-mainly-useful-for-reporting-servers"><a href="#Remove-leading-to-set-options-mainly-useful-for-reporting-servers" class="headerlink" title="Remove leading # to set options mainly useful for reporting servers."></a>Remove leading # to set options mainly useful for reporting servers.</h1><h1 id="The-server-defaults-are-faster-for-transactions-and-fast-SELECTs"><a href="#The-server-defaults-are-faster-for-transactions-and-fast-SELECTs" class="headerlink" title="The server defaults are faster for transactions and fast SELECTs."></a>The server defaults are faster for transactions and fast SELECTs.</h1><h1 id="Adjust-sizes-as-needed-experiment-to-find-the-optimal-values"><a href="#Adjust-sizes-as-needed-experiment-to-find-the-optimal-values" class="headerlink" title="Adjust sizes as needed, experiment to find the optimal values."></a>Adjust sizes as needed, experiment to find the optimal values.</h1><p>join_buffer_size = 128M<br>sort_buffer_size = 2M<br>read_rnd_buffer_size = 2M<br>log_bin_trust_function_creators = on<br>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</p>
<p>lower_case_table_names=1</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/分布式开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/07/11/分布式开发/" class="post-title-link" itemprop="url">分布式开发基础</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-07-11 12:26:09" itemprop="dateCreated datePublished" datetime="2018-07-11T12:26:09+08:00">2018-07-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 14:31:21" itemprop="dateModified" datetime="2019-10-11T14:31:21+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式系统架构基础"><a href="#分布式系统架构基础" class="headerlink" title="[分布式系统架构基础]"></a>[分布式系统架构基础]</h1><p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consistency</span><br><span class="line">Availability</span><br><span class="line">Partition tolerance</span><br></pre></td></tr></table></figure>

<p>它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 <code>CAP</code> 定理。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</li>
</ul>
<h3 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h3><p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统采用弱一致性来提高性能，一些不同的一致性模型也相继被提出。</p>
<ul>
<li><strong>强一致性</strong>： 要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</li>
<li><strong>弱一致性</strong>：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li>
<li><strong>最终一致性</strong>：是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。</li>
</ul>
<h4 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h4><ol>
<li>分布式事务：两段提交</li>
<li>分布式锁</li>
<li>MQ 消息持久化 重试 幂等</li>
<li>Paxos 算法</li>
</ol>
<h3 id="服务可用性"><a href="#服务可用性" class="headerlink" title="服务可用性"></a>服务可用性</h3><p>可用性，意思是只要收到用户的请求，服务器就必须给出回应。</p>
<h4 id="高可用解决方案"><a href="#高可用解决方案" class="headerlink" title="高可用解决方案"></a>高可用解决方案</h4><ul>
<li><strong>负载均衡</strong>：</li>
<li><strong>降级</strong>：当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</li>
<li><strong>熔断</strong>：对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞的。再等到目标服务好转后进行接口恢复。</li>
<li><strong>流量控制</strong>：</li>
<li><strong>异地多活</strong>：</li>
</ul>
<p>熔断是减少由于下游服务故障对自己的影响；而降级则是在整个系统的角度上，考虑业务整体流量，保护核心业务稳定。</p>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p>般来说，分区容错无法避免，因此可以认为 CAP 的 <code>P</code> 总是成立。CAP 定理告诉我们，剩下的 <code>C</code> 和 <code>A</code> 无法同时做到。</p>
<h1 id="高并发下的流量控制"><a href="#高并发下的流量控制" class="headerlink" title="高并发下的流量控制"></a>高并发下的流量控制</h1><p>这个时候如果不做任何保护措施，服务器就会承受很大的处理压力，请求量很高，服务器负载也很高，并且当请求超过服务器承载极限的时候，系统就会崩溃，导致所有人都不能访问。</p>
<p>为了应用服务的高可用，一个常用的办法是对大流量的请求（秒杀/抢购）进行限流，拦截掉大部分请求，只允许一部分请求真正进入后端服务器，这样就可以防止大量请求造成系统压力过大导致的系统崩溃，从而保护服务正常可用。</p>
<p><code>令牌桶(Token Bucket)</code>、<code>漏桶(leaky bucket)</code>和 <code>计数器</code> 算法是最常用的三种限流的算法。</p>
<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>计数器限流算法也是比较常用的，主要用来限制总并发数。比如限流 <code>qps</code> 为 <code>100</code> ，算法的实现思路就是从第一个请求进来开始计时，在接下去的 <code>1s</code> 内，每来一个请求，就把计数加 <code>1</code> ，如果累加的数字达到了 <code>100</code> ，那么后续的请求就会被全部拒绝。等到 <code>1s</code> 结束后，把计数恢复成 <code>0</code> ，重新开始计数。</p>
<p>这种实现方式有一个弊端：如果我在单位时间 <code>1s</code> 内的前 <code>10ms</code> ，已经通过了 <code>100</code> 个请求，那后面的 <code>990ms</code> ，只能眼巴巴的把请求拒绝，这种现象称为 <strong>突刺现象</strong>。</p>
<h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><p>为了消除 <strong>突刺现象</strong>，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p>
<p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每 <code>10</code> 毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p>
<p><img src="images/cee6a24bae2f1146d8f905a9ede12c23.png" alt></p>
<p>在算法实现方面，可以 <strong>准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行</strong>。</p>
<p>这种算法，在使用过后也存在弊端：<strong>无法应对短时间的突发流量</strong>，同时它的优点也是可以平滑网络上的突发流量，请求可以被整形成稳定的流量。</p>
<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>从某种意义上讲，<strong>令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用</strong>。</p>
<p>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p>
<p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置 <code>qps</code> 为 <code>100</code> ，那么限流器初始化完成一秒后，桶中就已经有 100 个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的 <code>100</code> 个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p>
<p><img src="images/cc2bf6c40bcccedb3e6bb2471ef36e53.png" alt></p>
<p>实现思路：可以 <strong>准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行</strong>。</p>
<blockquote>
<p>漏桶 VS 令牌桶：两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量。</p>
</blockquote>
<h2 id="集群限流"><a href="#集群限流" class="headerlink" title="集群限流"></a>集群限流</h2><h3 id="Redis-请求窗口"><a href="#Redis-请求窗口" class="headerlink" title="Redis 请求窗口"></a>Redis 请求窗口</h3><blockquote>
<p>采用redis 的计时和计数方式,在规定的时间窗口期,允许通过的最大请求数量</p>
</blockquote>
<p>比如为了限制某个资源被每个用户或者商户的访问次数，5s 只能访问 2 次，或者一天只能调用 1000 次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。</p>
<p>如何实现？为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。</p>
<p>大概思路：每次有相关操作的时候，就向 <code>redis</code> 服务器发送一个 <code>incr</code> 命令，比如需要限制某个用户访问 <code>/index</code> 接口的次数，只需要拼接用户 id 和接口名生成 <code>redis</code> 的 <code>key</code> ，每次该用户访问此接口时，只需要对这个 <code>key</code> 执行 <code>incr</code> 命令，在这个 <code>key</code> 带上过期时间，就可以实现指定时间的访问频率。</p>
<h3 id="Nginx-限流"><a href="#Nginx-限流" class="headerlink" title="Nginx 限流"></a>Nginx 限流</h3><p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。</p>
<p>Nginx官方版本限制IP的连接和并发分别有两个模块：</p>
<ul>
<li><code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。</li>
<li><code>limit_req_conn</code> 用来限制同一时间连接数，即并发限制。</li>
</ul>
<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>高并发环境下，例如典型的淘宝双11秒杀，几分钟内上亿的用户涌入淘宝，这个时候如果访问不加拦截，让大量的读写请求涌向数据库，由于磁盘的处理速度与内存显然不在一个量级，服务器马上就要宕机。<strong>从减轻数据库的压力和提高系统响应速度两个角度来考虑，都会在数据库之前加一层缓存</strong>，访问压力越大的，在缓存之前就开始 CDN 拦截图片等访问请求。</p>
<p>并且由于最早的单台机器的内存资源以及承载能力有限，如果大量使用本地缓存，也会使相同的数据被不同的节点存储多份，对内存资源造成较大的浪费，因此，才催生出了分布式缓存。</p>
<p><img src="images/36bb3e9d1be0ea97b3e836dc467a9c87.png" alt></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><strong>页面缓存</strong>：用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等;</li>
<li><strong>应用对象缓存</strong>：缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问;解决分布式Web部署的 session 同步问题，状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群。</li>
<li><strong>并行处理</strong>：通常涉及大量中间计算结果需要共享;</li>
<li><strong>云计算领域提供分布式缓存服务</strong></li>
</ol>
<h2 id="常见问题和挑战"><a href="#常见问题和挑战" class="headerlink" title="常见问题和挑战"></a>常见问题和挑战</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效、新缓存未到之间(<strong>例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期</strong>)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。<strong>这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空</strong>（<em>相当于进行了两次无用的查询</em>）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外，我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是 <strong>保证核心服务可用，即使是有损的</strong>。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li><strong>一般</strong>：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li><strong>警告</strong>：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li><strong>错误</strong>：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li><strong>严重错误</strong>：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<h3 id="缓存与数据库不一致问题"><a href="#缓存与数据库不一致问题" class="headerlink" title="缓存与数据库不一致问题"></a>缓存与数据库不一致问题</h3><p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>
<p><img src="images/995c5ddf11013119937692d6448da2e8.png" alt></p>
<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。</p>
<p>从理论上来说，给 <strong>缓存设置过期时间，是保证最终一致性的解决方案</strong>。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p>
<h4 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h4><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>可以通过：</p>
<ol>
<li>更新操作数据库后，再次更新缓存来实现</li>
<li>缓存设置过期时间，等待过期时间后，数据恢复</li>
</ol>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。</p>
<h2 id="应用发展流程"><a href="#应用发展流程" class="headerlink" title="应用发展流程"></a>应用发展流程</h2><h3 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="实现基于数据库的乐观锁"><a href="#实现基于数据库的乐观锁" class="headerlink" title="实现基于数据库的乐观锁"></a>实现基于数据库的乐观锁</h2><p>提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">// step 1</span><br><span class="line">int oldVersion = getOldVersion(stmt);</span><br><span class="line"></span><br><span class="line">// step 2</span><br><span class="line">// 用这个数据库连接做其他的逻辑</span><br><span class="line"></span><br><span class="line">// step 3 可用预编译语句</span><br><span class="line">int i = stmt.executeUpdate(</span><br><span class="line">        &quot;update optimistic_lock set version = &quot; + (oldVersion + 1) + &quot; where version = &quot; + oldVersion);</span><br><span class="line"></span><br><span class="line">// step 4</span><br><span class="line">if (i &gt; 0) &#123;</span><br><span class="line">    conn.commit(); // 更新成功表明数据没有被修改，提交事务。</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    conn.rollback(); // 更新失败，数据被修改，回滚。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乐观锁的缺点：</p>
<ul>
<li>会带来大数量的无效更新请求、事务回滚，给DB造成不必要的额外压力。</li>
<li>无法保证先到先得，后面的请求可能由于并发压力小了反而有可能处理成功。</li>
</ul>
<h2 id="基于-Redis-的分布式锁"><a href="#基于-Redis-的分布式锁" class="headerlink" title="基于 Redis 的分布式锁"></a>基于 Redis 的分布式锁</h2><p><a href="../../basic/database/7-redis.md">Redis</a></p>
<h1 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h1><p>当一个带有会话表示的 <code>Http</code> 请求到 <code>Web</code> 服务器后，需求在请求中的处理过程中找到 <code>session</code> 数据。而问题就在于， <code>session</code> 是保存在单机上的。 假设我们有应用A和应用B，现在一位用户第一次访问网站， <code>session</code> 数据保存在 <code>应用A</code> 中。如果我们不做处理，怎么保障接下来的请求每次都请求到 <code>应用A</code> 呢? 如请求到了 <code>应用B</code> 中，就会发现没有这位用户的 <code>session</code> 数据，这绝对是不能容忍的。</p>
<p>解决方案有Session Stick，Session复制，Session集中管理，基于Cookie管理，下面一一说明。</p>
<h2 id="Session-Stick"><a href="#Session-Stick" class="headerlink" title="Session Stick"></a>Session Stick</h2><p>在单机情况， <code>session</code> 保存在单机上，请求也是到这台单机上，不会有问题。变成多台后，如果能保障每次请求都到同一台服务，那就和单机一样了。 这需要在负载均衡设备上修改。这就是 <code>Session Stick</code> ，这种方式也会有问题：</p>
<ul>
<li>如果某一台服务器宕机或重启，那么这台服务器上的 <code>session</code> 数据就丢失了。如果 <code>session</code> 数据中还有登录状态信息，那么用户需要重现登录。</li>
<li>负载均衡要处理具体的 <code>session</code> 到服务器的映射。</li>
</ul>
<h2 id="Session复制"><a href="#Session复制" class="headerlink" title="Session复制"></a>Session复制</h2><p><code>Session</code> 复制顾名思义，就是每台应用服务，都保存会话 <code>session</code> 数据，一般的应用容器都支持。与 <code>Session Stick</code> 相比， <code>sessioon</code> 复制对负载均衡 没有太多的要求。不过这个方案还是有缺点：</p>
<ul>
<li>同步 <code>session</code> 数据带来都网络开销。只要 <code>session</code> 数据变化，就需要同步到所有机器上，机器越多，网络开销越大。</li>
<li>由于每台服务器都保存 <code>session</code> 数据，如果集群的 <code>session</code> 数据很多，比如 90万 人在访问网站，每台机器用于保存 <code>session</code> 数据的内容占用很严重。</li>
</ul>
<p>这就是 <strong>Session 复制</strong>，这个方案是靠应用容器来完成，并不依赖应用，如果应用服务数量并不是很多，可以考虑。</p>
<h2 id="Session集中管理"><a href="#Session集中管理" class="headerlink" title="Session集中管理"></a>Session集中管理</h2><p>这个也很好理解，再加一台服务，专门来管理 <code>session</code> 数据，每台应用服务都从专门的 <code>session</code> 管理服务中取会话 <code>session</code> 数据。可以使用数据库，NOSQL数据库等。 <strong>和Session复制相比，减少了每台应用服务的内存使用，同步session带来的网络开销问题</strong>。但还是有缺点：</p>
<ul>
<li>读写 <code>session</code> 引入了网络操作，相对于本机读写 <code>session</code> ，带来了延时和不稳定性。</li>
<li>如 <code>Session</code> 集中服务有问题，会影响应用。</li>
</ul>
<h2 id="基于Cookie管理"><a href="#基于Cookie管理" class="headerlink" title="基于Cookie管理"></a>基于Cookie管理</h2><p>最后一个是基于 <code>Cookie</code> 管理，我们把 <code>session</code> 数据存放在 <code>cookie</code> 中，然后请求过来后，从 <code>cookie</code> 中获取 <code>session</code> 数据。与集中管理相比，这个方案并不依赖外部 的存储系统，读写 <code>session</code> 数据带来的网络操作延时和不稳定性。但依然有缺点：</p>
<ul>
<li><strong>Cookie有长度限制，这会影响session数据的长度</strong>。</li>
<li><strong>安全性</strong>：session数据本来存储在服务端的，而这个方案是让 <code>session</code> 数据转到外部网络或客户端中，所以会有安全性问题。不过可以对写入 Cookie 的 <code>session</code> 数据做加密。</li>
<li><strong>带宽消耗</strong>：由于加了session数据，带宽当然也会增加一点。</li>
<li><strong>性能消耗</strong>：每次Http请求和响应都带有Session数据，对于Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发请求越多。</li>
</ul>
<h1 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h1><h2 id="使用场景-Scenario"><a href="#使用场景-Scenario" class="headerlink" title="使用场景(Scenario)"></a>使用场景(Scenario)</h2><p>微博和Twitter都有140字数的限制，如果分享一个长网址，很容易就超出限制，发布出去。短网址服务可以把一个长网址变成短网址，方便在社交网络上传播。</p>
<h2 id="需求-Needs"><a href="#需求-Needs" class="headerlink" title="需求(Needs)"></a>需求(Needs)</h2><p>很显然，要尽可能的短。长度设计为多少才合适呢？</p>
<h2 id="短网址的长度"><a href="#短网址的长度" class="headerlink" title="短网址的长度"></a>短网址的长度</h2><p>当前互联网上的网页总数大概是 45亿(参考 短网址<em>短网址资讯<code>mrw.so</code>)，45亿 超过了 <code>2^{32}=4294967296232=4294967296</code>，但远远小于64位整数的上限值，那么用一个64位整数足够了。微博的短网址服务用的是长度为 <code>7</code> 的字符串，这个字符串可以看做是62进制的数，那么最大能表示<code>{62}^7=3521614606208627=3521614606208</code>个网址，远远大于 45亿。所以长度为7就足够了。一个64位整数如何转化为字符串呢？，假设我们只是用大小写字母加数字，那么可以看做是62进制数，`log</em>{62{(2^{64}-1)=10.7log62(264−1)=10.7`，即字符串最长11就足够了。实际生产中，还可以再短一点，比如新浪微博采用的长度就是7，因为 62^7=3521614606208627=3521614606208，这个量级远远超过互联网上的URL总数了，绝对够用了。现代的web服务器（例如Apache, Nginx）大部分都区分URL里的大小写了，所以用大小写字母来区分不同的URL是没问题的。因此，正确答案：长度不超过7的字符串，由大小写字母加数字共62个字母组成。</p>
<h2 id="一对一还是一对多映射？"><a href="#一对一还是一对多映射？" class="headerlink" title="一对一还是一对多映射？"></a>一对一还是一对多映射？</h2><p>一个长网址，对应一个短网址，还是可以对应多个短网址？ 这也是个重大选择问题。一般而言，一个长网址，在不同的地点，不同的用户等情况下，生成的短网址应该不一样，这样，在后端数据库中，可以更好的进行数据分析。如果一个长网址与一个短网址一一对应，那么在数据库中，仅有一行数据，无法区分不同的来源，就无法做数据分析了。</p>
<p>以这个7位长度的短网址作为唯一ID，这个ID下可以挂各种信息，比如生成该网址的用户名，所在网站，HTTP头部的 User Agent等信息，收集了这些信息，才有可能在后面做大数据分析，挖掘数据的价值。短网址服务商的一大盈利来源就是这些数据。</p>
<p>正确答案：一对多</p>
<h2 id="如何计算短网址"><a href="#如何计算短网址" class="headerlink" title="如何计算短网址"></a>如何计算短网址</h2><p>现在我们设定了短网址是一个长度为7的字符串，如何计算得到这个短网址呢？</p>
<p>最容易想到的办法是哈希，先hash得到一个64位整数，将它转化为62进制整，截取低7位即可。但是哈希算法会有冲突，如何处理冲突呢，又是一个麻烦。这个方法只是转移了矛盾，没有解决矛盾，抛弃。</p>
<p>正确答案：分布式发号器(<code>Distributed ID Generator</code>)</p>
<h2 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h2><p>如果存储短网址和长网址的对应关系？以短网址为 <code>primary key</code>, 长网址为<code>value</code>, 可以用传统的关系数据库存起来，例如<code>MySQL,PostgreSQL</code>，也可以用任意一个分布式 KV 数据库，例如<code>Redis, LevelDB</code>。</p>
<h2 id="301还是302重定向"><a href="#301还是302重定向" class="headerlink" title="301还是302重定向"></a>301还是302重定向</h2><p>这也是一个有意思的问题。这个问题主要是考察你对301和302的理解，以及浏览器缓存机制的理解。</p>
<p>301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， <code>Google</code>，<code>百度</code>等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的<code>Cookie</code>, <code>User Agent</code> 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。</p>
<p>所以，正确答案是302重定向。</p>
<p>可以抓包看看mrw.so的短网址是怎么做的，使用 Chrome 浏览器，访问这个URL <code>http://mrw.so/4UD39p</code>，是我事先发微博自动生成的短网址。来抓包看看返回的结果是啥，可见新浪微博用的就是302临时重定向。</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><a href="https://draveness.me/distributed-transaction-principle" target="_blank" rel="noopener">分布式事务</a></h1><p>系统之间的通信可靠性从单一系统中的可靠变成了微服务架构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。<strong>无论是事务还是分布式事务实现原子性都无法避免对持久存储的依赖</strong>，事务使用磁盘上的日志记录执行的过程以及上下文，这样无论是需要回滚还是补偿都可以通过日志追溯，而分布式事务也会依赖 数据库、<code>Zookeeper</code> 或者 <code>ETCD</code> 等服务追踪事务的执行过程，总而言之，各种形式的日志是保证事务几大特性的 <strong>重要</strong> 手段。</p>
<h2 id="2PC-与-3PC"><a href="#2PC-与-3PC" class="headerlink" title="2PC 与 3PC"></a>2PC 与 3PC</h2><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>两阶段提交的执行过程就跟它的名字一样分为两个阶段，<strong>投票阶段和提交阶段</strong>，在投票阶段中，协调者（<code>Coordinator</code>）会向事务的参与者（<code>Cohort</code>）询问是否可以执行操作的请求，并等待其他参与者的响应，参与者会执行相对应的事务操作并 <strong>记录重做和回滚日志</strong>，所有执行成功的参与者会向协调者发送 <code>AGREEMENT</code> 或者 <code>ABORT</code> 表示执行操作的结果。</p>
<p><img src="images/42e2b6be95abf864362b7e646fea18aa.png" alt="image"></p>
<p>当所有的参与者都返回了确定的结果（同意或者终止）时，两阶段提交就进入了提交阶段，协调者会根据投票阶段的返回情况向所有的参与者发送提交或者回滚的指令。</p>
<p><img src="images/c3cf164028d6832a3465def010665ec3.png" alt="image"></p>
<p>当事务的所有参与者都决定提交事务时，协调者会向参与者发送 <code>COMMIT</code> 请求，参与者在完成操作并释放资源之后向协调者返回完成消息，协调者在收到所有参与者的完成消息时会结束整个事务；与之相反，当有参与者决定 <code>ABORT</code> 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会根据之前执行操作时的回滚日志对操作进行回滚并向协调者发送完成的消息，在提交阶段，无论当前事务被提交还是回滚，所有的资源都会被释放并且事务也一定会结束。</p>
<p>两阶段提交协议是一个阻塞协议，也就是说在两阶段提交的执行过程中，除此之外，如果事务的执行过程中协调者永久宕机，事务的一部分参与者将永远无法完成事务，它们会等待协调者发送 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 消息，甚至会出现多个参与者状态不一致的问题。</p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>为了解决两阶段提交在协议的一些问题，<strong>三阶段提交引入了超时机制和准备阶段</strong>，如果协调者或者参与者在规定的之间内没有接受到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务，准备阶段的引入其实让事务的参与者有了除回滚之外的其他选择。</p>
<p><img src="images/b1f224cb62e2257103969df6b2b02320.png" alt="image"></p>
<p>当参与者向协调者发送 <code>ACK</code> 后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交中被阻塞住；上述的图片非常清楚地说明了在不同阶段，协调者或者参与者的超时会造成什么样的行为。</p>
<h2 id="消息服务"><a href="#消息服务" class="headerlink" title="消息服务"></a>消息服务</h2><p>分布式事务带来复杂度的原因其实就是由于各个模块之间的通信不稳定，当我们发出一个网络请求时，可能的返回结果是成功、失败或者超时。</p>
<p><img src="images/5479e5bb2009261c1c1f4aa2524c5e48.png" alt="image"></p>
<p>网络无论是返回成功还是失败其实都是一个确定的结果，当网络请求超时的时候其实非常不好处理，在这时调用方并不能确定这一次请求是否送达而且不会知道请求的结果，但是 <strong>消息服务</strong> 可以保证某条信息一定会送达到调用方；大多数消息服务都会提供两种不同的 <code>QoS</code> ，也就是服务的等级。</p>
<p><img src="images/53847a86544edeb54059110633da692c.png" alt="image"></p>
<p>最常见的两种服务等级就是 <code>At-Most-Once</code> 和 <code>At-Least-Once</code> 。</p>
<ul>
<li><code>At-Most-Once</code>：能够保证发送方不对接收方是否能收到消息作保证，消息要么会被投递一次，要么不会被投递，这其实跟一次普通的网络请求没有太多的区别；</li>
<li><code>At-Least-Once</code>：能够解决消息投递失败的问题，它要求发送者检查投递的结果，并在失败或者超时时重新对消息进行投递，发送者会持续对消息进行推送，直到接受者确认消息已经被收到</li>
</ul>
<blockquote>
<p>相比于 <code>At-Most-Once</code>，<code>At-Least-Once</code> 因为能够确保消息的投递会被更多人使用。</p>
</blockquote>
<p>除了这两种常见的服务等级之外，还有另一种服务等级，也就是 <code>Exactly-Once</code>，这种服务等级不仅对发送者提出了要求，还对消费者提出了要求，它需要接受者对接收到的所有消息进行去重，发送者和接受者一方对消息进行重试，另一方对消息进行去重，两者分别部署在不同的节点上，这样对于各个节点上的服务来说，它们之间的通信就是 <code>Exactly-Once</code> 的，但是需要注意的是，<code>Exacly-Once</code> 一定需要接收方的参与。</p>
<p>使用消息服务实现分布式事务在底层的原理上与其他的方法没有太多的差别，只是 <strong>消息服务能够帮助我们实现的消息的持久化以及重试等功能</strong>，能够为我们提供一个比较合理的 API 接口，方便开发者使用。</p>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><a href="https://draveness.me/zookeeper-chubby" target="_blank" rel="noopener">Zookeeper</a></h1><blockquote>
<p>ZK 不是解决分布式问题的银弹</p>
</blockquote>
<h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>分布式应用可以在给定时间（同时）在网络中的多个系统上运行，通过协调它们以快速有效的方式完成特定任务。通常来说，<strong>对于复杂而耗时的任务，非分布式应用（运行在单个系统中）需要几个小时才能完成，而分布式应用通过使用所有系统涉及的计算能力可以在几分钟内完成</strong>。</p>
<p>通过将分布式应用配置为在更多系统上运行，可以进一步减少完成任务的时间。分布式应用正在运行的一组系统称为 <strong>集群</strong>，而在集群中运行的每台机器被称为 <strong>节点</strong>。</p>
<h3 id="分布式应用的优点"><a href="#分布式应用的优点" class="headerlink" title="分布式应用的优点"></a>分布式应用的优点</h3><ul>
<li>可靠性：单个或几个系统的故障不会使整个系统出现故障。</li>
<li>可扩展性：可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。</li>
<li>透明性：隐藏系统的复杂性，并将其显示为单个实体/应用程序。</li>
</ul>
<h3 id="分布式应用的挑战"><a href="#分布式应用的挑战" class="headerlink" title="分布式应用的挑战"></a>分布式应用的挑战</h3><ul>
<li>竞争条件：两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。</li>
<li>死锁：两个或多个操作等待彼此无限期完成。</li>
<li>不一致：数据的部分失败。</li>
</ul>
<h2 id="ZooKeeper基础"><a href="#ZooKeeper基础" class="headerlink" title="ZooKeeper基础"></a>ZooKeeper基础</h2><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p>
<p>ZooKeeper 的好处：</p>
<ul>
<li>简单的分布式协调过程</li>
<li>同步：服务器进程之间的相互排斥和协作。</li>
<li>有序性</li>
<li>序列化：根据特定规则对数据进行编码(Jute)。</li>
<li>可靠性</li>
<li>原子性：数据转移完全成功或完全失败，但没有事务是部分的。</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>一个 ZooKeeper 集群通常由一组机器组成，一般 3 台以上就可以组成一个可用的 ZooKeeper 集群了。组成 <code>ZooKeeper</code> 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都会互相保持通信。 ZooKeeper 本身就是一个 <strong>复制和分布式</strong> 应用程序，其目的作为服务运行，类似于我们运行 DNS 或任何其他集中式服务的方式。</p>
<blockquote>
<p>ZK 集群 <strong>半数以上存活</strong> 即可用</p>
</blockquote>
<p>ZooKeeper 的客户端程序会选择和集群中的任意一台服务器创建一个 TCP 连接，而且一旦客户端和服务器断开连接，客户端就会自动连接到集群中的其他服务器。</p>
<p><img src="images/cde28984c2c32a5068b2b31d5ba2040f.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">部分</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Client（客户端）</td>
<td align="left">客户端是我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。</td>
</tr>
<tr>
<td align="left">Server（服务器）</td>
<td align="left">服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。</td>
</tr>
<tr>
<td align="left">ZooKeeper Service</td>
<td align="left">ZooKeeper服务器组。形成 Service 所需的最小节点数为3。</td>
</tr>
<tr>
<td align="left">Leader</td>
<td align="left">服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。</td>
</tr>
<tr>
<td align="left">Follower</td>
<td align="left">用于接受客户端请求并向客户端返回结果，在选主过程中参与投票</td>
</tr>
<tr>
<td align="left">Observer</td>
<td align="left">接受客户端连接，将写请求转发给leader，但 observer <strong>不参与</strong> 投票过程，只同步 leader 的状态， observer 的目的是为了扩展系统，提高读取速度</td>
</tr>
</tbody></table>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><img src="images/944a3ed0ab807a87b5c562c58a31ea2b.png" alt="image"></p>
<p>到znode是一个标准的文件系统，层次结构很像一棵树。 需要注意的一些要点如下：</p>
<ul>
<li>根节点有一个名为 <code>/zoo</code> 的子节点，它又有三个 <code>znode</code> 。</li>
<li>ZooKeeper 树中的每个 <code>znode</code> 都由一个路径标识，路径元素由<code>/</code>分隔。</li>
<li>这些节点被称为数据寄存器，因为它们可以存储数据。 因此，一个 znode 可以有子节点以及与之相关的数据。 这与文件系统可以把文件作为路径很类似。</li>
</ul>
<p>znode 中的数据通常以字节格式存储，<strong>每个 znode 中的最大数据大小不超过1 MB</strong>。 ZooKeeper 是为协调而设计的，几乎所有形式的协调数据都比较小， 因此，对数据大小的限制是强制的。</p>
<p>与文件系统中的文件一样， <code>znode</code> 维护一个 <code>stat</code> 结构，其中包含数据更改的 <strong>版本号</strong> 以及随更改相关的时间戳而更改的 <strong>访问控制列表（ACL）</strong>。 只要 znode 的数据发生变化，版本号就会增加。 ZooKeeper 使用版本号以及相关的时间戳来验证它的核心内缓存。 znode 版本号还允许客户端通过 ZooKeeper API 更新或删除特定的 znode。 如果指定的版本号与 znode 的当前版本不匹配，则操作失败。 但是，执行 znode 更新或删除操作时，可以通过指定 0 作为版本号来覆盖。</p>
<h3 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h3><ul>
<li><strong>persistent</strong>：即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。</li>
<li><strong>ephemeral</strong>：客户端活跃时，临时节点就是有效的。当客户端与 ZooKeeper 集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在 leader 选举中起着重要作用。</li>
<li><strong>sequential</strong>：顺序节点可以是持久的或临时的。当一个新的 znode 被创建为一个顺序节点时，ZooKeeper 通过将 <strong>10位</strong> 的序列号附加到原始名称来设置 znode 的路径。例如，如果将具有路径 <code>/myapp</code> 的znode创建为顺序节点，则ZooKeeper会将路径更改为 <code>/myapp0000000001</code> ，并将下一个序列号设置为<code>0000000002</code>。如果两个顺序节点是同时创建的，那么 ZooKeeper <strong>不会对每个znode使用相同的数字</strong>。顺序节点在锁定和同步中起重要作用。</li>
</ul>
<h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><p>会话对于 ZooKeeper 的操作非常重要。会话中的请求按 FIFO 顺序执行。一旦客户端连接到服务器，将建立会话并向客户端分配 <strong>会话ID</strong> 。</p>
<p>客户端 <strong>以特定的时间间隔发送心跳</strong> 以保持会话有效。如果 ZooKeeper 集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。</p>
<p>会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>ZooKeeper</code> 的设计是一种可伸缩的、健壮的集中式服务。在客户端访问此类服务时，常见的设计模式是通过轮询或拉式（pull）模型。当在大型和复杂的分布式系统中实现时，拉模型常常会受到可伸缩性问题的影响。为了解决这个问题，ZooKeeper设计了一种机制，<strong>客户端可以从 ZooKeeper 服务中获取通知。客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据</strong>。</p>
<p>客户可以使用 <code>ZooKeeper</code> 服务注册与 <code>znode</code> 相关的任何更改。 这种注册被称为在 <code>ZooKeeper</code> 术语中的 <code>znode</code> 上设置 <code>watch</code>。 监视允许客户以任何方式更改 <code>znode</code> 时收到通知。 <strong><code>Watcher</code> 是一次性操作</strong>，这意味着它只触发一个通知。 要继续接收通知，客户必须在收到每个事件通知后重新注册一个监视。</p>
<p>监视触发：</p>
<ul>
<li>对 znode 数据的任何更改，例如使用 <code>setData</code> 操作将新数据写入 znode 的数据字段时。</li>
<li>对 znode 的子节点的任何更改。 例如，一个 znode 的子节点被删除。</li>
<li>正在创建或删除的 znode ，如果将新的 znode 添加到路径中或现有的 znode 被删除，则可能发生这种情况。</li>
</ul>
<p>同样，ZooKeeper 针对监视和通知声明以下保证：</p>
<ul>
<li>ZooKeeper 确保监视始终以先进先出（FIFO）方式排序，并且通知总是按顺序发送</li>
<li>在对同一个 znode 进行任何其他更改之前，监视会将通知发送给客户端</li>
<li>监视事件的顺序是按照 ZooKeeper 服务的更新顺序排列的</li>
</ul>
<h2 id="Zookeeper-工作流程"><a href="#Zookeeper-工作流程" class="headerlink" title="Zookeeper 工作流程"></a>Zookeeper 工作流程</h2><p>一旦 ZooKeeper 集合启动，它将等待客户端连接。客户端将连接到 ZooKeeper 集合中的一个节点。它可以是 leader 或 follower 节点。一旦客户端被连接，节点将向特定客户端分配 <code>会话ID</code> 并向该客户端发送确认。如果客户端没有收到确认，它将尝试连接 ZooKeeper 集合中的另一个节点。 一旦连接到节点，客户端将以有规律的间隔向节点发送 <strong>心跳</strong>，以确保连接不会丢失。</p>
<ul>
<li><p><strong>如果客户端想要读取特定的znode</strong>，它将会向具有znode路径的节点发送读取请求，并且节点通过从其自己的数据库获取来返回所请求的znode。为此，在ZooKeeper集合中读取速度很快。</p>
</li>
<li><p><strong>如果客户端想要将数据存储在ZooKeeper集合中</strong>，则会将 znode 路径和数据发送到服务器。<strong>连接的服务器将该请求转发给 leader，然后leader将向所有的follower重新发出写入请求。如果只有大部分节点成功响应，而写入请求成功，则成功返回代码将被发送到客户端</strong>。 否则，写入请求失败。绝大多数节点被称为 Quorum 。</p>
</li>
</ul>
<h3 id="ZooKeeper-Service-节点数量的影响"><a href="#ZooKeeper-Service-节点数量的影响" class="headerlink" title="ZooKeeper Service 节点数量的影响"></a>ZooKeeper Service 节点数量的影响</h3><ul>
<li>如果我们有 <strong>单个节点</strong>，则当该节点故障时，ZooKeeper Service 将故障。即“单点故障”，不建议在生产环境中使用。</li>
<li>如果我们有 <strong>两个节点</strong> 而一个节点故障，我们没有占多数，ZooKeeper Service 故障，因为两个中的一个不是多数。</li>
<li>如果我们有 <strong>三个节点</strong> 而一个节点故障，那么我们有大多数，因此，这是 <strong>最低要求</strong>。ZooKeeper集合在实际生产环境中必须至少有三个节点。</li>
<li>如果我们有 <strong>四个节点</strong> 而两个节点故障，它将再次故障。类似于有三个节点，额外节点不用于任何目的，因此，最好添加奇数的节点，例如 3，5，7。</li>
</ul>
<p>我们知道写入过程比 ZooKeeper 集合中的读取过程要耗时，因为 <strong>所有节点都需要在数据库中写入相同的数据</strong>。因此，对于平衡的环境拥有较少数量（例如3，5，7）的节点比拥有大量的节点要好。</p>
<h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>下面任何一种情况，都会触发 Leader 选举：</p>
<ul>
<li>启动时，集群服务器刚启动</li>
<li>运行时，Leader 崩溃</li>
</ul>
<p>服务器的状态流转：</p>
<p><img src="images/641361c1efdb212bdba9b74168d6334b.png" alt="image"></p>
<p>Leader 选举过程，本质就是 <strong>广播优先级消息</strong> 的过程，选出 <strong>数据最新的服务节点</strong>，选出优先级最高的服务节点，基本步骤：</p>
<ul>
<li>各个服务器节点，广播自己的优先级标识 <code>(sid，zxid)</code></li>
<li>服务器节点收到其他广播消息后，跟自己的优先级对比，自己优先级低，则变更当前节点投票的优先级<code>(sid，zxid)</code> ，并广播变更后的结果</li>
<li>当任意一个服务器节点收到的投票数，超过了法定数量(<code>quorum</code>)，则，升级为 Leader，并广播结果。</li>
</ul>
<p><img src="images/7ca755dfe9b16f9c130f5de492549a86.png" alt="image"></p>
<blockquote>
<ul>
<li>由于网络延时，节点得不到足够多广播信息时，会做出错误的投票判断，纠正过程更耗时</li>
<li>选举过程中，服务器节点会等待一定时间，再广播投票信息，时间间隔一般设定为 200 ms</li>
<li>上面 Leader 选举，采取事件触发 Push 方式 广播消息，称为 快速 Leader 选举，因为之前的 Leader 选举，采用 Pull 方式，每隔 1s 拉取一次。</li>
</ul>
</blockquote>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>通过 Zookeeper 进行数据的发布与订阅其实可以说是它提供的最基本功能，它能够允许多个客户端同时订阅某一个节点的变更并在变更发生时执行我们预先设置好的回调函数，在运行时改变服务的配置和行为</p>
<h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>除了实现服务配置数据的发布与订阅功能，Zookeeper 还能帮助分布式系统实现命名服务，在每一个分布式系统中，客户端应用都有根据指定名字获取资源、服务器地址的需求，在这时就要求整个集群中的全部服务有着唯一的名字。</p>
<p>在大型分布式系统中，有两件事情非常常见，一是不同服务之间的可能拥有相同的名字，另一个是同一个服务可能会在集群中部署很多的节点，Zookeeper 就可以通过文件系统和顺序节点解决这两个问题。</p>
<p><img src="images/72025ab7142520ce9e59193eb956b900.png" alt="image"></p>
<h3 id="协调分布式事务"><a href="#协调分布式事务" class="headerlink" title="协调分布式事务"></a>协调分布式事务</h3><p>Zookeeper 的另一个作用就是担任分布式事务中的协调者角色，在之前介绍 分布式事务 的文章中我们曾经介绍过分布式事务本质上都是通过 2PC 来实现的，在两阶段提交中就需要一个协调者负责协调分布式事务的执行。</p>
<p>所有的事务参与者会向当前节点中写入提交或者终止，一旦当前的节点改变了事务的状态，其他节点就会得到通知，如果出现一个写入终止的节点，所有的节点就会回滚对分布式事务进行回滚。</p>
<h3 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在数据库中，锁的概念其实是非常重要的，常见的关系型数据库就会对排他锁和共享锁进行支持，而 <code>Zookeeper</code> 提供的 API 也可以让我们非常简单的实现分布式锁。</p>
<p>作为分布式协调服务，Zookeeper 的应用场景非常广泛，不仅能够用于服务配置的下发、命名服务、协调分布式事务以及分布式锁，还能够用来实现微服务治理中的服务注册以及发现等功能，这些其实都源于 Zookeeper 能够提供高可用的分布式协调服务，能够为客户端提供分布式一致性的支持。</p>
<h2 id="ZooKeeper-的缺陷"><a href="#ZooKeeper-的缺陷" class="headerlink" title="ZooKeeper 的缺陷"></a>ZooKeeper 的缺陷</h2><h3 id="zookeeper-不是为高可用性设计的"><a href="#zookeeper-不是为高可用性设计的" class="headerlink" title="zookeeper 不是为高可用性设计的"></a>zookeeper 不是为高可用性设计的</h3><ol>
<li>由于要跨机房容灾，很多系统实际上是需要跨机房部署的。出于性价比的考虑我们通常会让多个机房同时工作，而不会搭建N倍的冗余。也就是说单个机房肯定撑不住全流量（你能设想谷歌在全球只剩下一个机房在干活吗）。由于 zookeeper 集群只能有一个 master，因此一旦机房之间连接出现故障，zookeeper master 就只能照顾一个机房，其他机房运行的业务模块由于没有 master 都只能停掉。于是所有流量集中到有 master 的那个机房，于是系统 crash。</li>
<li>即使是在同一个机房里面，由于网段的不同，在调整机房交换机的时候偶尔也会发生网段隔离的情况。实际上机房每个月基本上都会发生短暂的网络隔离之类的子网段调整。在那个时刻 zookeeper 将处于不可用状态。如果整个业务系统基于 zookeeper （比如要求每个业务请求都先去 zookeeper 获取业务系统的master地址），则系统的可用性将非常脆弱。</li>
<li>由于 zookeeper 对于网络隔离的极度敏感，导致 zookeeper 对于网络的任何风吹草动都会做出激烈反应。这使得 zookeeper 的‘不可用’时间比较多，我们不能让 zookeeper 的‘不可用’，变成系统的不可用。</li>
</ol>
<h3 id="zookeeper-的选举过程速度很慢"><a href="#zookeeper-的选举过程速度很慢" class="headerlink" title="zookeeper 的选举过程速度很慢"></a>zookeeper 的选举过程速度很慢</h3><ol>
<li>这是一个很难从理论分析上看到的弱点，但是你一旦遇到就会痛不欲生。</li>
<li>前面我们已经说过，网络实际上常常是会出现隔离等不完整状态的，而 zookeeper 对那种情况非常敏感。一旦出现网络隔离， zookeeper 就要发起选举流程。</li>
<li>zookeeper 的选举流程通常耗时 30 到 120 秒，期间 zookeeper 由于没有master，都是不可用的。</li>
<li>对于网络里面偶尔出现的，比如半秒一秒的网络隔离，zookeeper 会由于选举过程，而把不可用时间放大几十倍。</li>
</ol>
<h3 id="zookeeper-的性能是有限的"><a href="#zookeeper-的性能是有限的" class="headerlink" title="zookeeper 的性能是有限的"></a>zookeeper 的性能是有限的</h3><ol>
<li>典型的 zookeeper 的 tps(transaction peer secondes) 大概是一万多，无法覆盖系统内部每天动辄几十亿次的调用。因此每次请求都去 zookeeper 获取业务系统 master 信息是不可能的。</li>
<li>因此 zookeeper 的 client 必须自己缓存业务系统的 master 地址。</li>
<li>因此 zookeeper 提供的‘强一致性’实际上是不可用的。如果我们需要强一致性，还需要其他机制来进行保障：比如用自动化脚本把业务系统的 old master 给 kill 掉，但是那会有很多陷阱。</li>
</ol>
<h3 id="zookeeper-无法进行有效的权限控制"><a href="#zookeeper-无法进行有效的权限控制" class="headerlink" title="zookeeper 无法进行有效的权限控制"></a>zookeeper 无法进行有效的权限控制</h3><ol>
<li>zookeeper 的权限控制非常薄弱</li>
<li>在大型的复杂系统里面，使用 zookeeper 必须自己再额外的开发一套权限控制系统，通过那套权限控制系统再访问 zookeeper</li>
<li>额外的权限控制系统不但增加了系统复杂性和维护成本，而且降低了系统的总体性能</li>
</ol>
<h3 id="即使有了-zookeeper-也很难避免业务系统的数据不一致"><a href="#即使有了-zookeeper-也很难避免业务系统的数据不一致" class="headerlink" title="即使有了 zookeeper 也很难避免业务系统的数据不一致"></a>即使有了 zookeeper 也很难避免业务系统的数据不一致</h3><ol>
<li>前面已经讨论过了，由于 zookeeper 的性能限制，我们无法让每次系统内部调用都走 zookeeper ，因此总有某些时刻，业务系统会存在两个 master（业务系统 client 那边缓存的业务系统 master 信息是定时从 zookeeper 更新的，因此会有更新不同步的问题）。</li>
<li>如果要在业务系统 client 的 master 信息不一致的情况下，仍要保持系统的数据一致性的方法是 <em>先 kill 掉老 master ，再在  zookeeper 上更新 master 信息</em>。但是在是否要 kill current master 这个问题上，程序是无法完全自动决定的（因为网络隔离的时候zookeeper已经不可用了，自动脚本没有全局信息，不管怎么做都可能是错的，什么都不做也可能是错的。当网络故障的时候，只有运维人员才有全局信息，程序是无法接电话得知其他机房的情况的）。因此系统无法自动的保障数据一致性，必须要人工介入。而人工介入的典型时间是半个小时以上，我们不能让系统这么长时间不可用。因此我们必须在某个方向上进行妥协，最常见的妥协方式是放弃 ‘强一致性’，而接受‘最终一致性’。</li>
<li>如果我们需要人工介入才能保证‘可靠的强一致性’，那么 zookeeper 的价值就大打折扣。</li>
</ol>
<h3 id="Zookeeper-并不保证读取的是最新数据"><a href="#Zookeeper-并不保证读取的是最新数据" class="headerlink" title="Zookeeper 并不保证读取的是最新数据"></a>Zookeeper 并不保证读取的是最新数据</h3><p>ZooKeeper 并不保证在每个实例中，两个不同的客户端将具有相同的 ZooKeeper 数据的视图。由于诸如网络延迟的因素，一个客户端可以在另一客户端被通知该改变之前执行更新，考虑两个客户端A和B的场景。如果客户端A将 <code>/a</code> 的值从 <code>0</code> 设置为 <code>1</code> ，客户端B读取 <code>/a</code> ，客户端 B 可以读取旧值 0，这取决于它连接到的服务器。如果客户端A 和客户端B 读取相同的值很重要，则客户端B应该在执行读取之前从 ZooKeeper API 方法调用 <code>sync()</code> 方法。</p>
<p>对于 Zookeeper 来说，它实现了A可用性、P分区容错性、C中的写入强一致性，丧失的是C中的读取一致性。</p>
<h3 id="我们能做什么"><a href="#我们能做什么" class="headerlink" title="我们能做什么"></a>我们能做什么</h3><ol>
<li>我们或者选择人工介入的强一致性，或者选择程序自动化进行的弱一致性。需要进行取舍。</li>
<li>最终一致性甚至未必是程序来做的，有时候人工修正数据反而在灵活、可靠、低成本上有优势。这需要权衡。</li>
<li>不要迷信zookeeper，有时候不妨考虑一下主备数据库。数据库自带权限控制，用起来比zookeeper方便多了。</li>
<li>zookeeper 比较有价值的东西也许是内容变化的时候，可以阻塞回调的方式通知所有在线的 client 实时更新信息，但这个功能用处不大。</li>
</ol>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>这段时间来，也在和公司里的一些同学交流使用zk的心得，整理了一些常见的zookeeper问题。这个页面的目标是解答一些zk常见的使用问题，同时也让大家明确zk不能干什么。页面会一直更新。</p>
<h3 id="1-客户端对-ServerList-的轮询机制是什么"><a href="#1-客户端对-ServerList-的轮询机制是什么" class="headerlink" title="1. 客户端对 ServerList 的轮询机制是什么"></a>1. 客户端对 ServerList 的轮询机制是什么</h3><p>随机，客户端在初始化( <code>new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)</code> )的过程中，将所有 <code>Server</code> 保存在一个 <code>List</code> 中，然后随机打散，形成一个环。之后从 0 号位开始一个一个使用。两个注意点：</p>
<ol>
<li>Server地址能够重复配置，这样能够弥补客户端无法设置Server权重的缺陷，但是也会加大风险。（比如: <code>192.168.1.1:2181,192.168.1.1:2181,192.168.1.2:2181</code>).</li>
<li>如果客户端在进行 <code>Server</code> 切换过程中耗时过长，那么将会收到 <code>SESSION_EXPIRED</code> . 这也是上面第1点中的加大风险之处。</li>
</ol>
<h3 id="2-客户端如何正确处理-CONNECTIONLOSS-连接断开-和-SESSIONEXPIRED-Session-过期-两类连接异常"><a href="#2-客户端如何正确处理-CONNECTIONLOSS-连接断开-和-SESSIONEXPIRED-Session-过期-两类连接异常" class="headerlink" title="2. 客户端如何正确处理 CONNECTIONLOSS (连接断开) 和 SESSIONEXPIRED (Session 过期)两类连接异常"></a>2. 客户端如何正确处理 CONNECTIONLOSS (连接断开) 和 SESSIONEXPIRED (Session 过期)两类连接异常</h3><p>在 ZooKeeper 中，服务器和客户端之间维持的是一个 <strong>长连接</strong>，在 <code>SESSION_TIMEOUT</code> 时间内，服务器会确定客户端是否正常连接(客户端会定时向服务器发送 <code>heart_beat</code> ),服务器重置下次 <code>SESSION_TIMEOUT</code> 时间。因此，在正常情况下， <code>Session</code> 一直有效，并且 <strong><code>zk</code> 集群所有机器上都保存这个 <code>Session</code> 信息</strong>。在出现问题情况下，客户端与服务器之间连接断了（客户端所连接的那台zk机器挂了，或是其它原因的网络闪断），这个时候客户端会主动在地址列表（初始化的时候传入构造方法的那个参数 <code>connectString</code> ）中选择新的地址进行连接。  </p>
<p>好了，上面基本就是服务器与客户端之间维持长连接的过程了。在这个过程中，用户可能会看到两类异常 <code>CONNECTIONLOSS</code> (连接断开) 和 <code>SESSIONEXPIRED</code> (Session 过期)。</p>
<ul>
<li><code>CONNECTIONLOSS</code> ：应用在进行操作A时，发生了 <code>CONNECTIONLOSS</code> ，此时用户不需要关心我的会话是否可用，应用所要做的就是等待客户端帮我们自动连接上新的 <code>zk</code> 机器，一旦成功连接上新的 <code>zk</code> 机器后，确认刚刚的操作A是否执行成功了。  </li>
<li><code>SESSIONEXPIRED</code> ：这个通常是zk客户端与服务器的连接断了，试图连接上新的 <code>zk</code> 机器，这个过程如果耗时过长，超过 <code>SESSION_TIMEOUT</code> 后还没有成功连接上服务器，那么服务器认为这个 <code>session</code> 已经结束了（服务器无法确认是因为其它异常原因还是客户端主动结束会话），开始清除和这个会话有关的信息，包括这个会话创建的临时节点和注册的 <code>Watcher</code> 。在这之后，客户端重新连接上了服务器在，但是很不幸，服务器会告诉客户端 <code>SESSIONEXPIRED</code> 。此时客户端要做的事情就看应用的复杂情况了，总之，要重新实例 <code>zookeeper</code> 对象，重新操作所有临时数据（包括临时节点和注册 <code>Watcher</code> ）。</li>
</ul>
<h3 id="3-不同的客户端对同一个节点是否能获取相同的数据"><a href="#3-不同的客户端对同一个节点是否能获取相同的数据" class="headerlink" title="3. 不同的客户端对同一个节点是否能获取相同的数据"></a>3. 不同的客户端对同一个节点是否能获取相同的数据</h3><h3 id="4-一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗"><a href="#4-一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗" class="headerlink" title="4. 一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗"></a>4. 一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗</h3><p><code>ZooKeeper</code> <strong>不能确保任何客户端能够获取（即 <code>Read Request</code> ）到一样的数据</strong>，除非客户端自己要求：方法是客户端在获取数据之前调用<code>org.apache.zookeeper.AsyncCallback.VoidCallback, java.lang.Object) sync</code>.  </p>
<p>通常情况下（这里所说的通常情况满足：1. 对获取的数据是否是最新版本不敏感，2. 一个客户端修改了数据，其它客户端需要不需要立即能够获取最新），可以不关心这点。  </p>
<p>在其它情况下，最清晰的场景是这样：ZK 客户端 A 对 <code>/my_test</code> 的内容从 <code>v1-&gt;v2</code>, 但是 ZK 客户端 B 对 <code>/my_test</code> 的内容获取，依然得到的是 <code>v1</code>. 请注意，这个是实际存在的现象，当然延时很短。解决的方法是客户端B先调用 <code>sync()</code>, 再调用 <code>getData()</code>.</p>
<h3 id="5-ZK为什么不提供一个永久性的Watcher注册机制"><a href="#5-ZK为什么不提供一个永久性的Watcher注册机制" class="headerlink" title="5. ZK为什么不提供一个永久性的Watcher注册机制"></a>5. ZK为什么不提供一个永久性的Watcher注册机制</h3><p>不支持用持久Watcher的原因很简单，ZK无法保证性能。</p>
<h3 id="6-使用watch需要注意的几点"><a href="#6-使用watch需要注意的几点" class="headerlink" title="6. 使用watch需要注意的几点"></a>6. 使用watch需要注意的几点</h3><ol>
<li><code>Watches</code> 通知是一次性的，必须重复注册.  </li>
<li>发生 <code>CONNECTIONLOSS</code> 之后，只要在 <code>session_timeout</code> 之内再次连接上（即不发生 <code>SESSIONEXPIRED</code> ），那么这个连接注册的 <code>watches</code> 依然在。  </li>
<li>节点数据的版本变化会触发 <code>NodeDataChanged</code> ，注意，这里特意说明了是版本变化。存在这样的情况，只要成功执行了 <code>setData()</code>方法，无论内容是否和之前一致，都会触发 <code>NodeDataChanged</code> 。  </li>
<li>对某个节点注册了 <code>watch</code> ，但是节点被删除了，那么注册在这个节点上的 <code>watches</code> 都会被移除。  </li>
<li>同一个 zk 客户端对某一个节点注册相同的 <code>watch</code> ，只会收到一次通知。</li>
<li><code>Watcher</code> 对象只会保存在客户端，不会传递到服务端。</li>
</ol>
<h3 id="7-我能否收到每次节点变化的通知"><a href="#7-我能否收到每次节点变化的通知" class="headerlink" title="7. 我能否收到每次节点变化的通知"></a>7. 我能否收到每次节点变化的通知</h3><p><strong>如果节点数据的更新频率很高的话，不能</strong>。</p>
<p>原因在于：当一次数据修改，通知客户端，客户端再次注册 <code>watch</code> ，在这个过程中，可能数据已经发生了许多次数据修改，因此，千万不要做这样的测试：”数据被修改了n次，一定会收到n次通知”来测试 <code>server</code> 是否正常工作。</p>
<h3 id="8-能为临时节点创建子节点吗"><a href="#8-能为临时节点创建子节点吗" class="headerlink" title="8. 能为临时节点创建子节点吗"></a>8. 能为临时节点创建子节点吗</h3><p>不能。</p>
<h3 id="9-是否可以拒绝单个IP对ZK的访问-操作"><a href="#9-是否可以拒绝单个IP对ZK的访问-操作" class="headerlink" title="9. 是否可以拒绝单个IP对ZK的访问,操作"></a>9. 是否可以拒绝单个IP对ZK的访问,操作</h3><p>ZK 本身不提供这样的功能，它仅仅提供了对单个 IP 的连接数的限制。你可以通过修改 iptables 来实现对单个 ip 的限制。</p>
<h3 id="10-在-getChildren-String-path-boolean-watch-注册对节点子节点的变化，那么子节点的子节点变化能通知吗"><a href="#10-在-getChildren-String-path-boolean-watch-注册对节点子节点的变化，那么子节点的子节点变化能通知吗" class="headerlink" title="10. 在[getChildren(String path, boolean watch)]注册对节点子节点的变化，那么子节点的子节点变化能通知吗"></a>10. 在[<code>getChildren(String path, boolean watch)</code>]注册对节点子节点的变化，那么子节点的子节点变化能通知吗</h3><p>不能</p>
<h3 id="11-创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？"><a href="#11-创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？" class="headerlink" title="11. 创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？"></a>11. 创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？</h3><p>连接断了之后，ZK 不会马上移除临时数据，只有当 <code>SESSIONEXPIRED</code> 之后，才会把这个会话建立的临时数据移除。因此，用户需要谨慎设置 <code>Session_TimeOut</code></p>
<h3 id="12-zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？"><a href="#12-zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？" class="headerlink" title="12. zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？"></a>12. zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？</h3><p>3.4.3版本的zookeeper，还不支持这个功能，在3.5.0版本开始，支持动态加机器了。</p>
<h3 id="13-ZooKeeper集群中个服务器之间是怎样通信的？"><a href="#13-ZooKeeper集群中个服务器之间是怎样通信的？" class="headerlink" title="13. ZooKeeper集群中个服务器之间是怎样通信的？"></a>13. ZooKeeper集群中个服务器之间是怎样通信的？</h3><p>Leader服务器会和每一个 <code>Follower/Observer</code> 服务器都建立TCP连接，同时为每个 <code>F/O</code> 都创建一个叫做 <code>LearnerHandler</code> 的实体。LearnerHandler 主要负责 Leader 和 F/O 之间的网络通讯，包括数据同步，请求转发和 <code>Proposal</code> 提议的投票等。Leader 服务器保存了所有 F/O 的 <code>LearnerHandler</code> 。</p>
<h3 id="14-zookeeper是否会自动进行日志清理？如果进行日志清理？"><a href="#14-zookeeper是否会自动进行日志清理？如果进行日志清理？" class="headerlink" title="14.zookeeper是否会自动进行日志清理？如果进行日志清理？"></a>14.zookeeper是否会自动进行日志清理？如果进行日志清理？</h3><p>zk自己不会进行日志清理，需要运维人员进行日志清理</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://jm.taobao.org/2013/10/07/zookeeper-faq/" target="_blank" rel="noopener">ZooKeeper FAQ</a></li>
<li><a href="https://www.cnblogs.com/IcanFixIt/p/7818592.html" target="_blank" rel="noopener">Apache ZooKeeper数据模型</a></li>
<li><a href="http://www.crazyant.net/2120.html" target="_blank" rel="noopener">Zookeeper并不保证读取的是最新数据</a></li>
<li><a href="https://draveness.me/zookeeper-chubby" target="_blank" rel="noopener">详解分布式协调服务 ZooKeeper</a></li>
<li><a href="https://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html" target="_blank" rel="noopener">ZooKeeper 架构</a></li>
<li><a href="http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/" target="_blank" rel="noopener">阿里巴巴为什么不用ZooKeeper 做服务发现？</a></li>
<li><a href="http://ningg.top/zookeeper-lesson-2-leader-election/" target="_blank" rel="noopener">ZooKeeper 技术内幕：Leader 选举</a></li>
<li><a href="http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/01/zookeeper.html" target="_blank" rel="noopener">Zookeeper: 分布式过程协同技术详解</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/Mybatis-动态sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/05/20/Mybatis-动态sql/" class="post-title-link" itemprop="url">Mybatis 动态sql</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-05-20 21:41:10" itemprop="dateCreated datePublished" datetime="2018-05-20T21:41:10+08:00">2018-05-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 18:50:45" itemprop="dateModified" datetime="2019-10-11T18:50:45+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在报表类应用中，通常需要根据不同的维度去组合复杂的查询条件，然后构造SQL去执行查询。如果只是通过在程序中简单地拼接SQL语句，工作量会非常大，而且代码可能也非常难以维护。Mybatis支持动态SQL查询功能，可以通过配置动态的SQL来简化程序代码中复杂性，不过，这个颇有点XML编程的韵味，通过XML来处理复杂的数据判断、循环的功能，其实也很好理解。</p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2018/05/20/Mybatis-动态sql/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/05/10/docker/" class="post-title-link" itemprop="url">docker</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-05-10 15:10:25" itemprop="dateCreated datePublished" datetime="2018-05-10T15:10:25+08:00">2018-05-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 18:50:57" itemprop="dateModified" datetime="2019-10-11T18:50:57+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- GFM-TOC -->
<ul>
<li><p><a href="#一解决的问题">一、解决的问题</a></p>
</li>
<li><p><a href="#二与虚拟机的比较">二、与虚拟机的比较</a></p>
</li>
<li><p><a href="#三优势">三、优势</a></p>
</li>
<li><p><a href="#四使用场景">四、使用场景</a></p>
</li>
<li><p><a href="#五镜像与容器">五、镜像与容器</a></p>
</li>
<li><p><a href="#参考资料">参考资料</a></p>
<!-- GFM-TOC -->
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2018/05/10/docker/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leon</p>
  <div class="site-description" itemprop="description">挪威的森林</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ReonYu" title="GitHub &rarr; https://github.com/ReonYu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leon</span>
</div>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div>

        












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>

  <script defer src="/lib/three/three.min.js"></script>
    
    <script defer src="/lib/three/three-waves.min.js"></script>
  


  





















  

  

  

</body>
</html>
