<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="[分布式系统架构基础]分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。 123ConsistencyAvailabilityPartition tolerance  它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时">
<meta name="keywords" content="code">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式开发基础">
<meta property="og:url" content="http://yoursite.com/2018/07/11/分布式开发/index.html">
<meta property="og:site_name" content="Leon">
<meta property="og:description" content="[分布式系统架构基础]分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。 123ConsistencyAvailabilityPartition tolerance  它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/cee6a24bae2f1146d8f905a9ede12c23.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/cc2bf6c40bcccedb3e6bb2471ef36e53.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/36bb3e9d1be0ea97b3e836dc467a9c87.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/995c5ddf11013119937692d6448da2e8.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/42e2b6be95abf864362b7e646fea18aa.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/c3cf164028d6832a3465def010665ec3.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/b1f224cb62e2257103969df6b2b02320.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/5479e5bb2009261c1c1f4aa2524c5e48.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/53847a86544edeb54059110633da692c.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/cde28984c2c32a5068b2b31d5ba2040f.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/944a3ed0ab807a87b5c562c58a31ea2b.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/641361c1efdb212bdba9b74168d6334b.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/7ca755dfe9b16f9c130f5de492549a86.png">
<meta property="og:image" content="http://yoursite.com/2018/07/11/分布式开发/images/72025ab7142520ce9e59193eb956b900.png">
<meta property="og:updated_time" content="2019-10-11T06:31:21.276Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分布式开发基础">
<meta name="twitter:description" content="[分布式系统架构基础]分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。 123ConsistencyAvailabilityPartition tolerance  它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时">
<meta name="twitter:image" content="http://yoursite.com/2018/07/11/分布式开发/images/cee6a24bae2f1146d8f905a9ede12c23.png">
  <link rel="canonical" href="http://yoursite.com/2018/07/11/分布式开发/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>分布式开发基础 | Leon</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Live for Real</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-commonweal">
      
    

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeats"></i>Commonweal 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/分布式开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leon">
      <meta itemprop="description" content="挪威的森林">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">分布式开发基础

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-07-11 12:26:09" itemprop="dateCreated datePublished" datetime="2018-07-11T12:26:09+08:00">2018-07-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 14:31:21" itemprop="dateModified" datetime="2019-10-11T14:31:21+08:00">2019-10-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="分布式系统架构基础"><a href="#分布式系统架构基础" class="headerlink" title="[分布式系统架构基础]"></a>[分布式系统架构基础]</h1><p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consistency</span><br><span class="line">Availability</span><br><span class="line">Partition tolerance</span><br></pre></td></tr></table></figure>

<p>它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 <code>CAP</code> 定理。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</li>
</ul>
<h3 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h3><p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统采用弱一致性来提高性能，一些不同的一致性模型也相继被提出。</p>
<ul>
<li><strong>强一致性</strong>： 要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</li>
<li><strong>弱一致性</strong>：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li>
<li><strong>最终一致性</strong>：是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。</li>
</ul>
<h4 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h4><ol>
<li>分布式事务：两段提交</li>
<li>分布式锁</li>
<li>MQ 消息持久化 重试 幂等</li>
<li>Paxos 算法</li>
</ol>
<h3 id="服务可用性"><a href="#服务可用性" class="headerlink" title="服务可用性"></a>服务可用性</h3><p>可用性，意思是只要收到用户的请求，服务器就必须给出回应。</p>
<h4 id="高可用解决方案"><a href="#高可用解决方案" class="headerlink" title="高可用解决方案"></a>高可用解决方案</h4><ul>
<li><strong>负载均衡</strong>：</li>
<li><strong>降级</strong>：当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</li>
<li><strong>熔断</strong>：对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞的。再等到目标服务好转后进行接口恢复。</li>
<li><strong>流量控制</strong>：</li>
<li><strong>异地多活</strong>：</li>
</ul>
<p>熔断是减少由于下游服务故障对自己的影响；而降级则是在整个系统的角度上，考虑业务整体流量，保护核心业务稳定。</p>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p>般来说，分区容错无法避免，因此可以认为 CAP 的 <code>P</code> 总是成立。CAP 定理告诉我们，剩下的 <code>C</code> 和 <code>A</code> 无法同时做到。</p>
<h1 id="高并发下的流量控制"><a href="#高并发下的流量控制" class="headerlink" title="高并发下的流量控制"></a>高并发下的流量控制</h1><p>这个时候如果不做任何保护措施，服务器就会承受很大的处理压力，请求量很高，服务器负载也很高，并且当请求超过服务器承载极限的时候，系统就会崩溃，导致所有人都不能访问。</p>
<p>为了应用服务的高可用，一个常用的办法是对大流量的请求（秒杀/抢购）进行限流，拦截掉大部分请求，只允许一部分请求真正进入后端服务器，这样就可以防止大量请求造成系统压力过大导致的系统崩溃，从而保护服务正常可用。</p>
<p><code>令牌桶(Token Bucket)</code>、<code>漏桶(leaky bucket)</code>和 <code>计数器</code> 算法是最常用的三种限流的算法。</p>
<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>计数器限流算法也是比较常用的，主要用来限制总并发数。比如限流 <code>qps</code> 为 <code>100</code> ，算法的实现思路就是从第一个请求进来开始计时，在接下去的 <code>1s</code> 内，每来一个请求，就把计数加 <code>1</code> ，如果累加的数字达到了 <code>100</code> ，那么后续的请求就会被全部拒绝。等到 <code>1s</code> 结束后，把计数恢复成 <code>0</code> ，重新开始计数。</p>
<p>这种实现方式有一个弊端：如果我在单位时间 <code>1s</code> 内的前 <code>10ms</code> ，已经通过了 <code>100</code> 个请求，那后面的 <code>990ms</code> ，只能眼巴巴的把请求拒绝，这种现象称为 <strong>突刺现象</strong>。</p>
<h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><p>为了消除 <strong>突刺现象</strong>，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p>
<p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每 <code>10</code> 毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p>
<p><img src="images/cee6a24bae2f1146d8f905a9ede12c23.png" alt></p>
<p>在算法实现方面，可以 <strong>准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行</strong>。</p>
<p>这种算法，在使用过后也存在弊端：<strong>无法应对短时间的突发流量</strong>，同时它的优点也是可以平滑网络上的突发流量，请求可以被整形成稳定的流量。</p>
<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>从某种意义上讲，<strong>令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用</strong>。</p>
<p>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p>
<p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置 <code>qps</code> 为 <code>100</code> ，那么限流器初始化完成一秒后，桶中就已经有 100 个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的 <code>100</code> 个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p>
<p><img src="images/cc2bf6c40bcccedb3e6bb2471ef36e53.png" alt></p>
<p>实现思路：可以 <strong>准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行</strong>。</p>
<blockquote>
<p>漏桶 VS 令牌桶：两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量。</p>
</blockquote>
<h2 id="集群限流"><a href="#集群限流" class="headerlink" title="集群限流"></a>集群限流</h2><h3 id="Redis-请求窗口"><a href="#Redis-请求窗口" class="headerlink" title="Redis 请求窗口"></a>Redis 请求窗口</h3><blockquote>
<p>采用redis 的计时和计数方式,在规定的时间窗口期,允许通过的最大请求数量</p>
</blockquote>
<p>比如为了限制某个资源被每个用户或者商户的访问次数，5s 只能访问 2 次，或者一天只能调用 1000 次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。</p>
<p>如何实现？为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。</p>
<p>大概思路：每次有相关操作的时候，就向 <code>redis</code> 服务器发送一个 <code>incr</code> 命令，比如需要限制某个用户访问 <code>/index</code> 接口的次数，只需要拼接用户 id 和接口名生成 <code>redis</code> 的 <code>key</code> ，每次该用户访问此接口时，只需要对这个 <code>key</code> 执行 <code>incr</code> 命令，在这个 <code>key</code> 带上过期时间，就可以实现指定时间的访问频率。</p>
<h3 id="Nginx-限流"><a href="#Nginx-限流" class="headerlink" title="Nginx 限流"></a>Nginx 限流</h3><p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。</p>
<p>Nginx官方版本限制IP的连接和并发分别有两个模块：</p>
<ul>
<li><code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。</li>
<li><code>limit_req_conn</code> 用来限制同一时间连接数，即并发限制。</li>
</ul>
<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>高并发环境下，例如典型的淘宝双11秒杀，几分钟内上亿的用户涌入淘宝，这个时候如果访问不加拦截，让大量的读写请求涌向数据库，由于磁盘的处理速度与内存显然不在一个量级，服务器马上就要宕机。<strong>从减轻数据库的压力和提高系统响应速度两个角度来考虑，都会在数据库之前加一层缓存</strong>，访问压力越大的，在缓存之前就开始 CDN 拦截图片等访问请求。</p>
<p>并且由于最早的单台机器的内存资源以及承载能力有限，如果大量使用本地缓存，也会使相同的数据被不同的节点存储多份，对内存资源造成较大的浪费，因此，才催生出了分布式缓存。</p>
<p><img src="images/36bb3e9d1be0ea97b3e836dc467a9c87.png" alt></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><strong>页面缓存</strong>：用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等;</li>
<li><strong>应用对象缓存</strong>：缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问;解决分布式Web部署的 session 同步问题，状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群。</li>
<li><strong>并行处理</strong>：通常涉及大量中间计算结果需要共享;</li>
<li><strong>云计算领域提供分布式缓存服务</strong></li>
</ol>
<h2 id="常见问题和挑战"><a href="#常见问题和挑战" class="headerlink" title="常见问题和挑战"></a>常见问题和挑战</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效、新缓存未到之间(<strong>例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期</strong>)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。<strong>这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空</strong>（<em>相当于进行了两次无用的查询</em>）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外，我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是 <strong>保证核心服务可用，即使是有损的</strong>。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li><strong>一般</strong>：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li><strong>警告</strong>：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li><strong>错误</strong>：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li><strong>严重错误</strong>：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<h3 id="缓存与数据库不一致问题"><a href="#缓存与数据库不一致问题" class="headerlink" title="缓存与数据库不一致问题"></a>缓存与数据库不一致问题</h3><p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>
<p><img src="images/995c5ddf11013119937692d6448da2e8.png" alt></p>
<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。</p>
<p>从理论上来说，给 <strong>缓存设置过期时间，是保证最终一致性的解决方案</strong>。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p>
<h4 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h4><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>可以通过：</p>
<ol>
<li>更新操作数据库后，再次更新缓存来实现</li>
<li>缓存设置过期时间，等待过期时间后，数据恢复</li>
</ol>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。</p>
<h2 id="应用发展流程"><a href="#应用发展流程" class="headerlink" title="应用发展流程"></a>应用发展流程</h2><h3 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="实现基于数据库的乐观锁"><a href="#实现基于数据库的乐观锁" class="headerlink" title="实现基于数据库的乐观锁"></a>实现基于数据库的乐观锁</h2><p>提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">// step 1</span><br><span class="line">int oldVersion = getOldVersion(stmt);</span><br><span class="line"></span><br><span class="line">// step 2</span><br><span class="line">// 用这个数据库连接做其他的逻辑</span><br><span class="line"></span><br><span class="line">// step 3 可用预编译语句</span><br><span class="line">int i = stmt.executeUpdate(</span><br><span class="line">        &quot;update optimistic_lock set version = &quot; + (oldVersion + 1) + &quot; where version = &quot; + oldVersion);</span><br><span class="line"></span><br><span class="line">// step 4</span><br><span class="line">if (i &gt; 0) &#123;</span><br><span class="line">    conn.commit(); // 更新成功表明数据没有被修改，提交事务。</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    conn.rollback(); // 更新失败，数据被修改，回滚。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乐观锁的缺点：</p>
<ul>
<li>会带来大数量的无效更新请求、事务回滚，给DB造成不必要的额外压力。</li>
<li>无法保证先到先得，后面的请求可能由于并发压力小了反而有可能处理成功。</li>
</ul>
<h2 id="基于-Redis-的分布式锁"><a href="#基于-Redis-的分布式锁" class="headerlink" title="基于 Redis 的分布式锁"></a>基于 Redis 的分布式锁</h2><p><a href="../../basic/database/7-redis.md">Redis</a></p>
<h1 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h1><p>当一个带有会话表示的 <code>Http</code> 请求到 <code>Web</code> 服务器后，需求在请求中的处理过程中找到 <code>session</code> 数据。而问题就在于， <code>session</code> 是保存在单机上的。 假设我们有应用A和应用B，现在一位用户第一次访问网站， <code>session</code> 数据保存在 <code>应用A</code> 中。如果我们不做处理，怎么保障接下来的请求每次都请求到 <code>应用A</code> 呢? 如请求到了 <code>应用B</code> 中，就会发现没有这位用户的 <code>session</code> 数据，这绝对是不能容忍的。</p>
<p>解决方案有Session Stick，Session复制，Session集中管理，基于Cookie管理，下面一一说明。</p>
<h2 id="Session-Stick"><a href="#Session-Stick" class="headerlink" title="Session Stick"></a>Session Stick</h2><p>在单机情况， <code>session</code> 保存在单机上，请求也是到这台单机上，不会有问题。变成多台后，如果能保障每次请求都到同一台服务，那就和单机一样了。 这需要在负载均衡设备上修改。这就是 <code>Session Stick</code> ，这种方式也会有问题：</p>
<ul>
<li>如果某一台服务器宕机或重启，那么这台服务器上的 <code>session</code> 数据就丢失了。如果 <code>session</code> 数据中还有登录状态信息，那么用户需要重现登录。</li>
<li>负载均衡要处理具体的 <code>session</code> 到服务器的映射。</li>
</ul>
<h2 id="Session复制"><a href="#Session复制" class="headerlink" title="Session复制"></a>Session复制</h2><p><code>Session</code> 复制顾名思义，就是每台应用服务，都保存会话 <code>session</code> 数据，一般的应用容器都支持。与 <code>Session Stick</code> 相比， <code>sessioon</code> 复制对负载均衡 没有太多的要求。不过这个方案还是有缺点：</p>
<ul>
<li>同步 <code>session</code> 数据带来都网络开销。只要 <code>session</code> 数据变化，就需要同步到所有机器上，机器越多，网络开销越大。</li>
<li>由于每台服务器都保存 <code>session</code> 数据，如果集群的 <code>session</code> 数据很多，比如 90万 人在访问网站，每台机器用于保存 <code>session</code> 数据的内容占用很严重。</li>
</ul>
<p>这就是 <strong>Session 复制</strong>，这个方案是靠应用容器来完成，并不依赖应用，如果应用服务数量并不是很多，可以考虑。</p>
<h2 id="Session集中管理"><a href="#Session集中管理" class="headerlink" title="Session集中管理"></a>Session集中管理</h2><p>这个也很好理解，再加一台服务，专门来管理 <code>session</code> 数据，每台应用服务都从专门的 <code>session</code> 管理服务中取会话 <code>session</code> 数据。可以使用数据库，NOSQL数据库等。 <strong>和Session复制相比，减少了每台应用服务的内存使用，同步session带来的网络开销问题</strong>。但还是有缺点：</p>
<ul>
<li>读写 <code>session</code> 引入了网络操作，相对于本机读写 <code>session</code> ，带来了延时和不稳定性。</li>
<li>如 <code>Session</code> 集中服务有问题，会影响应用。</li>
</ul>
<h2 id="基于Cookie管理"><a href="#基于Cookie管理" class="headerlink" title="基于Cookie管理"></a>基于Cookie管理</h2><p>最后一个是基于 <code>Cookie</code> 管理，我们把 <code>session</code> 数据存放在 <code>cookie</code> 中，然后请求过来后，从 <code>cookie</code> 中获取 <code>session</code> 数据。与集中管理相比，这个方案并不依赖外部 的存储系统，读写 <code>session</code> 数据带来的网络操作延时和不稳定性。但依然有缺点：</p>
<ul>
<li><strong>Cookie有长度限制，这会影响session数据的长度</strong>。</li>
<li><strong>安全性</strong>：session数据本来存储在服务端的，而这个方案是让 <code>session</code> 数据转到外部网络或客户端中，所以会有安全性问题。不过可以对写入 Cookie 的 <code>session</code> 数据做加密。</li>
<li><strong>带宽消耗</strong>：由于加了session数据，带宽当然也会增加一点。</li>
<li><strong>性能消耗</strong>：每次Http请求和响应都带有Session数据，对于Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发请求越多。</li>
</ul>
<h1 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h1><h2 id="使用场景-Scenario"><a href="#使用场景-Scenario" class="headerlink" title="使用场景(Scenario)"></a>使用场景(Scenario)</h2><p>微博和Twitter都有140字数的限制，如果分享一个长网址，很容易就超出限制，发布出去。短网址服务可以把一个长网址变成短网址，方便在社交网络上传播。</p>
<h2 id="需求-Needs"><a href="#需求-Needs" class="headerlink" title="需求(Needs)"></a>需求(Needs)</h2><p>很显然，要尽可能的短。长度设计为多少才合适呢？</p>
<h2 id="短网址的长度"><a href="#短网址的长度" class="headerlink" title="短网址的长度"></a>短网址的长度</h2><p>当前互联网上的网页总数大概是 45亿(参考 短网址<em>短网址资讯<code>mrw.so</code>)，45亿 超过了 <code>2^{32}=4294967296232=4294967296</code>，但远远小于64位整数的上限值，那么用一个64位整数足够了。微博的短网址服务用的是长度为 <code>7</code> 的字符串，这个字符串可以看做是62进制的数，那么最大能表示<code>{62}^7=3521614606208627=3521614606208</code>个网址，远远大于 45亿。所以长度为7就足够了。一个64位整数如何转化为字符串呢？，假设我们只是用大小写字母加数字，那么可以看做是62进制数，`log</em>{62{(2^{64}-1)=10.7log62(264−1)=10.7`，即字符串最长11就足够了。实际生产中，还可以再短一点，比如新浪微博采用的长度就是7，因为 62^7=3521614606208627=3521614606208，这个量级远远超过互联网上的URL总数了，绝对够用了。现代的web服务器（例如Apache, Nginx）大部分都区分URL里的大小写了，所以用大小写字母来区分不同的URL是没问题的。因此，正确答案：长度不超过7的字符串，由大小写字母加数字共62个字母组成。</p>
<h2 id="一对一还是一对多映射？"><a href="#一对一还是一对多映射？" class="headerlink" title="一对一还是一对多映射？"></a>一对一还是一对多映射？</h2><p>一个长网址，对应一个短网址，还是可以对应多个短网址？ 这也是个重大选择问题。一般而言，一个长网址，在不同的地点，不同的用户等情况下，生成的短网址应该不一样，这样，在后端数据库中，可以更好的进行数据分析。如果一个长网址与一个短网址一一对应，那么在数据库中，仅有一行数据，无法区分不同的来源，就无法做数据分析了。</p>
<p>以这个7位长度的短网址作为唯一ID，这个ID下可以挂各种信息，比如生成该网址的用户名，所在网站，HTTP头部的 User Agent等信息，收集了这些信息，才有可能在后面做大数据分析，挖掘数据的价值。短网址服务商的一大盈利来源就是这些数据。</p>
<p>正确答案：一对多</p>
<h2 id="如何计算短网址"><a href="#如何计算短网址" class="headerlink" title="如何计算短网址"></a>如何计算短网址</h2><p>现在我们设定了短网址是一个长度为7的字符串，如何计算得到这个短网址呢？</p>
<p>最容易想到的办法是哈希，先hash得到一个64位整数，将它转化为62进制整，截取低7位即可。但是哈希算法会有冲突，如何处理冲突呢，又是一个麻烦。这个方法只是转移了矛盾，没有解决矛盾，抛弃。</p>
<p>正确答案：分布式发号器(<code>Distributed ID Generator</code>)</p>
<h2 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h2><p>如果存储短网址和长网址的对应关系？以短网址为 <code>primary key</code>, 长网址为<code>value</code>, 可以用传统的关系数据库存起来，例如<code>MySQL,PostgreSQL</code>，也可以用任意一个分布式 KV 数据库，例如<code>Redis, LevelDB</code>。</p>
<h2 id="301还是302重定向"><a href="#301还是302重定向" class="headerlink" title="301还是302重定向"></a>301还是302重定向</h2><p>这也是一个有意思的问题。这个问题主要是考察你对301和302的理解，以及浏览器缓存机制的理解。</p>
<p>301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， <code>Google</code>，<code>百度</code>等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的<code>Cookie</code>, <code>User Agent</code> 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。</p>
<p>所以，正确答案是302重定向。</p>
<p>可以抓包看看mrw.so的短网址是怎么做的，使用 Chrome 浏览器，访问这个URL <code>http://mrw.so/4UD39p</code>，是我事先发微博自动生成的短网址。来抓包看看返回的结果是啥，可见新浪微博用的就是302临时重定向。</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><a href="https://draveness.me/distributed-transaction-principle" target="_blank" rel="noopener">分布式事务</a></h1><p>系统之间的通信可靠性从单一系统中的可靠变成了微服务架构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。<strong>无论是事务还是分布式事务实现原子性都无法避免对持久存储的依赖</strong>，事务使用磁盘上的日志记录执行的过程以及上下文，这样无论是需要回滚还是补偿都可以通过日志追溯，而分布式事务也会依赖 数据库、<code>Zookeeper</code> 或者 <code>ETCD</code> 等服务追踪事务的执行过程，总而言之，各种形式的日志是保证事务几大特性的 <strong>重要</strong> 手段。</p>
<h2 id="2PC-与-3PC"><a href="#2PC-与-3PC" class="headerlink" title="2PC 与 3PC"></a>2PC 与 3PC</h2><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>两阶段提交的执行过程就跟它的名字一样分为两个阶段，<strong>投票阶段和提交阶段</strong>，在投票阶段中，协调者（<code>Coordinator</code>）会向事务的参与者（<code>Cohort</code>）询问是否可以执行操作的请求，并等待其他参与者的响应，参与者会执行相对应的事务操作并 <strong>记录重做和回滚日志</strong>，所有执行成功的参与者会向协调者发送 <code>AGREEMENT</code> 或者 <code>ABORT</code> 表示执行操作的结果。</p>
<p><img src="images/42e2b6be95abf864362b7e646fea18aa.png" alt="image"></p>
<p>当所有的参与者都返回了确定的结果（同意或者终止）时，两阶段提交就进入了提交阶段，协调者会根据投票阶段的返回情况向所有的参与者发送提交或者回滚的指令。</p>
<p><img src="images/c3cf164028d6832a3465def010665ec3.png" alt="image"></p>
<p>当事务的所有参与者都决定提交事务时，协调者会向参与者发送 <code>COMMIT</code> 请求，参与者在完成操作并释放资源之后向协调者返回完成消息，协调者在收到所有参与者的完成消息时会结束整个事务；与之相反，当有参与者决定 <code>ABORT</code> 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会根据之前执行操作时的回滚日志对操作进行回滚并向协调者发送完成的消息，在提交阶段，无论当前事务被提交还是回滚，所有的资源都会被释放并且事务也一定会结束。</p>
<p>两阶段提交协议是一个阻塞协议，也就是说在两阶段提交的执行过程中，除此之外，如果事务的执行过程中协调者永久宕机，事务的一部分参与者将永远无法完成事务，它们会等待协调者发送 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 消息，甚至会出现多个参与者状态不一致的问题。</p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>为了解决两阶段提交在协议的一些问题，<strong>三阶段提交引入了超时机制和准备阶段</strong>，如果协调者或者参与者在规定的之间内没有接受到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务，准备阶段的引入其实让事务的参与者有了除回滚之外的其他选择。</p>
<p><img src="images/b1f224cb62e2257103969df6b2b02320.png" alt="image"></p>
<p>当参与者向协调者发送 <code>ACK</code> 后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交中被阻塞住；上述的图片非常清楚地说明了在不同阶段，协调者或者参与者的超时会造成什么样的行为。</p>
<h2 id="消息服务"><a href="#消息服务" class="headerlink" title="消息服务"></a>消息服务</h2><p>分布式事务带来复杂度的原因其实就是由于各个模块之间的通信不稳定，当我们发出一个网络请求时，可能的返回结果是成功、失败或者超时。</p>
<p><img src="images/5479e5bb2009261c1c1f4aa2524c5e48.png" alt="image"></p>
<p>网络无论是返回成功还是失败其实都是一个确定的结果，当网络请求超时的时候其实非常不好处理，在这时调用方并不能确定这一次请求是否送达而且不会知道请求的结果，但是 <strong>消息服务</strong> 可以保证某条信息一定会送达到调用方；大多数消息服务都会提供两种不同的 <code>QoS</code> ，也就是服务的等级。</p>
<p><img src="images/53847a86544edeb54059110633da692c.png" alt="image"></p>
<p>最常见的两种服务等级就是 <code>At-Most-Once</code> 和 <code>At-Least-Once</code> 。</p>
<ul>
<li><code>At-Most-Once</code>：能够保证发送方不对接收方是否能收到消息作保证，消息要么会被投递一次，要么不会被投递，这其实跟一次普通的网络请求没有太多的区别；</li>
<li><code>At-Least-Once</code>：能够解决消息投递失败的问题，它要求发送者检查投递的结果，并在失败或者超时时重新对消息进行投递，发送者会持续对消息进行推送，直到接受者确认消息已经被收到</li>
</ul>
<blockquote>
<p>相比于 <code>At-Most-Once</code>，<code>At-Least-Once</code> 因为能够确保消息的投递会被更多人使用。</p>
</blockquote>
<p>除了这两种常见的服务等级之外，还有另一种服务等级，也就是 <code>Exactly-Once</code>，这种服务等级不仅对发送者提出了要求，还对消费者提出了要求，它需要接受者对接收到的所有消息进行去重，发送者和接受者一方对消息进行重试，另一方对消息进行去重，两者分别部署在不同的节点上，这样对于各个节点上的服务来说，它们之间的通信就是 <code>Exactly-Once</code> 的，但是需要注意的是，<code>Exacly-Once</code> 一定需要接收方的参与。</p>
<p>使用消息服务实现分布式事务在底层的原理上与其他的方法没有太多的差别，只是 <strong>消息服务能够帮助我们实现的消息的持久化以及重试等功能</strong>，能够为我们提供一个比较合理的 API 接口，方便开发者使用。</p>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><a href="https://draveness.me/zookeeper-chubby" target="_blank" rel="noopener">Zookeeper</a></h1><blockquote>
<p>ZK 不是解决分布式问题的银弹</p>
</blockquote>
<h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>分布式应用可以在给定时间（同时）在网络中的多个系统上运行，通过协调它们以快速有效的方式完成特定任务。通常来说，<strong>对于复杂而耗时的任务，非分布式应用（运行在单个系统中）需要几个小时才能完成，而分布式应用通过使用所有系统涉及的计算能力可以在几分钟内完成</strong>。</p>
<p>通过将分布式应用配置为在更多系统上运行，可以进一步减少完成任务的时间。分布式应用正在运行的一组系统称为 <strong>集群</strong>，而在集群中运行的每台机器被称为 <strong>节点</strong>。</p>
<h3 id="分布式应用的优点"><a href="#分布式应用的优点" class="headerlink" title="分布式应用的优点"></a>分布式应用的优点</h3><ul>
<li>可靠性：单个或几个系统的故障不会使整个系统出现故障。</li>
<li>可扩展性：可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。</li>
<li>透明性：隐藏系统的复杂性，并将其显示为单个实体/应用程序。</li>
</ul>
<h3 id="分布式应用的挑战"><a href="#分布式应用的挑战" class="headerlink" title="分布式应用的挑战"></a>分布式应用的挑战</h3><ul>
<li>竞争条件：两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。</li>
<li>死锁：两个或多个操作等待彼此无限期完成。</li>
<li>不一致：数据的部分失败。</li>
</ul>
<h2 id="ZooKeeper基础"><a href="#ZooKeeper基础" class="headerlink" title="ZooKeeper基础"></a>ZooKeeper基础</h2><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p>
<p>ZooKeeper 的好处：</p>
<ul>
<li>简单的分布式协调过程</li>
<li>同步：服务器进程之间的相互排斥和协作。</li>
<li>有序性</li>
<li>序列化：根据特定规则对数据进行编码(Jute)。</li>
<li>可靠性</li>
<li>原子性：数据转移完全成功或完全失败，但没有事务是部分的。</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>一个 ZooKeeper 集群通常由一组机器组成，一般 3 台以上就可以组成一个可用的 ZooKeeper 集群了。组成 <code>ZooKeeper</code> 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都会互相保持通信。 ZooKeeper 本身就是一个 <strong>复制和分布式</strong> 应用程序，其目的作为服务运行，类似于我们运行 DNS 或任何其他集中式服务的方式。</p>
<blockquote>
<p>ZK 集群 <strong>半数以上存活</strong> 即可用</p>
</blockquote>
<p>ZooKeeper 的客户端程序会选择和集群中的任意一台服务器创建一个 TCP 连接，而且一旦客户端和服务器断开连接，客户端就会自动连接到集群中的其他服务器。</p>
<p><img src="images/cde28984c2c32a5068b2b31d5ba2040f.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">部分</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Client（客户端）</td>
<td align="left">客户端是我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。</td>
</tr>
<tr>
<td align="left">Server（服务器）</td>
<td align="left">服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。</td>
</tr>
<tr>
<td align="left">ZooKeeper Service</td>
<td align="left">ZooKeeper服务器组。形成 Service 所需的最小节点数为3。</td>
</tr>
<tr>
<td align="left">Leader</td>
<td align="left">服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。</td>
</tr>
<tr>
<td align="left">Follower</td>
<td align="left">用于接受客户端请求并向客户端返回结果，在选主过程中参与投票</td>
</tr>
<tr>
<td align="left">Observer</td>
<td align="left">接受客户端连接，将写请求转发给leader，但 observer <strong>不参与</strong> 投票过程，只同步 leader 的状态， observer 的目的是为了扩展系统，提高读取速度</td>
</tr>
</tbody></table>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><img src="images/944a3ed0ab807a87b5c562c58a31ea2b.png" alt="image"></p>
<p>到znode是一个标准的文件系统，层次结构很像一棵树。 需要注意的一些要点如下：</p>
<ul>
<li>根节点有一个名为 <code>/zoo</code> 的子节点，它又有三个 <code>znode</code> 。</li>
<li>ZooKeeper 树中的每个 <code>znode</code> 都由一个路径标识，路径元素由<code>/</code>分隔。</li>
<li>这些节点被称为数据寄存器，因为它们可以存储数据。 因此，一个 znode 可以有子节点以及与之相关的数据。 这与文件系统可以把文件作为路径很类似。</li>
</ul>
<p>znode 中的数据通常以字节格式存储，<strong>每个 znode 中的最大数据大小不超过1 MB</strong>。 ZooKeeper 是为协调而设计的，几乎所有形式的协调数据都比较小， 因此，对数据大小的限制是强制的。</p>
<p>与文件系统中的文件一样， <code>znode</code> 维护一个 <code>stat</code> 结构，其中包含数据更改的 <strong>版本号</strong> 以及随更改相关的时间戳而更改的 <strong>访问控制列表（ACL）</strong>。 只要 znode 的数据发生变化，版本号就会增加。 ZooKeeper 使用版本号以及相关的时间戳来验证它的核心内缓存。 znode 版本号还允许客户端通过 ZooKeeper API 更新或删除特定的 znode。 如果指定的版本号与 znode 的当前版本不匹配，则操作失败。 但是，执行 znode 更新或删除操作时，可以通过指定 0 作为版本号来覆盖。</p>
<h3 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h3><ul>
<li><strong>persistent</strong>：即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。</li>
<li><strong>ephemeral</strong>：客户端活跃时，临时节点就是有效的。当客户端与 ZooKeeper 集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在 leader 选举中起着重要作用。</li>
<li><strong>sequential</strong>：顺序节点可以是持久的或临时的。当一个新的 znode 被创建为一个顺序节点时，ZooKeeper 通过将 <strong>10位</strong> 的序列号附加到原始名称来设置 znode 的路径。例如，如果将具有路径 <code>/myapp</code> 的znode创建为顺序节点，则ZooKeeper会将路径更改为 <code>/myapp0000000001</code> ，并将下一个序列号设置为<code>0000000002</code>。如果两个顺序节点是同时创建的，那么 ZooKeeper <strong>不会对每个znode使用相同的数字</strong>。顺序节点在锁定和同步中起重要作用。</li>
</ul>
<h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><p>会话对于 ZooKeeper 的操作非常重要。会话中的请求按 FIFO 顺序执行。一旦客户端连接到服务器，将建立会话并向客户端分配 <strong>会话ID</strong> 。</p>
<p>客户端 <strong>以特定的时间间隔发送心跳</strong> 以保持会话有效。如果 ZooKeeper 集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。</p>
<p>会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>ZooKeeper</code> 的设计是一种可伸缩的、健壮的集中式服务。在客户端访问此类服务时，常见的设计模式是通过轮询或拉式（pull）模型。当在大型和复杂的分布式系统中实现时，拉模型常常会受到可伸缩性问题的影响。为了解决这个问题，ZooKeeper设计了一种机制，<strong>客户端可以从 ZooKeeper 服务中获取通知。客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据</strong>。</p>
<p>客户可以使用 <code>ZooKeeper</code> 服务注册与 <code>znode</code> 相关的任何更改。 这种注册被称为在 <code>ZooKeeper</code> 术语中的 <code>znode</code> 上设置 <code>watch</code>。 监视允许客户以任何方式更改 <code>znode</code> 时收到通知。 <strong><code>Watcher</code> 是一次性操作</strong>，这意味着它只触发一个通知。 要继续接收通知，客户必须在收到每个事件通知后重新注册一个监视。</p>
<p>监视触发：</p>
<ul>
<li>对 znode 数据的任何更改，例如使用 <code>setData</code> 操作将新数据写入 znode 的数据字段时。</li>
<li>对 znode 的子节点的任何更改。 例如，一个 znode 的子节点被删除。</li>
<li>正在创建或删除的 znode ，如果将新的 znode 添加到路径中或现有的 znode 被删除，则可能发生这种情况。</li>
</ul>
<p>同样，ZooKeeper 针对监视和通知声明以下保证：</p>
<ul>
<li>ZooKeeper 确保监视始终以先进先出（FIFO）方式排序，并且通知总是按顺序发送</li>
<li>在对同一个 znode 进行任何其他更改之前，监视会将通知发送给客户端</li>
<li>监视事件的顺序是按照 ZooKeeper 服务的更新顺序排列的</li>
</ul>
<h2 id="Zookeeper-工作流程"><a href="#Zookeeper-工作流程" class="headerlink" title="Zookeeper 工作流程"></a>Zookeeper 工作流程</h2><p>一旦 ZooKeeper 集合启动，它将等待客户端连接。客户端将连接到 ZooKeeper 集合中的一个节点。它可以是 leader 或 follower 节点。一旦客户端被连接，节点将向特定客户端分配 <code>会话ID</code> 并向该客户端发送确认。如果客户端没有收到确认，它将尝试连接 ZooKeeper 集合中的另一个节点。 一旦连接到节点，客户端将以有规律的间隔向节点发送 <strong>心跳</strong>，以确保连接不会丢失。</p>
<ul>
<li><p><strong>如果客户端想要读取特定的znode</strong>，它将会向具有znode路径的节点发送读取请求，并且节点通过从其自己的数据库获取来返回所请求的znode。为此，在ZooKeeper集合中读取速度很快。</p>
</li>
<li><p><strong>如果客户端想要将数据存储在ZooKeeper集合中</strong>，则会将 znode 路径和数据发送到服务器。<strong>连接的服务器将该请求转发给 leader，然后leader将向所有的follower重新发出写入请求。如果只有大部分节点成功响应，而写入请求成功，则成功返回代码将被发送到客户端</strong>。 否则，写入请求失败。绝大多数节点被称为 Quorum 。</p>
</li>
</ul>
<h3 id="ZooKeeper-Service-节点数量的影响"><a href="#ZooKeeper-Service-节点数量的影响" class="headerlink" title="ZooKeeper Service 节点数量的影响"></a>ZooKeeper Service 节点数量的影响</h3><ul>
<li>如果我们有 <strong>单个节点</strong>，则当该节点故障时，ZooKeeper Service 将故障。即“单点故障”，不建议在生产环境中使用。</li>
<li>如果我们有 <strong>两个节点</strong> 而一个节点故障，我们没有占多数，ZooKeeper Service 故障，因为两个中的一个不是多数。</li>
<li>如果我们有 <strong>三个节点</strong> 而一个节点故障，那么我们有大多数，因此，这是 <strong>最低要求</strong>。ZooKeeper集合在实际生产环境中必须至少有三个节点。</li>
<li>如果我们有 <strong>四个节点</strong> 而两个节点故障，它将再次故障。类似于有三个节点，额外节点不用于任何目的，因此，最好添加奇数的节点，例如 3，5，7。</li>
</ul>
<p>我们知道写入过程比 ZooKeeper 集合中的读取过程要耗时，因为 <strong>所有节点都需要在数据库中写入相同的数据</strong>。因此，对于平衡的环境拥有较少数量（例如3，5，7）的节点比拥有大量的节点要好。</p>
<h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>下面任何一种情况，都会触发 Leader 选举：</p>
<ul>
<li>启动时，集群服务器刚启动</li>
<li>运行时，Leader 崩溃</li>
</ul>
<p>服务器的状态流转：</p>
<p><img src="images/641361c1efdb212bdba9b74168d6334b.png" alt="image"></p>
<p>Leader 选举过程，本质就是 <strong>广播优先级消息</strong> 的过程，选出 <strong>数据最新的服务节点</strong>，选出优先级最高的服务节点，基本步骤：</p>
<ul>
<li>各个服务器节点，广播自己的优先级标识 <code>(sid，zxid)</code></li>
<li>服务器节点收到其他广播消息后，跟自己的优先级对比，自己优先级低，则变更当前节点投票的优先级<code>(sid，zxid)</code> ，并广播变更后的结果</li>
<li>当任意一个服务器节点收到的投票数，超过了法定数量(<code>quorum</code>)，则，升级为 Leader，并广播结果。</li>
</ul>
<p><img src="images/7ca755dfe9b16f9c130f5de492549a86.png" alt="image"></p>
<blockquote>
<ul>
<li>由于网络延时，节点得不到足够多广播信息时，会做出错误的投票判断，纠正过程更耗时</li>
<li>选举过程中，服务器节点会等待一定时间，再广播投票信息，时间间隔一般设定为 200 ms</li>
<li>上面 Leader 选举，采取事件触发 Push 方式 广播消息，称为 快速 Leader 选举，因为之前的 Leader 选举，采用 Pull 方式，每隔 1s 拉取一次。</li>
</ul>
</blockquote>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>通过 Zookeeper 进行数据的发布与订阅其实可以说是它提供的最基本功能，它能够允许多个客户端同时订阅某一个节点的变更并在变更发生时执行我们预先设置好的回调函数，在运行时改变服务的配置和行为</p>
<h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>除了实现服务配置数据的发布与订阅功能，Zookeeper 还能帮助分布式系统实现命名服务，在每一个分布式系统中，客户端应用都有根据指定名字获取资源、服务器地址的需求，在这时就要求整个集群中的全部服务有着唯一的名字。</p>
<p>在大型分布式系统中，有两件事情非常常见，一是不同服务之间的可能拥有相同的名字，另一个是同一个服务可能会在集群中部署很多的节点，Zookeeper 就可以通过文件系统和顺序节点解决这两个问题。</p>
<p><img src="images/72025ab7142520ce9e59193eb956b900.png" alt="image"></p>
<h3 id="协调分布式事务"><a href="#协调分布式事务" class="headerlink" title="协调分布式事务"></a>协调分布式事务</h3><p>Zookeeper 的另一个作用就是担任分布式事务中的协调者角色，在之前介绍 分布式事务 的文章中我们曾经介绍过分布式事务本质上都是通过 2PC 来实现的，在两阶段提交中就需要一个协调者负责协调分布式事务的执行。</p>
<p>所有的事务参与者会向当前节点中写入提交或者终止，一旦当前的节点改变了事务的状态，其他节点就会得到通知，如果出现一个写入终止的节点，所有的节点就会回滚对分布式事务进行回滚。</p>
<h3 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在数据库中，锁的概念其实是非常重要的，常见的关系型数据库就会对排他锁和共享锁进行支持，而 <code>Zookeeper</code> 提供的 API 也可以让我们非常简单的实现分布式锁。</p>
<p>作为分布式协调服务，Zookeeper 的应用场景非常广泛，不仅能够用于服务配置的下发、命名服务、协调分布式事务以及分布式锁，还能够用来实现微服务治理中的服务注册以及发现等功能，这些其实都源于 Zookeeper 能够提供高可用的分布式协调服务，能够为客户端提供分布式一致性的支持。</p>
<h2 id="ZooKeeper-的缺陷"><a href="#ZooKeeper-的缺陷" class="headerlink" title="ZooKeeper 的缺陷"></a>ZooKeeper 的缺陷</h2><h3 id="zookeeper-不是为高可用性设计的"><a href="#zookeeper-不是为高可用性设计的" class="headerlink" title="zookeeper 不是为高可用性设计的"></a>zookeeper 不是为高可用性设计的</h3><ol>
<li>由于要跨机房容灾，很多系统实际上是需要跨机房部署的。出于性价比的考虑我们通常会让多个机房同时工作，而不会搭建N倍的冗余。也就是说单个机房肯定撑不住全流量（你能设想谷歌在全球只剩下一个机房在干活吗）。由于 zookeeper 集群只能有一个 master，因此一旦机房之间连接出现故障，zookeeper master 就只能照顾一个机房，其他机房运行的业务模块由于没有 master 都只能停掉。于是所有流量集中到有 master 的那个机房，于是系统 crash。</li>
<li>即使是在同一个机房里面，由于网段的不同，在调整机房交换机的时候偶尔也会发生网段隔离的情况。实际上机房每个月基本上都会发生短暂的网络隔离之类的子网段调整。在那个时刻 zookeeper 将处于不可用状态。如果整个业务系统基于 zookeeper （比如要求每个业务请求都先去 zookeeper 获取业务系统的master地址），则系统的可用性将非常脆弱。</li>
<li>由于 zookeeper 对于网络隔离的极度敏感，导致 zookeeper 对于网络的任何风吹草动都会做出激烈反应。这使得 zookeeper 的‘不可用’时间比较多，我们不能让 zookeeper 的‘不可用’，变成系统的不可用。</li>
</ol>
<h3 id="zookeeper-的选举过程速度很慢"><a href="#zookeeper-的选举过程速度很慢" class="headerlink" title="zookeeper 的选举过程速度很慢"></a>zookeeper 的选举过程速度很慢</h3><ol>
<li>这是一个很难从理论分析上看到的弱点，但是你一旦遇到就会痛不欲生。</li>
<li>前面我们已经说过，网络实际上常常是会出现隔离等不完整状态的，而 zookeeper 对那种情况非常敏感。一旦出现网络隔离， zookeeper 就要发起选举流程。</li>
<li>zookeeper 的选举流程通常耗时 30 到 120 秒，期间 zookeeper 由于没有master，都是不可用的。</li>
<li>对于网络里面偶尔出现的，比如半秒一秒的网络隔离，zookeeper 会由于选举过程，而把不可用时间放大几十倍。</li>
</ol>
<h3 id="zookeeper-的性能是有限的"><a href="#zookeeper-的性能是有限的" class="headerlink" title="zookeeper 的性能是有限的"></a>zookeeper 的性能是有限的</h3><ol>
<li>典型的 zookeeper 的 tps(transaction peer secondes) 大概是一万多，无法覆盖系统内部每天动辄几十亿次的调用。因此每次请求都去 zookeeper 获取业务系统 master 信息是不可能的。</li>
<li>因此 zookeeper 的 client 必须自己缓存业务系统的 master 地址。</li>
<li>因此 zookeeper 提供的‘强一致性’实际上是不可用的。如果我们需要强一致性，还需要其他机制来进行保障：比如用自动化脚本把业务系统的 old master 给 kill 掉，但是那会有很多陷阱。</li>
</ol>
<h3 id="zookeeper-无法进行有效的权限控制"><a href="#zookeeper-无法进行有效的权限控制" class="headerlink" title="zookeeper 无法进行有效的权限控制"></a>zookeeper 无法进行有效的权限控制</h3><ol>
<li>zookeeper 的权限控制非常薄弱</li>
<li>在大型的复杂系统里面，使用 zookeeper 必须自己再额外的开发一套权限控制系统，通过那套权限控制系统再访问 zookeeper</li>
<li>额外的权限控制系统不但增加了系统复杂性和维护成本，而且降低了系统的总体性能</li>
</ol>
<h3 id="即使有了-zookeeper-也很难避免业务系统的数据不一致"><a href="#即使有了-zookeeper-也很难避免业务系统的数据不一致" class="headerlink" title="即使有了 zookeeper 也很难避免业务系统的数据不一致"></a>即使有了 zookeeper 也很难避免业务系统的数据不一致</h3><ol>
<li>前面已经讨论过了，由于 zookeeper 的性能限制，我们无法让每次系统内部调用都走 zookeeper ，因此总有某些时刻，业务系统会存在两个 master（业务系统 client 那边缓存的业务系统 master 信息是定时从 zookeeper 更新的，因此会有更新不同步的问题）。</li>
<li>如果要在业务系统 client 的 master 信息不一致的情况下，仍要保持系统的数据一致性的方法是 <em>先 kill 掉老 master ，再在  zookeeper 上更新 master 信息</em>。但是在是否要 kill current master 这个问题上，程序是无法完全自动决定的（因为网络隔离的时候zookeeper已经不可用了，自动脚本没有全局信息，不管怎么做都可能是错的，什么都不做也可能是错的。当网络故障的时候，只有运维人员才有全局信息，程序是无法接电话得知其他机房的情况的）。因此系统无法自动的保障数据一致性，必须要人工介入。而人工介入的典型时间是半个小时以上，我们不能让系统这么长时间不可用。因此我们必须在某个方向上进行妥协，最常见的妥协方式是放弃 ‘强一致性’，而接受‘最终一致性’。</li>
<li>如果我们需要人工介入才能保证‘可靠的强一致性’，那么 zookeeper 的价值就大打折扣。</li>
</ol>
<h3 id="Zookeeper-并不保证读取的是最新数据"><a href="#Zookeeper-并不保证读取的是最新数据" class="headerlink" title="Zookeeper 并不保证读取的是最新数据"></a>Zookeeper 并不保证读取的是最新数据</h3><p>ZooKeeper 并不保证在每个实例中，两个不同的客户端将具有相同的 ZooKeeper 数据的视图。由于诸如网络延迟的因素，一个客户端可以在另一客户端被通知该改变之前执行更新，考虑两个客户端A和B的场景。如果客户端A将 <code>/a</code> 的值从 <code>0</code> 设置为 <code>1</code> ，客户端B读取 <code>/a</code> ，客户端 B 可以读取旧值 0，这取决于它连接到的服务器。如果客户端A 和客户端B 读取相同的值很重要，则客户端B应该在执行读取之前从 ZooKeeper API 方法调用 <code>sync()</code> 方法。</p>
<p>对于 Zookeeper 来说，它实现了A可用性、P分区容错性、C中的写入强一致性，丧失的是C中的读取一致性。</p>
<h3 id="我们能做什么"><a href="#我们能做什么" class="headerlink" title="我们能做什么"></a>我们能做什么</h3><ol>
<li>我们或者选择人工介入的强一致性，或者选择程序自动化进行的弱一致性。需要进行取舍。</li>
<li>最终一致性甚至未必是程序来做的，有时候人工修正数据反而在灵活、可靠、低成本上有优势。这需要权衡。</li>
<li>不要迷信zookeeper，有时候不妨考虑一下主备数据库。数据库自带权限控制，用起来比zookeeper方便多了。</li>
<li>zookeeper 比较有价值的东西也许是内容变化的时候，可以阻塞回调的方式通知所有在线的 client 实时更新信息，但这个功能用处不大。</li>
</ol>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>这段时间来，也在和公司里的一些同学交流使用zk的心得，整理了一些常见的zookeeper问题。这个页面的目标是解答一些zk常见的使用问题，同时也让大家明确zk不能干什么。页面会一直更新。</p>
<h3 id="1-客户端对-ServerList-的轮询机制是什么"><a href="#1-客户端对-ServerList-的轮询机制是什么" class="headerlink" title="1. 客户端对 ServerList 的轮询机制是什么"></a>1. 客户端对 ServerList 的轮询机制是什么</h3><p>随机，客户端在初始化( <code>new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)</code> )的过程中，将所有 <code>Server</code> 保存在一个 <code>List</code> 中，然后随机打散，形成一个环。之后从 0 号位开始一个一个使用。两个注意点：</p>
<ol>
<li>Server地址能够重复配置，这样能够弥补客户端无法设置Server权重的缺陷，但是也会加大风险。（比如: <code>192.168.1.1:2181,192.168.1.1:2181,192.168.1.2:2181</code>).</li>
<li>如果客户端在进行 <code>Server</code> 切换过程中耗时过长，那么将会收到 <code>SESSION_EXPIRED</code> . 这也是上面第1点中的加大风险之处。</li>
</ol>
<h3 id="2-客户端如何正确处理-CONNECTIONLOSS-连接断开-和-SESSIONEXPIRED-Session-过期-两类连接异常"><a href="#2-客户端如何正确处理-CONNECTIONLOSS-连接断开-和-SESSIONEXPIRED-Session-过期-两类连接异常" class="headerlink" title="2. 客户端如何正确处理 CONNECTIONLOSS (连接断开) 和 SESSIONEXPIRED (Session 过期)两类连接异常"></a>2. 客户端如何正确处理 CONNECTIONLOSS (连接断开) 和 SESSIONEXPIRED (Session 过期)两类连接异常</h3><p>在 ZooKeeper 中，服务器和客户端之间维持的是一个 <strong>长连接</strong>，在 <code>SESSION_TIMEOUT</code> 时间内，服务器会确定客户端是否正常连接(客户端会定时向服务器发送 <code>heart_beat</code> ),服务器重置下次 <code>SESSION_TIMEOUT</code> 时间。因此，在正常情况下， <code>Session</code> 一直有效，并且 <strong><code>zk</code> 集群所有机器上都保存这个 <code>Session</code> 信息</strong>。在出现问题情况下，客户端与服务器之间连接断了（客户端所连接的那台zk机器挂了，或是其它原因的网络闪断），这个时候客户端会主动在地址列表（初始化的时候传入构造方法的那个参数 <code>connectString</code> ）中选择新的地址进行连接。  </p>
<p>好了，上面基本就是服务器与客户端之间维持长连接的过程了。在这个过程中，用户可能会看到两类异常 <code>CONNECTIONLOSS</code> (连接断开) 和 <code>SESSIONEXPIRED</code> (Session 过期)。</p>
<ul>
<li><code>CONNECTIONLOSS</code> ：应用在进行操作A时，发生了 <code>CONNECTIONLOSS</code> ，此时用户不需要关心我的会话是否可用，应用所要做的就是等待客户端帮我们自动连接上新的 <code>zk</code> 机器，一旦成功连接上新的 <code>zk</code> 机器后，确认刚刚的操作A是否执行成功了。  </li>
<li><code>SESSIONEXPIRED</code> ：这个通常是zk客户端与服务器的连接断了，试图连接上新的 <code>zk</code> 机器，这个过程如果耗时过长，超过 <code>SESSION_TIMEOUT</code> 后还没有成功连接上服务器，那么服务器认为这个 <code>session</code> 已经结束了（服务器无法确认是因为其它异常原因还是客户端主动结束会话），开始清除和这个会话有关的信息，包括这个会话创建的临时节点和注册的 <code>Watcher</code> 。在这之后，客户端重新连接上了服务器在，但是很不幸，服务器会告诉客户端 <code>SESSIONEXPIRED</code> 。此时客户端要做的事情就看应用的复杂情况了，总之，要重新实例 <code>zookeeper</code> 对象，重新操作所有临时数据（包括临时节点和注册 <code>Watcher</code> ）。</li>
</ul>
<h3 id="3-不同的客户端对同一个节点是否能获取相同的数据"><a href="#3-不同的客户端对同一个节点是否能获取相同的数据" class="headerlink" title="3. 不同的客户端对同一个节点是否能获取相同的数据"></a>3. 不同的客户端对同一个节点是否能获取相同的数据</h3><h3 id="4-一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗"><a href="#4-一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗" class="headerlink" title="4. 一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗"></a>4. 一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗</h3><p><code>ZooKeeper</code> <strong>不能确保任何客户端能够获取（即 <code>Read Request</code> ）到一样的数据</strong>，除非客户端自己要求：方法是客户端在获取数据之前调用<code>org.apache.zookeeper.AsyncCallback.VoidCallback, java.lang.Object) sync</code>.  </p>
<p>通常情况下（这里所说的通常情况满足：1. 对获取的数据是否是最新版本不敏感，2. 一个客户端修改了数据，其它客户端需要不需要立即能够获取最新），可以不关心这点。  </p>
<p>在其它情况下，最清晰的场景是这样：ZK 客户端 A 对 <code>/my_test</code> 的内容从 <code>v1-&gt;v2</code>, 但是 ZK 客户端 B 对 <code>/my_test</code> 的内容获取，依然得到的是 <code>v1</code>. 请注意，这个是实际存在的现象，当然延时很短。解决的方法是客户端B先调用 <code>sync()</code>, 再调用 <code>getData()</code>.</p>
<h3 id="5-ZK为什么不提供一个永久性的Watcher注册机制"><a href="#5-ZK为什么不提供一个永久性的Watcher注册机制" class="headerlink" title="5. ZK为什么不提供一个永久性的Watcher注册机制"></a>5. ZK为什么不提供一个永久性的Watcher注册机制</h3><p>不支持用持久Watcher的原因很简单，ZK无法保证性能。</p>
<h3 id="6-使用watch需要注意的几点"><a href="#6-使用watch需要注意的几点" class="headerlink" title="6. 使用watch需要注意的几点"></a>6. 使用watch需要注意的几点</h3><ol>
<li><code>Watches</code> 通知是一次性的，必须重复注册.  </li>
<li>发生 <code>CONNECTIONLOSS</code> 之后，只要在 <code>session_timeout</code> 之内再次连接上（即不发生 <code>SESSIONEXPIRED</code> ），那么这个连接注册的 <code>watches</code> 依然在。  </li>
<li>节点数据的版本变化会触发 <code>NodeDataChanged</code> ，注意，这里特意说明了是版本变化。存在这样的情况，只要成功执行了 <code>setData()</code>方法，无论内容是否和之前一致，都会触发 <code>NodeDataChanged</code> 。  </li>
<li>对某个节点注册了 <code>watch</code> ，但是节点被删除了，那么注册在这个节点上的 <code>watches</code> 都会被移除。  </li>
<li>同一个 zk 客户端对某一个节点注册相同的 <code>watch</code> ，只会收到一次通知。</li>
<li><code>Watcher</code> 对象只会保存在客户端，不会传递到服务端。</li>
</ol>
<h3 id="7-我能否收到每次节点变化的通知"><a href="#7-我能否收到每次节点变化的通知" class="headerlink" title="7. 我能否收到每次节点变化的通知"></a>7. 我能否收到每次节点变化的通知</h3><p><strong>如果节点数据的更新频率很高的话，不能</strong>。</p>
<p>原因在于：当一次数据修改，通知客户端，客户端再次注册 <code>watch</code> ，在这个过程中，可能数据已经发生了许多次数据修改，因此，千万不要做这样的测试：”数据被修改了n次，一定会收到n次通知”来测试 <code>server</code> 是否正常工作。</p>
<h3 id="8-能为临时节点创建子节点吗"><a href="#8-能为临时节点创建子节点吗" class="headerlink" title="8. 能为临时节点创建子节点吗"></a>8. 能为临时节点创建子节点吗</h3><p>不能。</p>
<h3 id="9-是否可以拒绝单个IP对ZK的访问-操作"><a href="#9-是否可以拒绝单个IP对ZK的访问-操作" class="headerlink" title="9. 是否可以拒绝单个IP对ZK的访问,操作"></a>9. 是否可以拒绝单个IP对ZK的访问,操作</h3><p>ZK 本身不提供这样的功能，它仅仅提供了对单个 IP 的连接数的限制。你可以通过修改 iptables 来实现对单个 ip 的限制。</p>
<h3 id="10-在-getChildren-String-path-boolean-watch-注册对节点子节点的变化，那么子节点的子节点变化能通知吗"><a href="#10-在-getChildren-String-path-boolean-watch-注册对节点子节点的变化，那么子节点的子节点变化能通知吗" class="headerlink" title="10. 在[getChildren(String path, boolean watch)]注册对节点子节点的变化，那么子节点的子节点变化能通知吗"></a>10. 在[<code>getChildren(String path, boolean watch)</code>]注册对节点子节点的变化，那么子节点的子节点变化能通知吗</h3><p>不能</p>
<h3 id="11-创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？"><a href="#11-创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？" class="headerlink" title="11. 创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？"></a>11. 创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？</h3><p>连接断了之后，ZK 不会马上移除临时数据，只有当 <code>SESSIONEXPIRED</code> 之后，才会把这个会话建立的临时数据移除。因此，用户需要谨慎设置 <code>Session_TimeOut</code></p>
<h3 id="12-zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？"><a href="#12-zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？" class="headerlink" title="12. zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？"></a>12. zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？</h3><p>3.4.3版本的zookeeper，还不支持这个功能，在3.5.0版本开始，支持动态加机器了。</p>
<h3 id="13-ZooKeeper集群中个服务器之间是怎样通信的？"><a href="#13-ZooKeeper集群中个服务器之间是怎样通信的？" class="headerlink" title="13. ZooKeeper集群中个服务器之间是怎样通信的？"></a>13. ZooKeeper集群中个服务器之间是怎样通信的？</h3><p>Leader服务器会和每一个 <code>Follower/Observer</code> 服务器都建立TCP连接，同时为每个 <code>F/O</code> 都创建一个叫做 <code>LearnerHandler</code> 的实体。LearnerHandler 主要负责 Leader 和 F/O 之间的网络通讯，包括数据同步，请求转发和 <code>Proposal</code> 提议的投票等。Leader 服务器保存了所有 F/O 的 <code>LearnerHandler</code> 。</p>
<h3 id="14-zookeeper是否会自动进行日志清理？如果进行日志清理？"><a href="#14-zookeeper是否会自动进行日志清理？如果进行日志清理？" class="headerlink" title="14.zookeeper是否会自动进行日志清理？如果进行日志清理？"></a>14.zookeeper是否会自动进行日志清理？如果进行日志清理？</h3><p>zk自己不会进行日志清理，需要运维人员进行日志清理</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://jm.taobao.org/2013/10/07/zookeeper-faq/" target="_blank" rel="noopener">ZooKeeper FAQ</a></li>
<li><a href="https://www.cnblogs.com/IcanFixIt/p/7818592.html" target="_blank" rel="noopener">Apache ZooKeeper数据模型</a></li>
<li><a href="http://www.crazyant.net/2120.html" target="_blank" rel="noopener">Zookeeper并不保证读取的是最新数据</a></li>
<li><a href="https://draveness.me/zookeeper-chubby" target="_blank" rel="noopener">详解分布式协调服务 ZooKeeper</a></li>
<li><a href="https://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html" target="_blank" rel="noopener">ZooKeeper 架构</a></li>
<li><a href="http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/" target="_blank" rel="noopener">阿里巴巴为什么不用ZooKeeper 做服务发现？</a></li>
<li><a href="http://ningg.top/zookeeper-lesson-2-leader-election/" target="_blank" rel="noopener">ZooKeeper 技术内幕：Leader 选举</a></li>
<li><a href="http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/01/zookeeper.html" target="_blank" rel="noopener">Zookeeper: 分布式过程协同技术详解</a></li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/code/" rel="tag"># code</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2018/05/20/Mybatis-动态sql/" rel="next" title="Mybatis 动态sql">
                  <i class="fa fa-chevron-left"></i> Mybatis 动态sql
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2018/08/22/dubbo-相关/" rel="prev" title="dubbo 相关">
                  dubbo 相关 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式系统架构基础"><span class="nav-number">1.</span> <span class="nav-text">[分布式系统架构基础]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAP"><span class="nav-number">1.1.</span> <span class="nav-text">CAP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据一致性模型"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据一致性模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性解决方案"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">一致性解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务可用性"><span class="nav-number">1.1.2.</span> <span class="nav-text">服务可用性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高可用解决方案"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">高可用解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区容错性"><span class="nav-number">1.1.3.</span> <span class="nav-text">分区容错性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高并发下的流量控制"><span class="nav-number">2.</span> <span class="nav-text">高并发下的流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#限流算法"><span class="nav-number">2.1.</span> <span class="nav-text">限流算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计数器"><span class="nav-number">2.1.1.</span> <span class="nav-text">计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#漏桶"><span class="nav-number">2.1.2.</span> <span class="nav-text">漏桶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#令牌桶"><span class="nav-number">2.1.3.</span> <span class="nav-text">令牌桶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群限流"><span class="nav-number">2.2.</span> <span class="nav-text">集群限流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-请求窗口"><span class="nav-number">2.2.1.</span> <span class="nav-text">Redis 请求窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx-限流"><span class="nav-number">2.2.2.</span> <span class="nav-text">Nginx 限流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式缓存"><span class="nav-number">3.</span> <span class="nav-text">分布式缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景"><span class="nav-number">3.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见问题和挑战"><span class="nav-number">3.2.</span> <span class="nav-text">常见问题和挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">3.2.1.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透"><span class="nav-number">3.2.2.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存预热"><span class="nav-number">3.2.3.</span> <span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存更新"><span class="nav-number">3.2.4.</span> <span class="nav-text">缓存更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存降级"><span class="nav-number">3.2.5.</span> <span class="nav-text">缓存降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存与数据库不一致问题"><span class="nav-number">3.2.6.</span> <span class="nav-text">缓存与数据库不一致问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先删除缓存，再更新数据库"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">先删除缓存，再更新数据库</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC"><span class="nav-number">4.</span> <span class="nav-text">RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用发展流程"><span class="nav-number">4.1.</span> <span class="nav-text">应用发展流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一应用架构"><span class="nav-number">4.1.1.</span> <span class="nav-text">单一应用架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垂直应用架构"><span class="nav-number">4.1.2.</span> <span class="nav-text">垂直应用架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式服务架构"><span class="nav-number">4.1.3.</span> <span class="nav-text">分布式服务架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流动计算架构"><span class="nav-number">4.1.4.</span> <span class="nav-text">流动计算架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式锁"><span class="nav-number">5.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现基于数据库的乐观锁"><span class="nav-number">5.1.</span> <span class="nav-text">实现基于数据库的乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-Redis-的分布式锁"><span class="nav-number">5.2.</span> <span class="nav-text">基于 Redis 的分布式锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式-Session"><span class="nav-number">6.</span> <span class="nav-text">分布式 Session</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Session-Stick"><span class="nav-number">6.1.</span> <span class="nav-text">Session Stick</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session复制"><span class="nav-number">6.2.</span> <span class="nav-text">Session复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session集中管理"><span class="nav-number">6.3.</span> <span class="nav-text">Session集中管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于Cookie管理"><span class="nav-number">6.4.</span> <span class="nav-text">基于Cookie管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#短链接"><span class="nav-number">7.</span> <span class="nav-text">短链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用场景-Scenario"><span class="nav-number">7.1.</span> <span class="nav-text">使用场景(Scenario)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求-Needs"><span class="nav-number">7.2.</span> <span class="nav-text">需求(Needs)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#短网址的长度"><span class="nav-number">7.3.</span> <span class="nav-text">短网址的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一对一还是一对多映射？"><span class="nav-number">7.4.</span> <span class="nav-text">一对一还是一对多映射？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何计算短网址"><span class="nav-number">7.5.</span> <span class="nav-text">如何计算短网址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何存储"><span class="nav-number">7.6.</span> <span class="nav-text">如何存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#301还是302重定向"><span class="nav-number">7.7.</span> <span class="nav-text">301还是302重定向</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式事务"><span class="nav-number">8.</span> <span class="nav-text">分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2PC-与-3PC"><span class="nav-number">8.1.</span> <span class="nav-text">2PC 与 3PC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2PC"><span class="nav-number">8.2.</span> <span class="nav-text">2PC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3PC"><span class="nav-number">8.2.1.</span> <span class="nav-text">3PC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息服务"><span class="nav-number">8.3.</span> <span class="nav-text">消息服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper"><span class="nav-number">9.</span> <span class="nav-text">Zookeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式应用"><span class="nav-number">9.1.</span> <span class="nav-text">分布式应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式应用的优点"><span class="nav-number">9.1.1.</span> <span class="nav-text">分布式应用的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式应用的挑战"><span class="nav-number">9.1.2.</span> <span class="nav-text">分布式应用的挑战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper基础"><span class="nav-number">9.2.</span> <span class="nav-text">ZooKeeper基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#架构"><span class="nav-number">9.2.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据模型"><span class="nav-number">9.2.2.</span> <span class="nav-text">数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Znode"><span class="nav-number">9.2.3.</span> <span class="nav-text">Znode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sessions"><span class="nav-number">9.2.4.</span> <span class="nav-text">Sessions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Watcher"><span class="nav-number">9.2.5.</span> <span class="nav-text">Watcher</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-工作流程"><span class="nav-number">9.3.</span> <span class="nav-text">Zookeeper 工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-Service-节点数量的影响"><span class="nav-number">9.3.1.</span> <span class="nav-text">ZooKeeper Service 节点数量的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选举"><span class="nav-number">9.3.2.</span> <span class="nav-text">选举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-1"><span class="nav-number">9.4.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发布订阅"><span class="nav-number">9.4.1.</span> <span class="nav-text">发布订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名服务"><span class="nav-number">9.4.2.</span> <span class="nav-text">命名服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协调分布式事务"><span class="nav-number">9.4.3.</span> <span class="nav-text">协调分布式事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁-1"><span class="nav-number">9.4.4.</span> <span class="nav-text">分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper-的缺陷"><span class="nav-number">9.5.</span> <span class="nav-text">ZooKeeper 的缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper-不是为高可用性设计的"><span class="nav-number">9.5.1.</span> <span class="nav-text">zookeeper 不是为高可用性设计的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper-的选举过程速度很慢"><span class="nav-number">9.5.2.</span> <span class="nav-text">zookeeper 的选举过程速度很慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper-的性能是有限的"><span class="nav-number">9.5.3.</span> <span class="nav-text">zookeeper 的性能是有限的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper-无法进行有效的权限控制"><span class="nav-number">9.5.4.</span> <span class="nav-text">zookeeper 无法进行有效的权限控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#即使有了-zookeeper-也很难避免业务系统的数据不一致"><span class="nav-number">9.5.5.</span> <span class="nav-text">即使有了 zookeeper 也很难避免业务系统的数据不一致</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper-并不保证读取的是最新数据"><span class="nav-number">9.5.6.</span> <span class="nav-text">Zookeeper 并不保证读取的是最新数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们能做什么"><span class="nav-number">9.5.7.</span> <span class="nav-text">我们能做什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FAQ"><span class="nav-number">9.6.</span> <span class="nav-text">FAQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-客户端对-ServerList-的轮询机制是什么"><span class="nav-number">9.6.1.</span> <span class="nav-text">1. 客户端对 ServerList 的轮询机制是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-客户端如何正确处理-CONNECTIONLOSS-连接断开-和-SESSIONEXPIRED-Session-过期-两类连接异常"><span class="nav-number">9.6.2.</span> <span class="nav-text">2. 客户端如何正确处理 CONNECTIONLOSS (连接断开) 和 SESSIONEXPIRED (Session 过期)两类连接异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-不同的客户端对同一个节点是否能获取相同的数据"><span class="nav-number">9.6.3.</span> <span class="nav-text">3. 不同的客户端对同一个节点是否能获取相同的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗"><span class="nav-number">9.6.4.</span> <span class="nav-text">4. 一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ZK为什么不提供一个永久性的Watcher注册机制"><span class="nav-number">9.6.5.</span> <span class="nav-text">5. ZK为什么不提供一个永久性的Watcher注册机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-使用watch需要注意的几点"><span class="nav-number">9.6.6.</span> <span class="nav-text">6. 使用watch需要注意的几点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-我能否收到每次节点变化的通知"><span class="nav-number">9.6.7.</span> <span class="nav-text">7. 我能否收到每次节点变化的通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-能为临时节点创建子节点吗"><span class="nav-number">9.6.8.</span> <span class="nav-text">8. 能为临时节点创建子节点吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-是否可以拒绝单个IP对ZK的访问-操作"><span class="nav-number">9.6.9.</span> <span class="nav-text">9. 是否可以拒绝单个IP对ZK的访问,操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-在-getChildren-String-path-boolean-watch-注册对节点子节点的变化，那么子节点的子节点变化能通知吗"><span class="nav-number">9.6.10.</span> <span class="nav-text">10. 在[getChildren(String path, boolean watch)]注册对节点子节点的变化，那么子节点的子节点变化能通知吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？"><span class="nav-number">9.6.11.</span> <span class="nav-text">11. 创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？"><span class="nav-number">9.6.12.</span> <span class="nav-text">12. zookeeper是否支持动态进行机器扩容？如果目前不支持，那么要如何扩容呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-ZooKeeper集群中个服务器之间是怎样通信的？"><span class="nav-number">9.6.13.</span> <span class="nav-text">13. ZooKeeper集群中个服务器之间是怎样通信的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-zookeeper是否会自动进行日志清理？如果进行日志清理？"><span class="nav-number">9.6.14.</span> <span class="nav-text">14.zookeeper是否会自动进行日志清理？如果进行日志清理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">9.7.</span> <span class="nav-text">参考文档</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leon</p>
  <div class="site-description" itemprop="description">挪威的森林</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ReonYu" title="GitHub &rarr; https://github.com/ReonYu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leon</span>
</div>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div>

        












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>

  <script defer src="/lib/three/three.min.js"></script>
    
    <script defer src="/lib/three/three-waves.min.js"></script>
  


  





















  

  

  

</body>
</html>
